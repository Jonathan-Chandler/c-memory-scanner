<!doctype html>
<html>
<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<title>Chicken &raquo; Deviations from the standard</title>
<meta name="viewport" content="initial-scale=1" /></head>
<body>
<div id="body">
<div id="main"><h2 id="sec:Confirmed_deviations_from_R5RS"><a href="#sec:Confirmed_deviations_from_R5RS">Confirmed deviations from R5RS</a></h2><p>Identifiers are by default case-sensitive (see <a href="Using%20the%20compiler.html">Using the compiler</a>).</p><h3 id="sec:Number_of_arguments_to_procedures_and_macros"><a href="#sec:Number_of_arguments_to_procedures_and_macros">Number of arguments to procedures and macros</a></h3><p>The maximal number of arguments that may be passed to a compiled procedure or macro is limited to around 1000. Likewise, the maximum number of values that can be passed to continuations captured using <tt>call-with-current-continuation</tt> is 1000.  This is an implementation restriction that is unlikely to be lifted.</p><h3 id="sec:Numeric_string-conversion_considerations"><a href="#sec:Numeric_string-conversion_considerations">Numeric string-conversion considerations</a></h3><p>In some cases the runtime system uses the numerical string-conversion routines of the underlying C library.  Consequently, the procedures <tt>string-&gt;number</tt>, <tt>read</tt>, <tt>write</tt>, and <tt>display</tt> do not obey read/write invariance for inexact numbers.</p><h3 id="sec:Environments_and_non-standard_syntax"><a href="#sec:Environments_and_non-standard_syntax">Environments and non-standard syntax</a></h3><p>In addition to the standard bindings, <tt>scheme-report-environment</tt> and <tt>null-environment</tt> contain additional non-standard bindings for the following syntactic forms: <tt>import</tt>, <tt>require-extension</tt>, <tt>require-library</tt>, <tt>begin-for-syntax</tt>, <tt>export</tt>, <tt>module</tt>, <tt>cond-expand</tt>, <tt>syntax</tt>, <tt>reexport</tt>, <tt>import-for-syntax</tt>.</p><h3 id="sec:Assignment_to_unbound_variables"><a href="#sec:Assignment_to_unbound_variables">Assignment to unbound variables</a></h3><p><tt>set!</tt> may assign values to unbound variables; this creates a new top-level binding for the variable, as if <tt>define</tt> had been used instead. This extension must be used with care, as typos might cause unexpected results:</p>
<pre class="highlight colorize">&gt; <span class="paren1">(<span class="default"><i><span class="symbol">let</span></i> <span class="paren2">(<span class="default"><span class="paren3">(<span class="default">frob 5</span>)</span></span>)</span>
    <span class="paren2">(<span class="default">set! frov <span class="paren3">(<span class="default">+ frob 1</span>)</span></span>)</span>  <span class="comment">; oops!
</span>    frob</span>)</span>
&gt; 5
&gt; frov
&gt; 6</pre><h2 id="sec:Unconfirmed_deviations"><a href="#sec:Unconfirmed_deviations">Unconfirmed deviations</a></h2><h3 id="sec:char-ready.3f"><a href="#sec:char-ready.3f"><tt>char-ready?</tt></a></h3><p>The procedure <tt>char-ready?</tt> always returns <tt>#t</tt> for terminal ports.</p><h2 id="sec:Doubtful_deviations"><a href="#sec:Doubtful_deviations">Doubtful deviations</a></h2><h3 id="sec:letrec"><a href="#sec:letrec"><tt>letrec</tt></a></h3><p><tt>letrec</tt> does evaluate the initial values for the bound variables sequentially and not in parallel, that is:</p>
<pre class="highlight colorize"><span class="paren1">(<span class="default">letrec <span class="paren2">(<span class="default"><span class="paren3">(<span class="default">x 1</span>)</span> <span class="paren3">(<span class="default">y 2</span>)</span></span>)</span> <span class="paren2">(<span class="default">cons x y</span>)</span></span>)</span></pre><p>is equivalent to</p>
<pre class="highlight colorize"><span class="paren1">(<span class="default"><i><span class="symbol">let</span></i> <span class="paren2">(<span class="default"><span class="paren3">(<span class="default">x <span class="paren4">(<span class="default">void</span>)</span></span>)</span> <span class="paren3">(<span class="default">y <span class="paren4">(<span class="default">void</span>)</span></span>)</span></span>)</span>
  <span class="paren2">(<span class="default">set! x 1</span>)</span>
  <span class="paren2">(<span class="default">set! y 2</span>)</span>
  <span class="paren2">(<span class="default">cons x y</span>)</span> </span>)</span></pre><p>where R5RS requires</p>
<pre class="highlight colorize"><span class="paren1">(<span class="default"><i><span class="symbol">let</span></i> <span class="paren2">(<span class="default"><span class="paren3">(<span class="default">x <span class="paren4">(<span class="default">void</span>)</span></span>)</span> <span class="paren3">(<span class="default">y <span class="paren4">(<span class="default">void</span>)</span></span>)</span></span>)</span>
  <span class="paren2">(<span class="default"><i><span class="symbol">let</span></i> <span class="paren3">(<span class="default"><span class="paren4">(<span class="default">tmp1 1</span>)</span> <span class="paren4">(<span class="default">tmp2 2</span>)</span></span>)</span>
    <span class="paren3">(<span class="default">set! x tmp1</span>)</span>
    <span class="paren3">(<span class="default">set! y tmp2</span>)</span>
    <span class="paren3">(<span class="default">cons x y</span>)</span> </span>)</span> </span>)</span></pre><p>It is unclear whether R5RS permits this behavior or not; in any case, this only affects letrecs where the bound values are not lambda-expressions.</p><h2 id="sec:Non-deviations_that_might_surprise_you"><a href="#sec:Non-deviations_that_might_surprise_you">Non-deviations that might surprise you</a></h2><h3 id="sec:let-syntax_and_letrec-syntax"><a href="#sec:let-syntax_and_letrec-syntax"><tt>let-syntax</tt> and <tt>letrec-syntax</tt></a></h3><p><tt>let-syntax</tt> and <tt>letrec-syntax</tt> introduce a new scope.</p><h3 id="sec:equal.3f_compares_all_structured_data_recursively"><a href="#sec:equal.3f_compares_all_structured_data_recursively"><tt>equal?</tt> compares all structured data recursively</a></h3><p><tt>equal?</tt> compares all structured data with the exception of procedures recursively, while R5RS specifies that <tt>eqv?</tt> is used for data other than pairs, strings and vectors.  However, R5RS does not dictate the treatment of data types that are not specified by R5RS</p><h3 id="sec:transcript-on_and_transcript-off_are_not_implemented"><a href="#sec:transcript-on_and_transcript-off_are_not_implemented"><tt>transcript-on</tt> and <tt>transcript-off</tt> are not implemented</a></h3><p>The <tt>transcript-on</tt> and <tt>transcript-off</tt> procedures are not implemented.  R5RS does not require them.</p><hr /><p>Previous: <a href="Using%20the%20compiler.html">Using the compiler</a></p><p>Next: <a href="Extensions%20to%20the%20standard.html">Extensions to the standard</a></p></div></div></body></html>