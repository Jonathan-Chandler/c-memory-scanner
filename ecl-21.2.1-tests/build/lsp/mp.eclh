
#ifdef ECL_DYNAMIC_VV
static cl_object *VV;
#else
static cl_object VV[VM];
#endif

#ifdef __cplusplus
extern "C" {
#endif
static cl_object LC1without_interrupts(cl_object , cl_object );
static cl_object LC2with_interrupts(cl_object , cl_object );
static cl_object LC3with_lock(cl_object , cl_object );
static cl_object LC4define_cas_expander(cl_object , cl_object );
static cl_object LC5defcas(cl_object , cl_object );
static cl_object L6special_variable_p(cl_object );
static cl_object L7remcas(cl_object );
static cl_object L8get_cas_expansion(cl_narg, cl_object , ...);
static cl_object LC9compare_and_swap(cl_object , cl_object );
static cl_object LC10__lambda66(cl_narg, cl_object , ...);
static cl_object LC11__lambda70(cl_narg, cl_object , ...);
static cl_object LC12__lambda74(cl_narg, cl_object , ...);
static cl_object LC13__lambda78(cl_narg, cl_object , ...);
static cl_object LC14__lambda82(cl_narg, cl_object , ...);
static cl_object LC15__lambda86(cl_narg, cl_object , ...);
static cl_object LC16__lambda90(cl_narg, cl_object , ...);
static cl_object LC17__lambda94(cl_narg, cl_object , ...);
static cl_object LC18__lambda98(cl_narg, cl_object , ...);
static cl_object LC19__lambda102(cl_narg, cl_object , ...);
static cl_object LC20atomic_update(cl_object , cl_object );
static cl_object LC21atomic_push(cl_object , cl_object );
static cl_object LC22atomic_pop(cl_object , cl_object );
static cl_object LC23atomic_incf(cl_object , cl_object );
static cl_object LC24atomic_decf(cl_object , cl_object );
static cl_object Cblock;
#define VM 75
#define VMtemp 11
#define ECL_DEFINE_SETF_FUNCTIONS 
#ifdef __cplusplus
}
#endif
/*
 * Statically defined constants
 */
ecl_def_ct_base_string(_ecl_static_7,"PROCESS",7,static,const);
ecl_def_ct_base_string(_ecl_static_6,"COUNT",5,static,const);
ecl_def_ct_base_string(_ecl_static_5,"OWNER",5,static,const);
ecl_def_ct_base_string(_ecl_static_4,"LOCK",4,static,const);
ecl_def_ct_base_string(_ecl_static_3,"ENABLEP",7,static,const);
ecl_def_ct_base_string(_ecl_static_2,"ALLOWP",6,static,const);
ecl_def_ct_base_string(_ecl_static_1,"OUTER-INTERRUPTS-ENABLED",24,static,const);
ecl_def_ct_base_string(_ecl_static_0,"OUTER-ALLOW-WITH-INTERRUPTS",27,static,const);
/*
 * Exported Lisp functions
 */
#define compiler_cfuns_size 13
static const struct ecl_cfunfixed compiler_cfuns[] = {
 /*t,m,narg,padding,name=function-location,block=name-location,entry,entry_fixed,file,file_position*/
{0,0,2,0,ecl_make_fixnum(59),ecl_make_fixnum(14),(cl_objectfn)LC1without_interrupts,NULL,ECL_NIL,ecl_make_fixnum(728)},
{0,0,2,0,ecl_make_fixnum(60),ecl_make_fixnum(16),(cl_objectfn)LC2with_interrupts,NULL,ECL_NIL,ecl_make_fixnum(3883)},
{0,0,2,0,ecl_make_fixnum(61),ecl_make_fixnum(18),(cl_objectfn)LC3with_lock,NULL,ECL_NIL,ecl_make_fixnum(4919)},
{0,0,2,0,ecl_make_fixnum(63),ecl_make_fixnum(26),(cl_objectfn)LC4define_cas_expander,NULL,ECL_NIL,ecl_make_fixnum(7176)},
{0,0,2,0,ecl_make_fixnum(65),ecl_make_fixnum(33),(cl_objectfn)LC5defcas,NULL,ECL_NIL,ecl_make_fixnum(9457)},
{0,0,1,0,ecl_make_fixnum(67),ecl_make_fixnum(36),(cl_objectfn)L7remcas,NULL,ECL_NIL,ecl_make_fixnum(10592)},
{0,0,-2,0,ecl_make_fixnum(68),ecl_make_fixnum(38),(cl_objectfn)L8get_cas_expansion,NULL,ECL_NIL,ecl_make_fixnum(11218)},
{0,0,2,0,ecl_make_fixnum(69),ecl_make_fixnum(39),(cl_objectfn)LC9compare_and_swap,NULL,ECL_NIL,ecl_make_fixnum(12028)},
{0,0,2,0,ecl_make_fixnum(70),ecl_make_fixnum(45),(cl_objectfn)LC20atomic_update,NULL,ECL_NIL,ecl_make_fixnum(13811)},
{0,0,2,0,ecl_make_fixnum(71),ecl_make_fixnum(46),(cl_objectfn)LC21atomic_push,NULL,ECL_NIL,ecl_make_fixnum(14576)},
{0,0,2,0,ecl_make_fixnum(72),ecl_make_fixnum(47),(cl_objectfn)LC22atomic_pop,NULL,ECL_NIL,ecl_make_fixnum(15025)},
{0,0,2,0,ecl_make_fixnum(73),ecl_make_fixnum(57),(cl_objectfn)LC23atomic_incf,NULL,ECL_NIL,ecl_make_fixnum(15449)},
{0,0,2,0,ecl_make_fixnum(74),ecl_make_fixnum(58),(cl_objectfn)LC24atomic_decf,NULL,ECL_NIL,ecl_make_fixnum(17299)},
};
