static const struct ecl_base_string compiler_data_text1[] = {
        (int8_t)t_base_string, 0, ecl_aet_bc, 0,
        ECL_NIL, (cl_index)21159, (cl_index)21159,
        (ecl_base_char*)
"si::*quit-tags* si::*break-level* si::*break-env* si::*ihs-base* si::*ihs-top* s"
 "i::*ihs-current* si::*frs-base* si::*frs-top* si::*tpl-continuable* si::*tpl-pro"
 "mpt-hook* si::*eof* si::*last-error* si::*break-message* si::*break-condition* s"
 "i::*break-readtable* si::*tpl-level* si::*break-hidden-functions* si::*break-hid"
 "den-packages* si::tpl-commands si::*tpl-commands* si::break-commands si::*lisp-i"
 "nitialized* \"CL-USER\" \"ECL (Embeddable Common-Lisp) ~A (git:~D)\" \"~%Copyright (C"
 ") 1984 Taiichi Yuasa and Masami Hagiya~@\nCopyright (C) 1993 Giuseppe Attardi~@\nC"
 "opyright (C) 2013 Juan J. Garcia-Ripoll~@\nCopyright (C) 2018 Daniel Kochmanski~@"
 "\nCopyright (C) 2021 Daniel Kochmanski and Marius Gerbershagen~@\nECL is free soft"
 "ware, and you are welcome to redistribute it~@\nunder certain conditions; see fil"
 "e 'Copyright' for details.\" \"~%Type :h for Help.  \" si::top-level si::*console-l"
 "ock* si::*console-available* si::*console-owner* si::*console-waiting-list* si::"
 "candidate-to-get-console-p si::register-in-waiting-list si::delete-from-waiting-"
 "list si::grab-console si::release-console (si::register-in-waiting-list mp::*cur"
 "rent-process*) (si::grab-console mp::*current-process*) ((si::delete-from-waitin"
 "g-list mp::*current-process*) (si::release-console mp::*current-process*)) si::w"
 "ith-grabbed-console si::*allow-recursive-debug* si::*debug-status* si::simple-te"
 "rminal-interrupt \"~%  >~D: ~s\" \"~%   ~D: ~s\" si::show-process-list \"~&Choose the"
 " integer code of process to interrupt.\nUse special code 0 to cancel this operati"
 "on.\" \"~&Not a valid process number\" si::query-process si::*interrupt-lonely-thre"
 "ads-p* si::single-threaded-terminal-interrupt 0 0 \"~%;;; Suspending process ~A\" "
 ":report-function \"Interrupt a certain process.\" :interactive-function si::termin"
 "al-interrupt \"~&Debugger received error of type: ~A~%~A~%~\n                     "
 "                    Error flushed.~%\" si::restart-toplevel \"Go back to Top-Level"
 " REPL.\" si::restart-debugger \"Go back to debugger level ~D.\" si::tpl \"~A~V,,,'>A"
 " \" si::cl-user \"\" si::tpl-prompt 0 \"Ignoring an unmatched right parenthesis.\" 0 "
 "0 0 0 :newline (#\\  #\\Tab #\\Newline #\\Return :eof) :help si::tpl-read si::*debug"
 "-tpl-commands* si::tpl-command ((error (lambda (condition) (unless si::*debug-tp"
 "l-commands* (format t \"~&Command aborted.~%Received condition of type: ~A~%~A\" ("
 "type-of condition) condition) (clear-input) (return-from si::tpl-command nil))))"
 ") si::harden-command si::tpl-unknown-command :restart :eval :string :constant si"
 "::tpl-make-command si::tpl-parse-forms si::tpl-parse-strings si::tpl-print \"Unkn"
 "own top level command: ~s~%\" si::tpl-pop-command si::tpl-quit-command si::tpl-pr"
 "evious si::tpl-next si::tpl-go si::tpl-print-message \" Function cannot be disass"
 "embled.~%\" si::tpl-disassemble-command \" No source code available for this funct"
 "ion.~%\" si::tpl-lambda-expression-command clos::lambda-list ext::function-lambda"
 "-list si::decode-env-elt si::decode-ihs-env \"KEYWORD\" si::ihs-environment \"~% ~S"
 "\" \"~% ~S: ~S\" \"none\" si::tpl-print-variables \"~:[~;Local functions: ~:*~{~s~^, ~"
 "}.~%~]\" \"~:[~;Block names: ~:*~{~s~^, ~}.~%~]\" \"New restarts:\" \"~% ~A: ~A\" \"~%Lo"
 "cal variables: \" \"~%Special variables: \" si::tpl-variables-command si::tpl-inspe"
 "ct-command \"<unbound value>\" \"Variable not found.~%\" \"BDS[~d]: ~s = ~s~%\" si::tp"
 "l-bds-command \"~&Backtrace:~%\" \"  > ~S\" \" [Evaluation of: ~S]\" \"Argument to comm"
 "and :backtrace must be an integer or t.\" \"  > ---end-of-stack---~%\" si::tpl-back"
 "trace \"Argument to command :frs must be an integer.\" si::tpl-frs-command \"    FR"
 "S[~d]: ---> IHS[~d],BDS[~d]~%\" si::print-frs \"~&Top level in: ~A.~%\" si::break-w"
 "here \"~&Broken at ~:@(~S~).\" \" In: ~A.~%\" \" File: ~S (Position #~D)~%\" si::tpl-p"
 "rint-current si::tpl-hide si::tpl-unhide si::tpl-unhide-package si::tpl-unhide-a"
 "ll si::tpl-hide-package si::ihs-visible si::name :zombi si::ihs-fname si::set-cu"
 "rrent-ihs si::set-break-env si::ihs-search \"Search for ~a failed.~%\" si::tpl-bac"
 "kward-search si::tpl-forward-search si::tpl-apropos-command si::tpl-document-com"
 "mand si::tpl-step-command si::tpl-trace-command si::tpl-untrace-command si::*tpl"
 "-last-load* si::tpl-load-command si::*tpl-last-compile* si::tpl-compile-command "
 "\"~%~A:~%\" \"~A.~%\" \"No such help topic: ~s~%\" \"Not a valid help topic: ~s~%\" si::"
 "tpl-help-command \"\nUse the following functions to directly access ECL stacks.\n\nI"
 "nvocation History Stack:\n(SYS:IHS-TOP)   Returns the index of the TOP of the IHS"
 ".\n(SYS:IHS-FUN i) Returns the function of the i-th entity in IHS.\n(SYS:IHS-ENV i"
 ")\n(SYS:IHS-PREV i)\n(SYS:IHS-NEXT i)\n\nFrame (catch, block) Stack:\n(SYS:FRS-TOP)  "
 " Returns the index of the TOP of the FRS.\n(SYS:FRS-BDS i) Returns the BDS index "
 "of the i-th entity in FRS.\n(SYS:FRS-IHS i) Returns the IHS index of the i-th ent"
 "ity in FRS.\n(SYS:FRS-TAG i)\n\nBinding Stack:\n(SYS:BDS-TOP)   Returns the index of"
 " the TOP of the BDS.\n(SYS:BDS-VAR i) Returns the symbol of the i-th entity in BD"
 "S.\n(SYS:BDS-VAL i) Returns the value of the i-th entity in BDS.\n\nNote that these"
 " functions are named by external symbols in the SYSTEM\npackage.\" si::tpl-help-st"
 "ack-command \"Restart commands\" \"~&Available restarts:~2%\" \"~&No restarts availab"
 "le.~%\" \"r~D\" \"~@[(~A)~]\" :keyword \":~A~16T~A~24T~A\" \":~A~48T~A~& ~&~A~A\" \"[Resta"
 "rt command]\" \"~D. ~A ~A~%\" si::compute-restart-commands si::update-debug-command"
 "s si::*default-debugger-maximum-depth* \"~&Excessive debugger depth! Probable inf"
 "inite recursion!~%~\n             Quitting process: ~A.~%\" si::check-default-debu"
 "gger-runaway \"Debugger switch command: Invalid argument value.\" si::tpl-switch-c"
 "ommand \"~&~%Debugger's waiting list:~2%\" \"   >~D: ~A~%\" \"    ~D: ~A~%\" si::tpl-w"
 "aiting-command \"~&Condition of type: ~A~%~A~%\" :display :commands si::default-de"
 "bugger invoke-debugger 0 0 0 0 0 0 0 0 0 0 0 si::make-restart 0 :correctablep si"
 "::dm-too-few-arguments 0 :commands :prompt-hook :broken-at :quiet 0 0 0 0 0 0 0 "
 "0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 si::help"
 " 0 si::step* 0 si::trace* 0 si::untrace* 0 0 0 0 0 0 0 si::exit-process 0 si::ma"
 "ke-seq-iterator si::seq-iterator-ref si::seq-iterator-next 0 0 0 \"SYSTEM\" (si::*"
 "break-readtable* si::*break-on-warnings* si::*tpl-evalhook* si::*tpl-prompt-hook"
 "*) (error cerror apply funcall invoke-debugger) ((\"Top level commands\" ((:cf :co"
 "mpile-file) si::tpl-compile-command :string \":cf              Compile file\" \":co"
 "mpile-file &string &rest files               [Top level command]~@\n        :cf &"
 "string &rest files                         [Abbreviation]~@\n        ~@\n        C"
 "ompile files.  With no arguments, uses values from latest :cf~@\n        command."
 "  File extensions are optional.~%\") ((:exit :eof) ext::quit :eval \":exit        "
 "    Exit Lisp\" \":exit &eval &optional (status 0)                [Top level comma"
 "nd]~@\n        ~@\n        Exit Lisp without further confirmation.~%\") ((:ld :load"
 ") si::tpl-load-command :string \":ld              Load file\" \":load &string &rest"
 " files                       [Top level command]~@\n        :ld &string &rest fil"
 "es                         [Abbreviation]~@\n        ~@\n        Load files.  With"
 " no arguments, uses values from latest :ld~@\n        or :cf command. File extens"
 "ions are optional.~%\") ((:step) si::tpl-step-command nil \":step            Singl"
 "e step form\" \":step form                                      [Top level command"
 "]~@\n        ~@\n        Evaluate form in single step mode.  While stepping, a new"
 " break~@\n        level is invoked before every evaluation.  Extra commands are~@"
 "\n        available at this time to control stepping and form evaluation.~%\") ((:"
 "tr :trace) si::tpl-trace-command nil \":tr(ace)         Trace function\" \":trace &"
 "rest functions                          [Top level command]~@\n        :tr &rest "
 "functions                             [Abbreviation]~@\n        ~@\n        Trace "
 "specified functions.  With no arguments, show currently~@\n        traced functio"
 "ns.~@\n        ~@\n        See also: :untrace.~%\") ((:untr :untrace) si::tpl-untra"
 "ce-command nil \":untr(ace)       Untrace function\" \":untrace &rest functions    "
 "                    [Top level command]~@\n        :untr &rest functions         "
 "                  [Abbreviation]~@\n        ~@\n        Untrace specified function"
 "s.  With no arguments, untrace~@\n        all functions.~@\n        ~@\n        See"
 " also: :trace.~%\") ((:s :switch) si::tpl-switch-command nil \":s(witch)        Sw"
 "itch to next process to debug\" \":switch process                                 "
 "[Break command]~@\n        :s processs                                     [Abbre"
 "viation]~@\n        ~@\n        Switch to next process in need to debugger attenti"
 "on. Argument~@\n        process, when provided, must be an integer indicating the"
 " rank~@\n        of the process in the debugger waiting list.~%\") ((:br :break) s"
 "i::tpl-interrupt-command nil \":br(eak)         Stop a given process\" \":break pro"
 "cess                                  [Break command]~@\n        :br processs    "
 "                                [Abbreviation]~@\n        ~@\n        Interrupt a "
 "given process. Argument process, must be provided and\n        it must be an inte"
 "ger indicating the rank~@\n        of the process in the debugger waiting list (:"
 "waiting).~%\") ((:w :waiting) si::tpl-waiting-command nil \":w(aiting)       Displ"
 "ay list of active toplevels\" \":waiting                                        [B"
 "reak command]~@\n        :w                                              [Abbrevi"
 "ation]~@\n        ~@\n        Display list of active toplevels, including open deb"
 "ug sessions.~%\")) (\"Help commands\" ((:apropos) si::tpl-apropos-command nil \":apr"
 "opos         Apropos\" \":apropos string &optional package               [Top leve"
 "l command]~@\n        ~@\n        Finds all available symbols whose print names co"
 "ntain string.~@\n        If a non NIL package is specified, only symbols in that "
 "package are considered.~@\n        ~%\") ((:doc si::document) si::tpl-document-com"
 "mand nil \":doc(ument)      Document\" \":document symbol                          "
 "      [Top level command]~@\n        ~@\n        Displays documentation about func"
 "tion, print names contain string.~%\") ((si::? :h :help) si::tpl-help-command nil"
 " \":h(elp) or ?     Help.  Type \\\":help help\\\" for more information\" \":help &opti"
 "onal topic                           [Top level command]~@\n        :h &optional "
 "topic                              [Abbreviation]~@\n        ~@\n        Print inf"
 "ormation on specified topic.  With no arguments, print~@\n        quick summary o"
 "f top level commands.~@\n        ~@\n        Help information for top level comman"
 "ds follows the documentation~@\n        style found in \\\"Common Lisp, the Languag"
 "e\\\"; and, in general, the~@\n        commands themselves follow the conventions o"
 "f Common Lisp functions,~@\n        with the exception that arguments are normall"
 "y not evaluated.~@\n        Those commands that do evaluate their arguments are i"
 "ndicated by the~@\n        keyword &eval in their description.  A third class of "
 "commands~@\n        treat their arguments as whitespace-separated, case-sensitive"
 "~@\n        strings, requiring double quotes only when necessary.  This style~@\n "
 "       of argument processing is indicated by the keyword &string.~@\n        For"
 " example, the :load command accepts a list of file names:\n        ~@\n        :lo"
 "ad &string &rest files                       [Top level Command]~@\n        ~@\n  "
 "      whereas :exit, which requires an optional evaluated argument, is~@\n       "
 " ~@\n        :exit &eval &optional status                    [Top level Command]~"
 "%\"))) (\"Break commands\" ((:q :quit) si::tpl-quit-command nil \":q(uit)          R"
 "eturn to some previous break level\" \":quit &optional n                          "
 "     [Break command]~@\n        :q &optional n                                  ["
 "Abbreviation]~@\n        ~@\n        Without argument, return to top level;~@\n    "
 "    otherwise return to break level n.~%\") ((:pop) (si::tpl-pop-command) :consta"
 "nt \":pop             Pop to previous break level\" \":pop                         "
 "                   [Break command]~@\n        ~@\n        Pop to previous break le"
 "vel, or if already in top level,~@\n        exit Lisp after confirmation.~%\") ((:"
 "c :continue) continue nil \":c(ontinue)      Continue execution\" \":continue      "
 "                                 [Break command]~@\n        :c                   "
 "                           [Abbreviation]~@\n        ~@\n        Continue executio"
 "n.  Return from current break level to the caller.~@\n        This command is onl"
 "y available when the break level is continuable~@\n        (e.g., called from a c"
 "orrectable error or the function break).~%\") ((:b :backtrace) si::tpl-backtrace "
 "nil \":b(acktrace)     Print backtrace\" \":backtrace &optional n                  "
 "        [Break command]~@\n        :b &optional n                                "
 "  [Abbreviation]~@\n        ~@\n        Show function call history.  Only those fu"
 "nctions called since~@\n        the previous break level are shown.  In addition,"
 " functions compiled~@\n        in-line or explicitly hidden are not displayed.  W"
 "ithout an argument,~@\n        a concise backtrace is printed with the current fu"
 "nction in upper~@\n        case.  With integer argument n, the n functions above "
 "and including~@\n        the current one are printed in a verbose format.~@\n     "
 "   ~@\n        See also: :function, :previous, :next.~%\") ((:f :function) si::tpl"
 "-print-current nil \":f(unction)      Show current function\" \":function          "
 "                             [Break command]~@\n        :f                       "
 "                       [Abbreviation]~@\n        ~@\n        Show current function"
 ".  The current function is the implicit focus~@\n        of attention for several"
 " other commands.  When it is an interpreted~@\n        function, its lexical envi"
 "ronment is available for inspection and~@\n        becomes the environment for ev"
 "aluating user input forms.~@\n        ~@\n        See also: :backtrace, :next, pre"
 "vious, :disassemble, :variables.~%\") ((:p :previous) si::tpl-previous nil \":p(re"
 "vious)      Go to previous function\" \":previous &optional (n 1)                 "
 "      [Break command]~@\n        :p &optional (n 1)                              "
 "[Abbreviation]~@\n        ~@\n        Move to the nth previous visible function in"
 " the backtrace.~@\n        It becomes the new current function.~@\n        ~@\n    "
 "    See also: :backtrace, :function, :go, :next.~%\") ((:d :down) si::tpl-previou"
 "s nil \":d(own)          Alias to :previous\" \"\") ((:n :next) si::tpl-next nil \":n"
 "(ext)          Go to next function\" \":next &optional (n 1)                      "
 "     [Break command]~@\n        :n &optional (n 1)                              ["
 "Abbreviation]~@\n        ~@\n        Move to the nth next visible function in the "
 "backtrace.  It becomes~@\n        the new current function.~@\n        ~@\n        "
 "See also: :backtrace, :function, :go, :previous.~%\") ((:u :up) si::tpl-next nil "
 "\":u(p)            Alias to :next\" \"\") ((:g :go) si::tpl-go nil \":g(o)           "
 " Go to next function\" \":go &optional (n 1)                             [Break co"
 "mmand]~@\n        :g &optional (n 1)                              [Abbreviation]~"
 "@\n        ~@\n        Move to the function at IHS[i].~@\n        See also: :backtr"
 "ace, :function, :next, :previous.~%\") ((:fs :forward-search) si::tpl-forward-sea"
 "rch :string \":fs              Search forward for function\" \":forward-search &str"
 "ing substring               [Break command]~@\n        :fs &string substring     "
 "                      [Abbreviation]~@\n        ~@\n        Search forward in the "
 "backtrace for function containing substring.~@\n        The match is case insensi"
 "tive.~@\n        ~@\n        See also: :backtrace, :function, :next.~%\") ((:bs :ba"
 "ckward-search) si::tpl-backward-search :string \":bs              Search backward"
 " for function\" \":backward-search &string substring              [Break command]~"
 "@\n        :bs &string substring                           [Abbreviation]~@\n     "
 "   ~@\n        Search backward in the backtrace for function containing substring"
 ".~@\n        The match is case insensitive.~@\n        ~@\n        See also: :backt"
 "race, :function, :previous.~%\") ((:disassemble) si::tpl-disassemble-command nil "
 "\":disassemble     Disassemble current function\" \":disassemble                   "
 "                 [Break command]~@\n        :disassemble                         "
 "           [Abbreviation]~@\n        ~@\n        Disassemble the current function."
 " Currently, only interpreted functions~@\n        can be disassembled.~%\") ((:le "
 ":lambda-expression) si::tpl-lambda-expression-command nil \":l(ambda-)e(expressio"
 "n) Show lisp code for current function\" \":lambda-expression                     "
 "         [Break command]~@\n        :le                                          "
 "   [Abbreviation]~@\n        ~@\n        Show the lisp code of the current functio"
 "n. Only works for interpreted~@\n        functions.~%\") ((:v :variables) si::tpl-"
 "variables-command nil \":v(ariables)     Show local variables, functions, blocks,"
 " and tags\" \":variables &optional no-values                  [Break command]~@\n  "
 "      :v &optional no-values                          [Abbreviation]~@\n        ~"
 "@\n        Show lexical variables, functions, block names, and tags local~@\n     "
 "   to the current function.  The current function must be interpreted.~@\n       "
 " The values of local variables and functions are also shown,~@\n        unless th"
 "e argument is non-null.~%\") ((:hide) si::tpl-hide nil \":hide            Hide fun"
 "ction\" \":hide function                                  [Break command]~@\n      "
 "  ~@\n        Hide function.  A hidden function is not displayed in a backtrace.~"
 "@\n        ~@\n        See also: :backtrace, :unhide, :hide-package.~%\") ((:unhide"
 ") si::tpl-unhide nil \":unhide          Unhide function\" \":unhide function       "
 "                         [Break command]~@\n        ~@\n        Unhide function.  "
 "The specified function will be displayed in future~@\n        backtraces, unless "
 "its home package is also hidden.~@\n        ~@\n        See also: :backtrace, :hid"
 "e, :unhide-package.~%\") ((:hp :hide-package) si::tpl-hide-package nil \":hp      "
 "        Hide package\" \":hide-package package                           [Break co"
 "mmand]~@\n        :hp package                                     [Abbreviation]~"
 "@\n        ~@\n        Hide package.  Functions in a hidden package are not displa"
 "yed~@\n        in a backtrace.~@\n        ~@\n        See also: :backtrace, :unhide"
 "-package.~%\") ((:unhp :unhide-package) si::tpl-unhide-package nil \":unhp        "
 "    Unhide package\" \":unhide-package package                         [Break comm"
 "and]~@\n        :unhp package                                   [Abbreviation]~@\n"
 "        ~@\n        Unhide package.  Functions in the specified package will be d"
 "isplayed~@\n        in future backtraces, unless they are individually hidden.~@\n"
 "        ~@\n        See also: :backtrace, :hide-package, :hide, :unhide.~%\") ((:u"
 "nhide-all) si::tpl-unhide-all nil \":unhide-all      Unhide all variables and pac"
 "kages\" \":unhide-all                                     [Break command]~@\n      "
 "  ~@\n        Unhide all variables and packages.  All functions will be displayed"
 "~@\n        in future backtraces.~@\n        ~@\n        See also: :hide, :unhide, "
 ":hide-package, :unhide-package.~%\") ((:bds :binding-stack) si::tpl-bds-command n"
 "il \":bds             Show binding stack\" \":binding-stack &optional variable     "
 "          [Break command]~@\n        :bds &optional variable                     "
 "    [Abbreviation]~@\n        ~@\n        Without an argument, show the entire bin"
 "ding stack since the previous~@\n        break level.  With a variable name, prin"
 "t nothing, but return the~@\n        value of the given variable on the binding s"
 "tack.~%\") ((:frs :frame-stack) si::tpl-frs-command nil \":frs             Show fr"
 "ame stack\" \"\") ((:m :message) si::tpl-print-message nil \":m(essage)       Show e"
 "rror message\" \":message                                        [Break command]~@"
 "\n        :m                                              [Abbreviation]~@\n      "
 "  ~@\n        Show current error message.~%\") ((:hs :help-stack) si::tpl-help-sta"
 "ck-command nil \":hs              Help stack\" \":help-stack                       "
 "              [Break command]~@\n        :hs                                     "
 "        [Abbreviation]~@\n        ~@\n        Lists the functions to access the LI"
 "SP system stacks.~%\") ((:i :inspect) si::tpl-inspect-command nil \":i(nspect)    "
 "   Inspect value of local variable\" \":inspect var-name                          "
 "     [Break command]~@\n        :i var-name                                     ["
 "Abbreviation]~@\n        ~@\n        Inspect value of local variable named by var-"
 "name. Argument~@\n        var-name can be a string or a symbol whose name string "
 "will~@\n        then be used regardless of of the symbol's package.~@\n        ~@\n"
 "        See also: :variables.~%\") ((:cb :c-backtrace) ext::dump-c-backtrace nil "
 "\":c(-)b(acktrace) Print a raw C backtrace\" \":c-backtrace n                      "
 "            [Break command]~@\n        :cb n                                     "
 "      [Abbreviation]~@\n        ~@\n        Show function call history of the n C "
 "functions above and~@\n        including the current one.~@\n        ~@\n        Se"
 "e also: :backtrace.~%\")) \"Console lock\"" };

static const cl_object compiler_data_text[] = {
(cl_object)compiler_data_text1,
NULL};
