static const struct ecl_base_string compiler_data_text1[] = {
        (int8_t)t_base_string, 0, ecl_aet_bc, 0,
        ECL_NIL, (cl_index)6805, (cl_index)6805,
        (ecl_base_char*)
"c::*current-toplevel-form* c::*cmp-env* c::*top-level-forms* c::t1expr c::*tople"
 "vel-forms-to-print* c::*current-form* c::*first-error* c::*setjmps* \"~s is illeg"
 "al function.\" c::*t1-dispatch-table* c::*c1-dispatch-table* c::*compile-time-too"
 "* c::t1expr* c::*compile-toplevel* c::t1/c1expr c::*t2-dispatch-table* c::*compi"
 "le-file-position* \"Unhandled T2FORM found at the toplevel:~%~4I~A\" c::t2expr c::"
 "*emitted-local-funs* c::*local-funs* c::*volatile* \"volatile \" \"#include \\\"\" \"\\\""
 "\" \"#ifdef ECL_DYNAMIC_VV\" \"static cl_object *VV;\" \"#else\" \"static cl_object VV[V"
 "M];\" \"#endif\" c::*compiler-output2* \"#ifdef __cplusplus\" \"extern \\\"C\\\" {\" c::*op"
 "ened-c-braces* c::*aux-closure* c::*compiler-output1* c::*compiler-declared-glob"
 "als* \"extern \\\"C\\\"\" \"ECL_DLLEXPORT void \" \"(cl_object flag)\" \"const cl_env_ptr c"
 "l_env_copy = ecl_process_env();\" \"cl_object value0;\" \"cl_object *VVtemp;\" \"if (f"
 "lag != OBJNULL){\" \"Cblock = flag;\" \"#ifndef ECL_DYNAMIC_VV\" \"flag->cblock.data ="
 " VV;\" c::*self-destructing-fasl* \"flag->cblock.self_destruct=1;\" \"flag->cblock.d"
 "ata_size = VM;\" \"flag->cblock.temp_data_size = VMtemp;\" \"flag->cblock.data_text "
 "= compiler_data_text;\" \"flag->cblock.cfuns_size = compiler_cfuns_size;\" \"flag->c"
 "block.cfuns = compiler_cfuns;\" \"flag->cblock.source = ecl_make_constant_base_str"
 "ing(\\\"\" \"\\\",-1);\" \"return;}\" \"VV = Cblock->cblock.data;\" \"Cblock->cblock.data_te"
 "xt = (const cl_object *)\\\"\" \"\\\";\" \"VVtemp = Cblock->cblock.temp_data;\" \"ECL_DEFI"
 "NE_SETF_FUNCTIONS\" c::*do-type-propagation* c::*compiler-phase* c::p1propagate c"
 "::t2 c::*make-forms* \"static cl_object Cblock;\" \"#undef ECL_DYNAMIC_VV\" \"#define"
 " compiler_data_text 0\" \"#define VM 0\" \"#define VMtemp 0\" \"#define VV NULL\" \"#def"
 "ine VM \" \"#define VMtemp \" \"#define ECL_DEFINE_SETF_FUNCTIONS \" c::*setf-definit"
 "ions* \"=ecl_setf_definition(\" \",ECL_T);\" \"}\" c::*static-constants* \"/*\" \" * Stat"
 "ically defined constants\" \" */\" c::t3 c::*callbacks* \"#include <ecl/internal.h>\""
 " c::ctop-write c::*ihs-used-p* c::*max-lex* c::*max-env* c::*max-temp* c::*lcl* "
 "c::*lex* c::*level* c::*env* c::*env-lvl* c::*temp* c::*compile-to-linking-call*"
 " 0 0 0 0 0 0 \"The EVAL-WHEN situation ~s is illegal.\" c::c1eval-when c::t2compil"
 "er-let c::t2progn c::lfun \"L~D~A\" c::exported-fname c::*global-funs* c::new-defu"
 "n \"~%<a FUN: ~A, CLOSURE: ~A, LEVEL: ~A, ENV: ~A>\" c::print-function c::l ((ppri"
 "nt (list* 'c::l? c::l)) (every #'identity c::l)) c::and! \"cl_object \" \"T\" \", \" \""
 ";\" \"struct ecl_ihs_frame ihs;\" \"const cl_object _ecl_debug_env = ECL_NIL;\" \"vola"
 "tile cl_object lex\" \"[\" \"];\" c::closure \"env0 = ECL_NIL;\" \"volatile struct ecl_c"
 "closure aux_closure;\" \"\" \"CLV\" c::wt-function-locals \"cl_fixnum \" \"unsigned char"
 " \" \"float \" \"double \" c::rep-type c::ordinary :args c::t1ordinary c::p1ordinary "
 "c::*exit* c::*unwind-exit* c::*destination* c::trash c::t2ordinary c::*load-time"
 "-values* c::add-load-time-values c::t1defmacro :always c::c1load-time-value c::t"
 "2load-time-value c::t2make-form c::t2init-form (ffi::object char ffi::int float "
 "ffi::double) \"The C variable name ~s is illegal.\" \"The C variable specification "
 "~s is illegal.\" c::parse-cvspecs ((:object . \"_ecl_object_loc\") (:fixnum . \"_ecl"
 "_fixnum_loc\") (:char . \"_ecl_base_char_loc\") (:float . \"_ecl_float_loc\") (:doubl"
 "e . \"_ecl_double_loc\") (:long-double . \"_ecl_long_double_loc\") (:csfloat . \"_ecl"
 "_csfloat_loc\") (:cdfloat . \"_ecl_cdfloat_loc\") (:clfloat . \"_ecl_clfloat_loc\") ("
 "(special c::global c::closure c::lexical))) c::locative-type-from-var-kind \"KEYW"
 "ORD\" \"\\\"~S\\\"\" c::lcl \"static const struct ecl_var_debug_info _ecl_descriptors[]="
 "{\" \"{\" \",{\" \",\" \"};\" \"const cl_index _ecl_debug_info_raw[]={\" \"(cl_index)(ECL_NI"
 "L),\" \"(cl_index)(_ecl_debug_env),\" \"(cl_index)(_ecl_descriptors)\" \",(cl_index)(&"
 "\" \")\" \"ecl_def_ct_vector(_ecl_debug_env,ecl_aet_index,_ecl_debug_info_raw,\" \",,)"
 ";\" \"ihs.lex_env = _ecl_debug_env;\" c::build-debug-lexical-env c::pop-debug-lexic"
 "al-env c::*last-label* (return) c::*tail-recursion-info* \"env0 = cl_env_copy->fu"
 "nction->cclosure.env;\" \"value0;\" \"ecl_cs_check(cl_env_copy,value0);\" c::t3local-"
 "fun c::t3local-fun-body \"function definition for ~a\" \"closure ~a\" \"local functio"
 "n ~a\" \"... shares definition with ~a\" \"optimize speed ~D, debug ~D, space ~D, sa"
 "fety ~D \" \"ECL_DLLEXPORT cl_object \" \"(\" \"static cl_object \" \"cl_narg\" \"cl_narg "
 "narg\" \"volatile cl_object  *\" \"volatile cl_object *lex\" c::fun \", ...\" \");\" c::t"
 "3local-fun-declaration c::fun-closure-variables c::lexical c::fun-lexical-levels"
 " \"/* Scanning closure data ... */\" \" = env0;\" \" = _ecl_cdr(CLV\" \" /* ... closure"
 " scanning finished */\" c::t3local-fun-closure-scan c::t1fset c::*use-c-global* c"
 "::locals c::var \"Declaration C-LOCAL used in macro ~a\" 0 0 :permanent :duplicate"
 " :used-p c::c1fset c::p1fset c::t2fset \"(void)0; /* No entry created for \" \"~A\" "
 "c::*inline-blocks* c::*global-cfuns-array* \"ecl_cmp_defmacro(\" \"ecl_cmp_defun(\" "
 "c::c2fset \" * Exported Lisp functions\" \"#define compiler_cfuns_size \" \"#define c"
 "ompiler_cfuns NULL\" \"~%static const struct ecl_cfunfixed compiler_cfuns[] = {~\n~"
 "%~t/*t,m,narg,padding,name=function-location,block=name-location,entry,entry_fix"
 "ed,file,file_position*/\" \"~%{0,0,~D,0,ecl_make_fixnum(~D),ecl_make_fixnum(~D),(c"
 "l_objectfn)~A,NULL,ECL_NIL,ecl_make_fixnum(~D)},\" \"~%};\" c::output-cfuns 0 c::cm"
 "p-env-copy c::cmp-env-root 0 c::chk-symbol-macrolet c::print-current-form c::cmp"
 "err c::inline-possible c::cmp-expand-macro c::cmp-eval c::cmp-macro-function 0 c"
 "::c1expr 0 c::c1form-name c::c1form-file c::c1form-file-position c::c1form-form "
 "c::c1form-env c::c1form-args 0 c::brief-namestring c::wt-nl c::wt-nl-h c::output"
 "-clines c::wt-nl-open-brace c::init-name-tag c::fun-lambda c::wt-nl-close-many-b"
 "races c::data-size c::data-permanent-storage-size c::data-temporary-storage-size"
 " c::wt-h c::t3-defcallback c::wt-nl-close-brace 0 c::check-args-number c::c1prog"
 "n 0 c::c2expr 0 0 c::next-cfun 0 0 c::fun-name c::fun-closure c::fun-level c::fu"
 "n-env 0 0 c::wt 0 0 c::make-c1form* 0 0 c::next-label c::wt-label 0 0 si::dm-too"
 "-few-arguments c::cmp-env-register-global-macro 0 c::c1constant-value c::data-em"
 "pty-loc c::add-object 0 0 0 0 0 0 c::var-name c::var-kind c::var-loc 0 0 c::prin"
 "t-emitting c::c1form-volatile* c::policy-check-stack-overflow 0 c::fun-cfun c::f"
 "un-description c::fun-needs-narg c::fun-required-lcls c::fun-optional-type-check"
 "-forms c::fun-keyword-type-check-forms c::c2lambda-expr 0 c::fun-global c::wt-co"
 "mment-nl c::fun-shares-with c::next-lcl c::cmp-env-optimization c::fun-exported "
 "0 c::fun-referenced-vars c::ref-ref-ccb c::var-referenced-in-form c::var-changed"
 "-in-form 0 0 c::wt-comment 0 0 si::dm-too-many-arguments c::global-var-p c::fun-"
 "var c::fun-no-entry 0 0 0 c::new-local c::c2call-global c::loc-immediate-value c"
 "::close-inline-blocks 0 c::fun-minarg c::fun-maxarg c::vv-location c::fun-file-p"
 "osition \"COMPILER\" (defun defmacro defvar defparameter defclass defmethod defgen"
 "eric)" };

static const cl_object compiler_data_text[] = {
(cl_object)compiler_data_text1,
NULL};
