static const struct ecl_base_string compiler_data_text1[] = {
        (int8_t)t_base_string, 0, ecl_aet_bc, 0,
        ECL_NIL, (cl_index)36043, (cl_index)36043,
        (ecl_base_char*)
"c::*machine* c::*inline-information* ((aref :unsafe (t t t) t \"@0;ecl_aref_unsaf"
 "e(#0,ecl_fixnum(#1)*(#0)->array.dims[1]+ecl_fixnum(#2))\") (aref :unsafe ((array "
 "t) t t) t \"@0;(#0)->array.self.t[ecl_fixnum(#1)*(#0)->array.dims[1]+ecl_fixnum(#"
 "2)]\") (aref :unsafe ((array bit) t t) :fixnum \"@0;ecl_aref_bv(#0,ecl_fixnum(#1)*"
 "(#0)->array.dims[1]+ecl_fixnum(#2))\") (aref :unsafe ((array t) fixnum fixnum) t "
 "\"@0;(#0)->array.self.t[#1*(#0)->array.dims[1]+#2]\") (aref :unsafe ((array bit) f"
 "ixnum fixnum) :fixnum \"@0;ecl_aref_bv(#0,(#1)*(#0)->array.dims[1]+#2)\") (aref :u"
 "nsafe ((array base-char) fixnum fixnum) :unsigned-char \"@0;(#0)->base_string.sel"
 "f[#1*(#0)->array.dims[1]+#2]\") (aref :unsafe ((array double-float) fixnum fixnum"
 ") :double \"@0;(#0)->array.self.df[#1*(#0)->array.dims[1]+#2]\") (aref :unsafe ((a"
 "rray single-float) fixnum fixnum) :float \"@0;(#0)->array.self.sf[#1*(#0)->array."
 "dims[1]+#2]\") (aref :unsafe ((array long-float) fixnum fixnum) :long-double \"@0;"
 "(#0)->array.self.lf[#1*(#0)->array.dims[1]+#2]\") (aref :unsafe ((array si::compl"
 "ex-single-float) fixnum fixnum) :csfloat \"@0;(#0)->array.self.csf[#1*(#0)->array"
 ".dims[1]+#2]\") (aref :unsafe ((array si::complex-double-float) fixnum fixnum) :c"
 "dfloat \"@0;(#0)->array.self.cdf[#1*(#0)->array.dims[1]+#2]\") (aref :unsafe ((arr"
 "ay si::complex-long-float) fixnum fixnum) :clfloat \"@0;(#0)->array.self.clf[#1*("
 "#0)->array.dims[1]+#2]\") (aref :unsafe ((array fixnum) fixnum fixnum) :fixnum \"@"
 "0;(#0)->array.self.fix[#1*(#0)->array.dims[1]+#2]\") (aref :always (t t) t \"ecl_a"
 "ref1(#0,ecl_to_size(#1))\") (aref :always (t fixnum) t \"ecl_aref1(#0,#1)\") (aref "
 ":unsafe (t t) t \"ecl_aref1(#0,ecl_fixnum(#1))\") (aref :unsafe ((array bit) t) :f"
 "ixnum \"ecl_aref_bv(#0,ecl_fixnum(#1))\") (aref :unsafe ((array bit) fixnum) :fixn"
 "um \"ecl_aref_bv(#0,#1)\") (aref :unsafe ((array character) fixnum) :wchar \"(#0)->"
 "string.self[#1]\") (aref :unsafe ((array base-char) fixnum) :unsigned-char \"(#0)-"
 ">base_string.self[#1]\") (aref :unsafe ((array double-float) fixnum) :double \"(#0"
 ")->array.self.df[#1]\") (aref :unsafe ((array single-float) fixnum) :float \"(#0)-"
 ">array.self.sf[#1]\") (aref :unsafe ((array long-float) fixnum) :long-double \"(#0"
 ")->array.self.lf[#1]\") (aref :unsafe ((array si::complex-single-float) fixnum) :"
 "csfloat \"(#0)->array.self.csf[#1]\") (aref :unsafe ((array si::complex-double-flo"
 "at) fixnum) :cdfloat \"(#0)->array.self.cdf[#1]\") (aref :unsafe ((array si::compl"
 "ex-long-float) fixnum) :clfloat \"(#0)->array.self.clf[#1]\") (aref :unsafe ((arra"
 "y fixnum) fixnum) :fixnum \"(#0)->array.self.fix[#1]\") (row-major-aref :always (t"
 " t) t \"ecl_aref(#0,ecl_to_size(#1))\") (row-major-aref :always (t fixnum) t \"ecl_"
 "aref(#0,#1)\") (row-major-aref :unsafe (t t) t \"ecl_aref_unsafe(#0,ecl_fixnum(#1)"
 ")\") (row-major-aref :unsafe (t fixnum) t \"ecl_aref_unsafe(#0,#1)\") (row-major-ar"
 "ef :unsafe ((array bit) t) :fixnum \"ecl_aref_bv(#0,ecl_fixnum(#1))\") (row-major-"
 "aref :unsafe ((array bit) fixnum) :fixnum \"ecl_aref_bv(#0,#1)\") (row-major-aref "
 ":unsafe ((array character) fixnum) :wchar \"(#0)->string.self[#1]\") (row-major-ar"
 "ef :unsafe ((array base-char) fixnum) :unsigned-char \"(#0)->base_string.self[#1]"
 "\") (row-major-aref :unsafe ((array ext::byte8) fixnum) :uint8-t \"(#0)->vector.se"
 "lf.b8[#1]\") (row-major-aref :unsafe ((array ext::integer8) fixnum) :int8-t \"(#0)"
 "->vector.self.i8[#1]\") (row-major-aref :unsafe ((array ext::byte16) fixnum) :uin"
 "t16-t \"(#0)->vector.self.b16[#1]\") (row-major-aref :unsafe ((array ext::integer1"
 "6) fixnum) :int16-t \"(#0)->vector.self.i16[#1]\") (row-major-aref :unsafe ((array"
 " ext::byte32) fixnum) :uint32-t \"(#0)->vector.self.b32[#1]\") (row-major-aref :un"
 "safe ((array ext::integer32) fixnum) :int32-t \"(#0)->vector.self.i32[#1]\") (row-"
 "major-aref :unsafe ((array ext::byte64) fixnum) :uint64-t \"(#0)->vector.self.b64"
 "[#1]\") (row-major-aref :unsafe ((array ext::integer64) fixnum) :int64-t \"(#0)->v"
 "ector.self.i64[#1]\") (row-major-aref :unsafe ((array long-float) fixnum) :long-d"
 "ouble \"(#0)->array.self.lf[#1]\") (row-major-aref :unsafe ((array double-float) f"
 "ixnum) :double \"(#0)->array.self.df[#1]\") (row-major-aref :unsafe ((array single"
 "-float) fixnum) :float \"(#0)->array.self.sf[#1]\") (row-major-aref :unsafe ((arra"
 "y si::complex-single-float) fixnum) :csfloat \"(#0)->array.self.csf[#1]\") (row-ma"
 "jor-aref :unsafe ((array si::complex-double-float) fixnum) :cdfloat \"(#0)->array"
 ".self.cdf[#1]\") (row-major-aref :unsafe ((array si::complex-long-float) fixnum) "
 ":clfloat \"(#0)->array.self.clf[#1]\") (row-major-aref :unsafe ((array fixnum) fix"
 "num) :fixnum \"(#0)->array.self.fix[#1]\") (si::row-major-aset :always (t t t) t \""
 "ecl_aset(#0,ecl_to_size(#1),#2)\") (si::row-major-aset :always (t fixnum t) t \"ec"
 "l_aset(#0,#1,#2)\") (si::row-major-aset :unsafe (t t t) t \"ecl_aset_unsafe(#0,ecl"
 "_fixnum(#1),#2)\") (si::row-major-aset :unsafe (t fixnum t) t \"ecl_aset_unsafe(#0"
 ",#1,#2)\") (si::row-major-aset :unsafe ((array t) fixnum t) t \"(#0)->vector.self."
 "t[#1]= #2\") (si::row-major-aset :unsafe ((array bit) fixnum t) :fixnum \"ecl_aset"
 "_bv(#0,#1,ecl_fixnum(#2))\") (si::row-major-aset :unsafe ((array bit) fixnum fixn"
 "um) :fixnum \"ecl_aset_bv(#0,#1,#2)\") (si::row-major-aset :unsafe ((array base-ch"
 "ar) fixnum base-char) :unsigned-char \"(#0)->base_string.self[#1]= #2\") (si::row-"
 "major-aset :unsafe ((array character) fixnum character) :wchar \"(#0)->string.sel"
 "f[#1]= #2\") (si::row-major-aset :unsafe ((array ext::byte8) fixnum ext::byte8) :"
 "uint8-t \"(#0)->vector.self.b8[#1]= #2\") (si::row-major-aset :unsafe ((array ext:"
 ":integer8) fixnum ext::integer8) :int8-t \"(#0)->vector.self.i8[#1]= #2\") (si::ro"
 "w-major-aset :unsafe ((array ext::byte16) fixnum ext::byte16) :uint16-t \"(#0)->v"
 "ector.self.b16[#1]= #2\") (si::row-major-aset :unsafe ((array ext::integer16) fix"
 "num ext::integer16) :int16-t \"(#0)->vector.self.i16[#1]= #2\") (si::row-major-ase"
 "t :unsafe ((array ext::byte32) fixnum ext::byte32) :uint32-t \"(#0)->vector.self."
 "b32[#1]= #2\") (si::row-major-aset :unsafe ((array ext::integer32) fixnum ext::in"
 "teger32) :int32-t \"(#0)->vector.self.i32[#1]= #2\") (si::row-major-aset :unsafe ("
 "(array ext::byte64) fixnum ext::byte64) :uint64-t \"(#0)->vector.self.b64[#1]= #2"
 "\") (si::row-major-aset :unsafe ((array ext::integer64) fixnum ext::integer64) :i"
 "nt64-t \"(#0)->vector.self.i64[#1]= #2\") (si::row-major-aset :unsafe ((array long"
 "-float) fixnum long-float) :long-double \"(#0)->array.self.lf[#1]= #2\") (si::row-"
 "major-aset :unsafe ((array double-float) fixnum double-float) :double \"(#0)->arr"
 "ay.self.df[#1]= #2\") (si::row-major-aset :unsafe ((array single-float) fixnum si"
 "ngle-float) :float \"(#0)->array.self.sf[#1]= #2\") (si::row-major-aset :unsafe (("
 "array si::complex-single-float) fixnum si::complex-single-float) :csfloat \"(#0)-"
 ">array.self.csf[#1]= #2\") (si::row-major-aset :unsafe ((array si::complex-double"
 "-float) fixnum si::complex-double-float) :cdfloat \"(#0)->array.self.cdf[#1]= #2\""
 ") (si::row-major-aset :unsafe ((array si::complex-long-float) fixnum si::complex"
 "-long-float) :clfloat \"(#0)->array.self.clf[#1]= #2\") (si::row-major-aset :unsaf"
 "e ((array fixnum) fixnum fixnum) :fixnum \"(#0)->array.self.fix[#1]= #2\") (si::co"
 "py-subarray :always (array ext::array-index array ext::array-index ext::array-in"
 "dex) array \"@0;(ecl_copy_subarray(#0,#1,#2,#3,#4),#0)\") (array-rank :unsafe (arr"
 "ay) :fixnum \"@0;(((#0)->d.t == t_array)?(#0)->array.rank:1)\") (array-rank :alway"
 "s (array) :fixnum \"ecl_array_rank(#0)\") (array-dimension :always (t t) fixnum \"e"
 "cl_array_dimension(#0,ecl_to_size(#1))\") (array-dimension :always (t fixnum) fix"
 "num \"ecl_array_dimension(#0,#1)\") (array-total-size :unsafe (t) :fixnum \"((#0)->"
 "array.dim)\") (adjustable-array-p :always (t) :bool \"@0;(ECL_ARRAYP(#0)? (void)0:"
 " FEtype_error_array(#0),ECL_ADJUSTABLE_ARRAY_P(#0))\") (adjustable-array-p :unsaf"
 "e (array) :bool \"ECL_ADJUSTABLE_ARRAY_P(#0)\") (svref :always (t t) t \"ecl_aref1("
 "#0,ecl_to_size(#1))\") (svref :always (t fixnum) t \"ecl_aref1(#0,#1)\") (svref :un"
 "safe (t t) t \"(#0)->vector.self.t[ecl_fixnum(#1)]\") (svref :unsafe (t fixnum) t "
 "\"(#0)->vector.self.t[#1]\") (si::svset :always (t t t) t \"ecl_aset1(#0,ecl_to_siz"
 "e(#1),#2)\") (si::svset :always (t fixnum t) t \"ecl_aset1(#0,#1,#2)\") (si::svset "
 ":unsafe (t t t) t \"((#0)->vector.self.t[ecl_fixnum(#1)]=(#2))\") (si::svset :unsa"
 "fe (t fixnum t) t \"(#0)->vector.self.t[#1]= #2\") (array-has-fill-pointer-p :alwa"
 "ys (t) :bool \"@0;(ECL_ARRAYP(#0)?(void)0:FEtype_error_array(#0),ECL_ARRAY_HAS_FI"
 "LL_POINTER_P(#0))\") (array-has-fill-pointer-p :unsafe (array) :bool \"ECL_ARRAY_H"
 "AS_FILL_POINTER_P(#0)\") (fill-pointer :unsafe (t) :fixnum \"((#0)->vector.fillp)\""
 ") (si::fill-pointer-set :unsafe (t fixnum) :fixnum \"((#0)->vector.fillp)=(#1)\") "
 "(standard-char-p :always (character) :bool \"ecl_standard_char_p(#0)\") (graphic-c"
 "har-p :always (character) :bool \"ecl_graphic_char_p(#0)\") (alpha-char-p :always "
 "(character) :bool \"ecl_alpha_char_p(#0)\") (upper-case-p :always (character) :boo"
 "l \"ecl_upper_case_p(#0)\") (lower-case-p :always (character) :bool \"ecl_lower_cas"
 "e_p(#0)\") (both-case-p :always (character) :bool \"ecl_both_case_p(#0)\") (alphanu"
 "mericp :always (character) :bool \"ecl_alphanumericp(#0)\") (char= :always (t t) :"
 "bool \"ecl_char_code(#0)==ecl_char_code(#1)\") (char= :always (character character"
 ") :bool \"(#0)==(#1)\") (char/= :always (t t) :bool \"ecl_char_code(#0)!=ecl_char_c"
 "ode(#1)\") (char/= :always (character character) :bool \"(#0)!=(#1)\") (char< :alwa"
 "ys (character character) :bool \"(#0)<(#1)\") (char> :always (character character)"
 " :bool \"(#0)>(#1)\") (char<= :always (character character) :bool \"(#0)<=(#1)\") (c"
 "har>= :always (character character) :bool \"(#0)>=(#1)\") (char-code :always (char"
 "acter) :fixnum \"#0\") (code-char :always (fixnum) :wchar \"#0\") (char-upcase :alwa"
 "ys (base-char) :unsigned-char \"ecl_char_upcase(#0)\") (char-upcase :always (chara"
 "cter) :wchar \"ecl_char_upcase(#0)\") (char-downcase :always (base-char) :unsigned"
 "-char \"ecl_char_downcase(#0)\") (char-downcase :always (character) :wchar \"ecl_ch"
 "ar_downcase(#0)\") (char-int :always (character) :fixnum \"#0\") (si::foreign-data-"
 "p :always (t) :bool \"@0;ECL_FOREIGN_DATA_P(#0)\") (input-stream-p :always (stream"
 ") :bool \"ecl_input_stream_p(#0)\") (output-stream-p :always (stream) :bool \"ecl_o"
 "utput_stream_p(#0)\") (gethash :always (t t t) t \"ecl_gethash_safe(#0,#1,#2)\" :mu"
 "ltiple-values nil) (gethash :always (t t) t \"ecl_gethash_safe(#0,#1,ECL_NIL)\" :m"
 "ultiple-values nil) (hash-table-count :unsafe (hash-table) ext::array-index \"ecl"
 "_hash_table_count(#0)\") (car :unsafe (cons) t \"ECL_CONS_CAR(#0)\") (car :unsafe ("
 "t) t \"_ecl_car(#0)\") (si::cons-car :always (t) t \"_ecl_car(#0)\") (si::cons-car :"
 "unsafe (t) t \"ECL_CONS_CAR(#0)\") (cdr :unsafe (cons) t \"ECL_CONS_CDR(#0)\") (cdr "
 ":unsafe (t) t \"_ecl_cdr(#0)\") (si::cons-cdr :always (t) t \"_ecl_cdr(#0)\") (si::c"
 "ons-cdr :unsafe (t) t \"ECL_CONS_CDR(#0)\") (car :always (t) t \"ecl_car(#0)\") (car"
 " :unsafe (t) t \"_ecl_car(#0)\") (cdr :always (t) t \"ecl_cdr(#0)\") (cdr :unsafe (t"
 ") t \"_ecl_cdr(#0)\") (caar :always (t) t \"ecl_caar(#0)\") (caar :unsafe (t) t \"_ec"
 "l_caar(#0)\") (cdar :always (t) t \"ecl_cdar(#0)\") (cdar :unsafe (t) t \"_ecl_cdar("
 "#0)\") (cadr :always (t) t \"ecl_cadr(#0)\") (cadr :unsafe (t) t \"_ecl_cadr(#0)\") ("
 "cddr :always (t) t \"ecl_cddr(#0)\") (cddr :unsafe (t) t \"_ecl_cddr(#0)\") (caaar :"
 "always (t) t \"ecl_caaar(#0)\") (caaar :unsafe (t) t \"_ecl_caaar(#0)\") (cdaar :alw"
 "ays (t) t \"ecl_cdaar(#0)\") (cdaar :unsafe (t) t \"_ecl_cdaar(#0)\") (cadar :always"
 " (t) t \"ecl_cadar(#0)\") (cadar :unsafe (t) t \"_ecl_cadar(#0)\") (cddar :always (t"
 ") t \"ecl_cddar(#0)\") (cddar :unsafe (t) t \"_ecl_cddar(#0)\") (caadr :always (t) t"
 " \"ecl_caadr(#0)\") (caadr :unsafe (t) t \"_ecl_caadr(#0)\") (cdadr :always (t) t \"e"
 "cl_cdadr(#0)\") (cdadr :unsafe (t) t \"_ecl_cdadr(#0)\") (caddr :always (t) t \"ecl_"
 "caddr(#0)\") (caddr :unsafe (t) t \"_ecl_caddr(#0)\") (cdddr :always (t) t \"ecl_cdd"
 "dr(#0)\") (cdddr :unsafe (t) t \"_ecl_cdddr(#0)\") (caaaar :always (t) t \"ecl_caaaa"
 "r(#0)\") (caaaar :unsafe (t) t \"_ecl_caaaar(#0)\") (cdaaar :always (t) t \"ecl_cdaa"
 "ar(#0)\") (cdaaar :unsafe (t) t \"_ecl_cdaaar(#0)\") (cadaar :always (t) t \"ecl_cad"
 "aar(#0)\") (cadaar :unsafe (t) t \"_ecl_cadaar(#0)\") (cddaar :always (t) t \"ecl_cd"
 "daar(#0)\") (cddaar :unsafe (t) t \"_ecl_cddaar(#0)\") (caadar :always (t) t \"ecl_c"
 "aadar(#0)\") (caadar :unsafe (t) t \"_ecl_caadar(#0)\") (cdadar :always (t) t \"ecl_"
 "cdadar(#0)\") (cdadar :unsafe (t) t \"_ecl_cdadar(#0)\") (caddar :always (t) t \"ecl"
 "_caddar(#0)\") (caddar :unsafe (t) t \"_ecl_caddar(#0)\") (cdddar :always (t) t \"ec"
 "l_cdddar(#0)\") (cdddar :unsafe (t) t \"_ecl_cdddar(#0)\") (caaadr :always (t) t \"e"
 "cl_caaadr(#0)\") (caaadr :unsafe (t) t \"_ecl_caaadr(#0)\") (cdaadr :always (t) t \""
 "ecl_cdaadr(#0)\") (cdaadr :unsafe (t) t \"_ecl_cdaadr(#0)\") (cadadr :always (t) t "
 "\"ecl_cadadr(#0)\") (cadadr :unsafe (t) t \"_ecl_cadadr(#0)\") (cddadr :always (t) t"
 " \"ecl_cddadr(#0)\") (cddadr :unsafe (t) t \"_ecl_cddadr(#0)\") (caaddr :always (t) "
 "t \"ecl_caaddr(#0)\") (caaddr :unsafe (t) t \"_ecl_caaddr(#0)\") (cdaddr :always (t)"
 " t \"ecl_cdaddr(#0)\") (cdaddr :unsafe (t) t \"_ecl_cdaddr(#0)\") (cadddr :always (t"
 ") t \"ecl_cadddr(#0)\") (cadddr :unsafe (t) t \"_ecl_cadddr(#0)\") (cddddr :always ("
 "t) t \"ecl_cddddr(#0)\") (cddddr :unsafe (t) t \"_ecl_cddddr(#0)\") (cons :always (t"
 " t) t \"CONS(#0,#1)\") (endp :safe (t) :bool \"ecl_endp(#0)\") (endp :unsafe (t) :bo"
 "ol \"#0==ECL_NIL\") (nth :always (t t) t \"ecl_nth(ecl_to_size(#0),#1)\") (nth :alwa"
 "ys (fixnum t) t \"ecl_nth(#0,#1)\") (nth :unsafe (t t) t \"ecl_nth(ecl_fixnum(#0),#"
 "1)\") (nth :unsafe (fixnum t) t \"ecl_nth(#0,#1)\") (nthcdr :always (t t) t \"ecl_nt"
 "hcdr(ecl_to_size(#0),#1)\") (nthcdr :always (fixnum t) t \"ecl_nthcdr(#0,#1)\") (nt"
 "hcdr :unsafe (t t) t \"ecl_nthcdr(ecl_fixnum(#0),#1)\") (nthcdr :unsafe (fixnum t)"
 " t \"ecl_nthcdr(#0,#1)\") (last :always (t) t \"ecl_last(#0,1)\") (list :always nil "
 "t \"ECL_NIL\") (list :always (t) t \"ecl_list1(#0)\") (list* :always (t) t \"#0\") (li"
 "st* :always (t t) t \"CONS(#0,#1)\") (append :always (t t) t \"ecl_append(#0,#1)\") "
 "(nconc :always (t t) t \"ecl_nconc(#0,#1)\") (butlast :always (t) t \"ecl_butlast(#"
 "0,1)\") (nbutlast :always (t) t \"ecl_nbutlast(#0,1)\") (1+ :always (t) t \"ecl_one_"
 "plus(#0)\") (1+ :always (fixnum) t \"ecl_make_integer((#0)+1)\") (1+ :always (long-"
 "float) :long-double \"(long double)(#0)+1\") (1+ :always (double-float) :double \"("
 "double)(#0)+1\") (1+ :always (single-float) :float \"(float)(#0)+1\") (1+ :always ("
 "si::complex-single-float) :csfloat \"(_Complex float)(#0)+1\") (1+ :always (si::co"
 "mplex-double-float) :cdfloat \"(_Complex double)(#0)+1\") (1+ :always (si::complex"
 "-long-float) :clfloat \"(_Complex long double)(#0)+1\") (1+ :always (fixnum) :fixn"
 "um \"(#0)+1\" :exact-return-type t) (1- :always (t) t \"ecl_one_minus(#0)\") (1- :al"
 "ways (fixnum) t \"ecl_make_integer((#0)-1)\") (1- :always (long-float) :long-doubl"
 "e \"(long double)(#0)-1\") (1- :always (double-float) :double \"(double)(#0)-1\") (1"
 "- :always (single-float) :float \"(float)(#0)-1\") (1- :always (si::complex-single"
 "-float) :csfloat \"(_Complex float)(#0)-1\") (1- :always (si::complex-double-float"
 ") :cdfloat \"(_Complex double)(#0)-1\") (1- :always (si::complex-long-float) :clfl"
 "oat \"(_Complex long double)(#0)-1\") (1- :always (fixnum) :fixnum \"(#0)-1\" :exact"
 "-return-type t) (float :always (t single-float) :float \"ecl_to_float(#0)\") (floa"
 "t :always (t double-float) :double \"ecl_to_double(#0)\") (float :always (t long-f"
 "loat) :long-double \"ecl_to_long_double(#0)\") (float :always (c::fixnum-float) :l"
 "ong-double \"((long double)(#0))\" :exact-return-type t) (float :always (c::fixnum"
 "-float) :double \"((double)(#0))\" :exact-return-type t) (float :always (c::fixnum"
 "-float) :float \"((float)(#0))\" :exact-return-type t) (numerator :unsafe (integer"
 ") integer \"(#0)\") (numerator :unsafe (ratio) integer \"(#0)->ratio.num\") (denomin"
 "ator :unsafe (integer) integer \"ecl_make_fixnum(1)\") (denominator :unsafe (ratio"
 ") integer \"(#0)->ratio.den\") (floor :always (t) (values &rest t) \"ecl_floor1(#0)"
 "\") (floor :always (t t) (values &rest t) \"ecl_floor2(#0,#1)\") (ceiling :always ("
 "t) (values &rest t) \"ecl_ceiling1(#0)\") (ceiling :always (t t) (values &rest t) "
 "\"ecl_ceiling2(#0,#1)\") (truncate :always (t) (values &rest t) \"ecl_truncate1(#0)"
 "\") (truncate :always (t t) (values &rest t) \"ecl_truncate2(#0,#1)\") (round :alwa"
 "ys (t) (values &rest t) \"ecl_round1(#0)\") (round :always (t t) (values &rest t) "
 "\"ecl_round2(#0,#1)\") (mod :always (t t) t \"(ecl_floor2(#0,#1),cl_env_copy->value"
 "s[1])\") (mod :always (fixnum fixnum) :fixnum \"@01;(#0>=0&&#1>0?(#0)%(#1):ecl_imo"
 "d(#0,#1))\") (rem :always (t t) t \"(ecl_truncate2(#0,#1),cl_env_copy->values[1])\""
 ") (rem :always (fixnum fixnum) :fixnum \"(#0)%(#1)\") (= :always (t t) :bool \"ecl_"
 "number_equalp(#0,#1)\") (= :always (c::fixnum-float c::fixnum-float) :bool \"(#0)="
 "=(#1)\") (/= :always (t t) :bool \"!ecl_number_equalp(#0,#1)\") (/= :always (c::fix"
 "num-float c::fixnum-float) :bool \"(#0)!=(#1)\") (< :always (t t) :bool \"ecl_lower"
 "(#0,#1)\") (< :always (c::fixnum-float c::fixnum-float) :bool \"(#0)<(#1)\") (< :al"
 "ways (c::fixnum-float c::fixnum-float c::fixnum-float) :bool \"@012;((#0)<(#1) &&"
 " (#1)<(#2))\") (> :always (t t) :bool \"ecl_greater(#0,#1)\") (> :always (c::fixnum"
 "-float c::fixnum-float) :bool \"(#0)>(#1)\") (> :always (c::fixnum-float c::fixnum"
 "-float c::fixnum-float) :bool \"@012;((#0)>(#1) && (#1)>(#2))\") (<= :always (t t)"
 " :bool \"ecl_lowereq(#0,#1)\") (<= :always (c::fixnum-float c::fixnum-float) :bool"
 " \"(#0)<=(#1)\") (<= :always (c::fixnum-float c::fixnum-float c::fixnum-float) :bo"
 "ol \"@012;((#0)<=(#1) && (#1)<=(#2))\") (>= :always (t t) :bool \"ecl_greatereq(#0,"
 "#1)\") (>= :always (c::fixnum-float c::fixnum-float) :bool \"(#0)>=(#1)\") (>= :alw"
 "ays (c::fixnum-float c::fixnum-float c::fixnum-float) :bool \"@012;((#0)>=(#1) &&"
 " (#1)>=(#2))\") (max :always (t t) t \"@01;((ecl_float_nan_p(#1) || ecl_greatereq("
 "#0,#1))?#0:#1)\") (max :always (fixnum fixnum) :fixnum \"@01;(#0)>=(#1)?#0:#1\") (m"
 "in :always (t t) t \"@01;((ecl_float_nan_p(#1) || ecl_lowereq(#0,#1))?#0:#1)\") (m"
 "in :always (fixnum fixnum) :fixnum \"@01;(#0)<=(#1)?#0:#1\") (logand :always nil t"
 " \"ecl_make_fixnum(-1)\") (logand :always nil :fixnum \"-1\") (logand :always (t t) "
 "t \"ecl_boole(ECL_BOOLAND,(#0),(#1))\") (logand :always (fixnum fixnum) :fixnum \"("
 "(#0) & (#1))\") (logandc1 :always (t t) t \"ecl_boole(ECL_BOOLANDC1,(#0),(#1))\") ("
 "logandc1 :always (fixnum fixnum) :fixnum \"(~(#0) & (#1))\") (logandc2 :always (t "
 "t) t \"ecl_boole(ECL_BOOLANDC2,(#0),(#1))\") (logandc2 :always (fixnum fixnum) :fi"
 "xnum \"((#0) & ~(#1))\") (logeqv :always nil t \"ecl_make_fixnum(-1)\") (logeqv :alw"
 "ays nil :fixnum \"-1\") (logeqv :always (t t) t \"ecl_boole(ECL_BOOLEQV,(#0),(#1))\""
 ") (logeqv :always (fixnum fixnum) :fixnum \"(~( (#0) ^ (#1) ))\") (logior :always "
 "nil t \"ecl_make_fixnum(0)\") (logior :always nil :fixnum \"0\") (logior :always (t "
 "t) t \"ecl_boole(ECL_BOOLIOR,(#0),(#1))\") (logior :always (fixnum fixnum) :fixnum"
 " \"((#0) | (#1))\") (lognand :always (t t) t \"ecl_boole(ECL_BOOLNAND,(#0),(#1))\") "
 "(lognand :always (fixnum fixnum) :fixnum \"(~( (#0) & (#1) ))\") (lognor :always ("
 "t t) t \"ecl_boole(ECL_BOOLNOR,(#0),(#1))\") (lognor :always (fixnum fixnum) :fixn"
 "um \"(~( (#0) | (#1) ))\") (lognot :always (t) t \"ecl_boole(ECL_BOOLXOR,(#0),ecl_m"
 "ake_fixnum(-1))\") (lognot :always (fixnum) :fixnum \"(~(#0))\") (logorc1 :always ("
 "t t) t \"ecl_boole(ECL_BOOLORC1,(#0),(#1))\") (logorc1 :always (fixnum fixnum) :fi"
 "xnum \"(~(#0) | (#1))\") (logorc2 :always (t t) t \"ecl_boole(ECL_BOOLORC2,(#0),(#1"
 "))\") (logorc2 :always (fixnum fixnum) :fixnum \"((#0) | ~(#1))\") (logxor :always "
 "nil t \"ecl_make_fixnum(0)\") (logxor :always nil :fixnum \"0\") (logxor :always (t "
 "t) t \"ecl_boole(ECL_BOOLXOR,(#0),(#1))\") (logxor :always (fixnum fixnum) :fixnum"
 " \"((#0) ^ (#1))\") (boole :always (fixnum t t) t \"ecl_boole((#0),(#1),(#2))\") (lo"
 "gbitp :always ((integer -29 29) fixnum) :bool \"(#1 >> #0) & 1\") (integer-length "
 ":always (t) :cl-index \"ecl_integer_length(#0)\") (zerop :always (t) :bool \"ecl_ze"
 "rop(#0)\") (zerop :always (c::fixnum-float) :bool \"(#0)==0\") (plusp :always (t) :"
 "bool \"ecl_plusp(#0)\") (plusp :always (c::fixnum-float) :bool \"(#0)>0\") (minusp :"
 "always (t) :bool \"ecl_minusp(#0)\") (minusp :always (c::fixnum-float) :bool \"(#0)"
 "<0\") (oddp :always (t) :bool \"ecl_oddp(#0)\") (oddp :always (fixnum fixnum) :bool"
 " \"(#0) & 1\") (evenp :always (t) :bool \"ecl_evenp(#0)\") (evenp :always (fixnum fi"
 "xnum) :bool \"~(#0) & 1\") (abs :always (t t) t \"ecl_abs(#0,#1)\") (exp :always (t)"
 " t \"ecl_exp(#0)\") (expt :always (t t) t \"ecl_expt(#0,#1)\") (expt :always ((integ"
 "er 2 2) (integer 0 29)) :fixnum \"(1<<(#1))\") (expt :always ((integer 0 0) t) :fi"
 "xnum \"0\") (expt :always ((integer 1 1) t) :fixnum \"1\") (expt :always ((long-floa"
 "t #1=0.0 *) long-float) :long-double \"powl((long double)#0,(long double)#1)\") (e"
 "xpt :always ((double-float #1# *) double-float) :double \"pow((double)#0,(double)"
 "#1)\") (expt :always ((single-float #1# *) single-float) :float \"powf((float)#0,("
 "float)#1)\") (expt :always (si::complex-single-float si::complex-single-float) :c"
 "sfloat \"cpowf(#0,#1)\") (expt :always (si::complex-double-float si::complex-doubl"
 "e-float) :cdfloat \"cpow(#0,#1)\") (expt :always (si::complex-long-float si::compl"
 "ex-long-float) :clfloat \"cpowl(#0,#1)\") (log :always (c::fixnum-float) :long-dou"
 "ble \"logl((long double)(#0))\" :exact-return-type t) (log :always (c::fixnum-floa"
 "t) :double \"log((double)(#0))\" :exact-return-type t) (log :always (c::fixnum-flo"
 "at) :float \"logf((float)(#0))\" :exact-return-type t) (log :always (si::complex-s"
 "ingle-float) :csfloat \"clogf(#0)\") (log :always (si::complex-double-float) :cdfl"
 "oat \"clog(#0)\") (log :always (si::complex-long-float) :clfloat \"clogl(#0)\") (sqr"
 "t :always (number) number \"ecl_sqrt(#0)\") (sqrt :always ((long-float #1# *)) :lo"
 "ng-double \"sqrtl((long double)(#0))\") (sqrt :always ((double-float #1# *)) :doub"
 "le \"sqrt((double)(#0))\") (sqrt :always ((single-float #1# *)) :float \"sqrtf((flo"
 "at)(#0))\") (sqrt :always (si::complex-single-float) :csfloat \"csqrtf(#0)\") (sqrt"
 " :always (si::complex-double-float) :cdfloat \"csqrt(#0)\") (sqrt :always (si::com"
 "plex-long-float) :clfloat \"csqrtl(#0)\") (sin :always (number) number \"ecl_sin(#0"
 ")\") (sin :always (c::fixnum-float) :long-double \"sinl((long double)(#0))\" :exact"
 "-return-type t) (sin :always (c::fixnum-float) :double \"sin((double)(#0))\" :exac"
 "t-return-type t) (sin :always (c::fixnum-float) :float \"sinf((float)(#0))\" :exac"
 "t-return-type t) (sin :always (si::complex-single-float) :csfloat \"csinf(#0)\") ("
 "sin :always (si::complex-double-float) :cdfloat \"csin(#0)\") (sin :always (si::co"
 "mplex-long-float) :clfloat \"csinl(#0)\") (cos :always (t) number \"ecl_cos(#0)\") ("
 "cos :always (c::fixnum-float) :long-double \"cosl((long double)(#0))\" :exact-retu"
 "rn-type t) (cos :always (c::fixnum-float) :double \"cos((double)(#0))\" :exact-ret"
 "urn-type t) (cos :always (c::fixnum-float) :float \"cosf((float)(#0))\" :exact-ret"
 "urn-type t) (cos :always (si::complex-single-float) :csfloat \"ccosf(#0)\") (cos :"
 "always (si::complex-double-float) :cdfloat \"ccos(#0)\") (cos :always (si::complex"
 "-long-float) :clfloat \"ccosl(#0)\") (tan :always (t) number \"ecl_tan(#0)\") (tan :"
 "always (c::fixnum-float) :long-double \"tanl((long double)(#0))\" :exact-return-ty"
 "pe t) (tan :always (c::fixnum-float) :double \"tan((double)(#0))\" :exact-return-t"
 "ype t) (tan :always (c::fixnum-float) :float \"tanf((float)(#0))\" :exact-return-t"
 "ype t) (tan :always (si::complex-single-float) :csfloat \"ctanf(#0)\") (tan :alway"
 "s (si::complex-double-float) :cdfloat \"ctan(#0)\") (tan :always (si::complex-long"
 "-float) :clfloat \"ctanl(#0)\") (sinh :always (t) number \"ecl_sinh(#0)\") (sinh :al"
 "ways (c::fixnum-float) :long-double \"sinhl((long double)(#0))\" :exact-return-typ"
 "e t) (sinh :always (c::fixnum-float) :double \"sinh((double)(#0))\" :exact-return-"
 "type t) (sinh :always (c::fixnum-float) :float \"sinhf((float)(#0))\" :exact-retur"
 "n-type t) (sinh :always (si::complex-single-float) :csfloat \"csinhf(#0)\") (sinh "
 ":always (si::complex-double-float) :cdfloat \"csinh(#0)\") (sinh :always (si::comp"
 "lex-long-float) :clfloat \"csinhl(#0)\") (cosh :always (t) number \"ecl_cosh(#0)\") "
 "(cosh :always (c::fixnum-float) :long-double \"coshl((long double)(#0))\" :exact-r"
 "eturn-type t) (cosh :always (c::fixnum-float) :double \"cosh((double)(#0))\" :exac"
 "t-return-type t) (cosh :always (c::fixnum-float) :float \"coshf((float)(#0))\" :ex"
 "act-return-type t) (cosh :always (si::complex-single-float) :csfloat \"ccoshf(#0)"
 "\") (cosh :always (si::complex-double-float) :cdfloat \"ccosh(#0)\") (cosh :always "
 "(si::complex-long-float) :clfloat \"ccoshl(#0)\") (tanh :always (t) number \"ecl_ta"
 "nh(#0)\") (tanh :always (c::fixnum-float) :long-double \"tanhl((long double)(#0))\""
 " :exact-return-type t) (tanh :always (c::fixnum-float) :double \"tanh((double)(#0"
 "))\" :exact-return-type t) (tanh :always (c::fixnum-float) :float \"tanhf((float)("
 "#0))\" :exact-return-type t) (tanh :always (si::complex-single-float) :csfloat \"c"
 "tanhf(#0)\") (tanh :always (si::complex-double-float) :cdfloat \"ctanh(#0)\") (tanh"
 " :always (si::complex-long-float) :clfloat \"ctanhl(#0)\") (null :always (t) :bool"
 " \"#0==ECL_NIL\") (symbolp :always (t) :bool \"@0;ECL_SYMBOLP(#0)\") (atom :always ("
 "t) :bool \"@0;ECL_ATOM(#0)\") (consp :always (t) :bool \"@0;ECL_CONSP(#0)\") (listp "
 ":always (t) :bool \"@0;ECL_LISTP(#0)\") (numberp :always (t) :bool \"ecl_numberp(#0"
 ")\") (integerp :always (t) :bool \"@0;ECL_FIXNUMP(#0)||ECL_BIGNUMP(#0)\") (floatp :"
 "always (t) :bool \"floatp(#0)\") (characterp :always (t) :bool \"ECL_CHARACTERP(#0)"
 "\") (c::base-char-p :always (character) :bool \"ECL_BASE_CHAR_P(#0)\") (stringp :al"
 "ways (t) :bool \"@0;ECL_STRINGP(#0)\") (c::base-string-p :always (t) :bool \"@0;ECL"
 "_BASE_STRINGP(#0)\") (bit-vector-p :always (t) :bool \"@0;ECL_BIT_VECTOR_P(#0)\") ("
 "vectorp :always (t) :bool \"@0;ECL_VECTORP(#0)\") (arrayp :always (t) :bool \"@0;EC"
 "L_ARRAYP(#0)\") (eq :always (t t) :bool \"(#0)==(#1)\") (eq :always (fixnum fixnum)"
 " :bool \"(#0)==(#1)\") (eql :always (t t) :bool \"ecl_eql(#0,#1)\") (eql :always (ch"
 "aracter t) :bool \"(ECL_CODE_CHAR(#0)==(#1))\") (eql :always (t character) :bool \""
 "((#0)==ECL_CODE_CHAR(#1))\") (eql :always (character character) :bool \"(#0)==(#1)"
 "\") (eql :always ((not (or complex bignum ratio float)) t) :bool \"(#0)==(#1)\") (e"
 "ql :always (t (not (or complex bignum ratio float))) :bool \"(#0)==(#1)\") (eql :a"
 "lways (fixnum fixnum) :bool \"(#0)==(#1)\") (equal :always (t t) :bool \"ecl_equal("
 "#0,#1)\") (equal :always (fixnum fixnum) :bool \"(#0)==(#1)\") (equalp :always (t t"
 ") :bool \"ecl_equalp(#0,#1)\") (equalp :always (fixnum fixnum) :bool \"(#0)==(#1)\")"
 " (not :always (t) :bool \"(#0)==ECL_NIL\") (clear-output :always (stream) null \"(e"
 "cl_clear_output(#0),ECL_NIL)\") (finish-output :always (stream) null \"(ecl_finish"
 "_output(#0),ECL_NIL)\") (finish-output :always (stream) null \"(ecl_force_output(#"
 "0),ECL_NIL)\") (write-char :always (t) t \"@0;(ecl_princ_char(ecl_char_code(#0),EC"
 "L_NIL),(#0))\") (clear-input :always (stream) null \"(ecl_clear_input(#0),ECL_NIL)"
 "\") (copy-readtable :always (null null) t \"standard_readtable\") (boundp :always ("
 "t) :bool \"ecl_boundp(cl_env_copy,#0)\") (boundp :unsafe ((and symbol (not null)))"
 " :bool \"ECL_SYM_VAL(cl_env_copy,#0)!=OBJNULL\") (elt :always (t t) t \"ecl_elt(#0,"
 "ecl_fixnum(#1))\") (elt :always (t fixnum) t \"ecl_elt(#0,#1)\") (elt :always (vect"
 "or t) t \"ecl_aref1(#0,ecl_fixnum(#1))\") (elt :always (vector fixnum) t \"ecl_aref"
 "1(#0,#1)\") (elt :unsafe (t t) t \"ecl_elt(#0,ecl_fixnum(#1))\") (elt :unsafe (t fi"
 "xnum) t \"ecl_elt(#0,#1)\") (elt :unsafe (vector t) t \"ecl_aref_unsafe(#0,ecl_fixn"
 "um(#1))\") (elt :unsafe (vector fixnum) t \"ecl_aref_unsafe(#0,#1)\") (aref :unsafe"
 " ((array bit) t) :fixnum \"ecl_aref_bv(#0,ecl_fixnum(#1))\") (aref :unsafe ((array"
 " bit) fixnum) :fixnum \"ecl_aref_bv(#0,#1)\") (aref :unsafe ((array character) fix"
 "num) :wchar \"(#0)->string.self[#1]\") (aref :unsafe ((array base-char) fixnum) :u"
 "nsigned-char \"(#0)->base_string.self[#1]\") (aref :unsafe ((array double-float) f"
 "ixnum) :double \"(#0)->array.self.df[#1]\") (aref :unsafe ((array single-float) fi"
 "xnum) :float \"(#0)->array.self.sf[#1]\") (aref :unsafe ((array fixnum) fixnum) :f"
 "ixnum \"(#0)->array.self.fix[#1]\") (si::elt-set :always (t t t) t \"ecl_elt_set(#0"
 ",ecl_to_size(#1),#2)\") (si::elt-set :always (t fixnum t) t \"ecl_elt_set(#0,#1,#2"
 ")\") (si::elt-set :always (vector t t) t \"ecl_aset1(#0,ecl_to_size(#1),#2)\") (si:"
 ":elt-set :always (vector fixnum t) t \"ecl_aset1(#0,#1,#2)\") (si::elt-set :unsafe"
 " (t t t) t \"ecl_elt_set(#0,ecl_fixnum(#1),#2)\") (si::elt-set :unsafe (vector t t"
 ") t \"ecl_aset_unsafe(#0,ecl_to_size(#1),#2)\") (si::elt-set :unsafe (vector fixnu"
 "m t) t \"ecl_aset_unsafe(#0,#1,#2)\") (length :always (t) :fixnum \"ecl_length(#0)\""
 ") (length :unsafe (vector) :fixnum \"(#0)->vector.fillp\") (copy-seq :always (t) t"
 " \"ecl_copy_seq(#0)\") (char :always (t fixnum) t \"ecl_aref1(#0,#1)\") (char :alway"
 "s (t fixnum) :wchar \"ecl_char(#0,#1)\") (char :unsafe (base-string fixnum) :unsig"
 "ned-char \"(#0)->base_string.self[#1]\") (char :unsafe (ext::extended-string fixnu"
 "m) :wchar \"(#0)->string.self[#1]\") (si::char-set :always (t t t) t \"si_char_set("
 "#0,#1,#2)\") (si::char-set :always (t fixnum t) t \"ecl_aset1(#0,#1,#2)\") (si::cha"
 "r-set :always (t fixnum character) :wchar \"ecl_char_set(#0,#1,#2)\") (si::char-se"
 "t :unsafe (base-string t t) t \"@2;((#0)->base_string.self[ecl_fixnum(#1)]=ecl_ch"
 "ar_code(#2),(#2))\") (si::char-set :unsafe (base-string fixnum base-char) :unsign"
 "ed-char \"(#0)->base_string.self[#1]= #2\") (si::char-set :unsafe (ext::extended-s"
 "tring t t) t \"@2;((#0)->string.self[ecl_fixnum(#1)]=ecl_char_code(#2),(#2))\") (s"
 "i::char-set :unsafe (ext::extended-string fixnum character) :unsigned-char \"(#0)"
 "->string.self[#1]= #2\") (schar :always (t t) t \"ecl_elt(#0,ecl_to_size(#1))\") (s"
 "char :always (t fixnum) t \"ecl_elt(#0,#1)\") (schar :always (t fixnum) :wchar \"ec"
 "l_char(#0,#1)\") (schar :unsafe (base-string t) t \"ECL_CODE_CHAR((#0)->base_strin"
 "g.self[ecl_fixnum(#1)])\") (schar :unsafe (base-string fixnum) :unsigned-char \"(#"
 "0)->base_string.self[#1]\") (schar :unsafe (ext::extended-string fixnum) :wchar \""
 "(#0)->string.self[#1]\") (si::schar-set :always (t t t) t \"ecl_elt_set(#0,ecl_to_"
 "size(#1),#2)\") (si::schar-set :always (t fixnum t) t \"ecl_elt_set(#0,#1,#2)\") (s"
 "i::schar-set :always (t fixnum character) :wchar \"ecl_char_set(#0,#1,#2)\") (si::"
 "schar-set :unsafe (base-string t t) t \"@2;((#0)->base_string.self[ecl_fixnum(#1)"
 "]=ecl_char_code(#2),(#2))\") (si::schar-set :unsafe (base-string fixnum base-char"
 ") :unsigned-char \"(#0)->base_string.self[#1]= #2\") (si::schar-set :unsafe (ext::"
 "extended-string fixnum t) :wchar \"@2;((#0)->string.self[#1]= ecl_char_code(#2),("
 "#2))\") (si::schar-set :unsafe (ext::extended-string fixnum character) :wchar \"(#"
 "0)->string.self[#1]= #2\") (string= :always (string string) :bool \"ecl_string_eq("
 "#0,#1)\") (si::structure-name :always (structure-object) symbol \"ECL_STRUCT_NAME("
 "#0)\") (si::structure-ref :always (t t fixnum) t \"ecl_structure_ref(#0,#1,#2)\") ("
 "si::structure-set :always (t t fixnum t) t \"ecl_structure_set(#0,#1,#2,#3)\") (ge"
 "t :always (t t t) t \"ecl_get(#0,#1,#2)\") (get :always (t t) t \"ecl_get(#0,#1,ECL"
 "_NIL)\") (symbol-name :always (t) string \"ecl_symbol_name(#0)\") (c::shift>> :alwa"
 "ys (fixnum fixnum) :fixnum \"((#0) >> (- (#1)))\") (c::shift<< :always (fixnum fix"
 "num) :fixnum \"((#0) << (#1))\") (si::short-float-p :always (t) :bool \"@0;ECL_SING"
 "LE_FLOAT_P(#0)\") (si::single-float-p :always (t) :bool \"@0;ECL_SINGLE_FLOAT_P(#0"
 ")\") (si::double-float-p :always (t) :bool \"@0;ECL_DOUBLE_FLOAT_P(#0)\") (si::long"
 "-float-p :always (t) :bool \"@0;ECL_LONG_FLOAT_P(#0)\") (si::complex-single-float-"
 "p :always (t) :bool \"@0;ECL_COMPLEX_SINGLE_FLOAT_P(#0)\") (si::complex-double-flo"
 "at-p :always (t) :bool \"@0;ECL_COMPLEX_DOUBLE_FLOAT_P(#0)\") (si::complex-long-fl"
 "oat-p :always (t) :bool \"@0;ECL_COMPLEX_LONG_FLOAT_P(#0)\") (ext::fixnump :always"
 " (t) :bool \"ECL_FIXNUMP(#0)\") (ext::fixnump :always (fixnum) :bool \"1\") (mp::loc"
 "k-count :unsafe (mp::lock) fixnum \"((#0)->lock.counter)\") (mp::compare-and-swap-"
 "car :always (cons t t) t \"ecl_compare_and_swap(&ECL_CONS_CAR(#0),(#1),(#2))\") (m"
 "p::atomic-incf-car :always (cons t) t \"ecl_atomic_incf(&ECL_CONS_CAR(#0),(#1))\")"
 " (mp::atomic-incf-car :always (cons fixnum) t \"ecl_atomic_incf_by_fixnum(&ECL_CO"
 "NS_CAR(#0),(#1))\") (mp::compare-and-swap-cdr :always (cons t t) t \"ecl_compare_a"
 "nd_swap(&ECL_CONS_CDR(#0),(#1),(#2))\") (mp::atomic-incf-cdr :always (cons t) t \""
 "ecl_atomic_incf(&ECL_CONS_CDR(#0),(#1))\") (mp::atomic-incf-cdr :always (cons fix"
 "num) t \"ecl_atomic_incf_by_fixnum(&ECL_CONS_CDR(#0),(#1))\") (mp::compare-and-swa"
 "p-symbol-value :unsafe (symbol t t) t \"ecl_compare_and_swap(ecl_bds_ref(ecl_proc"
 "ess_env(),(#0)),(#1),(#2))\") (mp::atomic-incf-symbol-value :always (t fixnum) t "
 "\"ecl_atomic_incf_by_fixnum(ecl_bds_ref(ecl_process_env(),(#0)),(#1))\") (mp::atom"
 "ic-incf-symbol-value :unsafe (symbol t) t \"ecl_atomic_incf(ecl_bds_ref(ecl_proce"
 "ss_env(),(#0)),(#1))\") (mp::atomic-incf-symbol-value :unsafe (symbol fixnum) t \""
 "ecl_atomic_incf_by_fixnum(ecl_bds_ref(ecl_process_env(),(#0)),(#1))\") (mp::compa"
 "re-and-swap-svref :unsafe (t t t t) t \"ecl_compare_and_swap((#0)->vector.self.t "
 "+ ecl_fixnum(#1),(#2),(#3))\") (mp::compare-and-swap-svref :unsafe (t fixnum t t)"
 " t \"ecl_compare_and_swap((#0)->vector.self.t + (#1),(#2),(#3))\") (mp::compare-an"
 "d-swap-instance :always (t fixnum t t) t \"ecl_compare_and_swap_instance((#0),(#1"
 "),(#2),(#3))\") (mp::compare-and-swap-instance :unsafe (standard-object fixnum t "
 "t) t \"ecl_compare_and_swap((#0)->instance.slots+(#1),(#2),(#3))\") (mp::atomic-in"
 "cf-instance :always (t fixnum t) t \"ecl_atomic_incf_instance((#0),(#1),(#2))\") ("
 "mp::atomic-incf-instance :unsafe (standard-object fixnum t) t \"ecl_atomic_incf(("
 "#0)->instance.slots+(#1),(#2))\") (mp::atomic-incf-instance :unsafe (standard-obj"
 "ect fixnum fixnum) t \"ecl_atomic_incf_by_fixnum((#0)->instance.slots+(#1),(#2))\""
 ") (mp::compare-and-swap-structure :unsafe (structure-object t fixnum t t) t \"ecl"
 "_compare_and_swap(&(ECL_STRUCT_SLOT((#0),(#2))),(#3),(#4))\") (si::instance-ref :"
 "always (t fixnum) t \"ecl_instance_ref((#0),(#1))\") (si::instance-ref :unsafe (st"
 "andard-object fixnum) t \"(#0)->instance.slots[#1]\") (si::instance-slotds :unsafe"
 " (standard-object) list \"(#0)->instance.slotds\") (si::instance-set :unsafe (t fi"
 "xnum t) t \"ecl_instance_set((#0),(#1),(#2))\") (si::instance-set :unsafe (standar"
 "d-object fixnum t) t \"(#0)->instance.slots[#1]=(#2)\") (si::instance-class :alway"
 "s (standard-object) t \"ECL_CLASS_OF(#0)\") (class-of :unsafe (standard-object) t "
 "\"ECL_CLASS_OF(#0)\") (si::instancep :always (t) :bool \"@0;ECL_INSTANCEP(#0)\") (si"
 "::unbound :always nil t \"ECL_UNBOUND\") (si::sl-boundp :always (t) :bool \"(#0)!=E"
 "CL_UNBOUND\") (clos::standard-instance-access :always (t fixnum) t \"ecl_instance_"
 "ref((#0),(#1))\") (clos::standard-instance-access :unsafe (standard-object fixnum"
 ") t \"(#0)->instance.slots[#1]\") (clos::funcallable-standard-instance-access :alw"
 "ays (t fixnum) t \"ecl_instance_ref((#0),(#1))\") (clos::funcallable-standard-inst"
 "ance-access :unsafe (clos::funcallable-standard-object fixnum) t \"(#0)->instance"
 ".slots[#1]\")) c::make-inline-information c::inline-information (setf c::inline-i"
 "nformation) :unsafe :inline-unsafe :safe :inline-safe :always :inline-always \"In"
 " DEF-INLINE, wrong value of SAFETY\" c::fixnum-float \"Dropping inline form for ~A"
 " because of missing type ~A\" c::should-be-inlined :arg-rep-types :return-rep-typ"
 "e :return-type :arg-types :exact-return-type :multiple-values :one-liner :expans"
 "ion c::def-inline c::*default-machine* c::machine si::c-export-fname si::find-do"
 "cumentation si::find-declarations si::search-keyword si::check-keyword si::dm-to"
 "o-many-arguments si::dm-too-few-arguments si::remove-documentation si::structure"
 "-type-error si::define-structure si::get-documentation si::set-documentation si:"
 ":expand-set-documentation si::packages-iterator si::pprint-logical-block-helper "
 "si::pprint-pop-helper si::make-seq-iterator si::seq-iterator-ref si::seq-iterato"
 "r-set si::seq-iterator-next si::coerce-to-list si::coerce-to-vector 0 0 0 0 :one"
 "-liner :exact-return-type :inline-or-warn :multiple-values c::lisp-type-p c::mac"
 "hine-c-type-p c::rep-type->lisp-type c::make-inline-info c::lisp-type->rep-type "
 "\"COMPILER\" \"SI\" (si::format-princ si::format-prin1 si::format-print-named-charac"
 "ter si::format-print-integer si::format-print-cardinal si::format-print-ordinal "
 "si::format-print-old-roman si::format-print-roman si::format-fixed si::format-ex"
 "ponential si::format-general si::format-dollars si::format-relative-tab si::form"
 "at-absolute-tab si::format-justification) (clos::associate-methods-to-gfun clos:"
 ":install-method clos::find-slot-definition)" };

static const cl_object compiler_data_text[] = {
(cl_object)compiler_data_text1,
NULL};
