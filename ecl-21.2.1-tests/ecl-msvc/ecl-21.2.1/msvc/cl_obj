c/abs.c:cl_object
c/abs.c:cl_abs(cl_object x)
c/abs.c:	cl_object __value0 = ecl_abs(x);
c/abs.c:static cl_object
c/abs.c:ecl_abs_fixnum(cl_object x)
c/abs.c:static cl_object
c/abs.c:ecl_abs_bignum(cl_object x)
c/abs.c:static cl_object
c/abs.c:ecl_abs_rational(cl_object x)
c/abs.c:static cl_object
c/abs.c:ecl_abs_single_float(cl_object x)
c/abs.c:static cl_object
c/abs.c:ecl_abs_double_float(cl_object x)
c/abs.c:static cl_object
c/abs.c:ecl_abs_long_float(cl_object x)
c/abs.c:static cl_object
c/abs.c:ecl_abs_complex(cl_object x)
c/abs.c:  cl_object r = ecl_abs(x->gencomplex.real);
c/abs.c:  cl_object i = ecl_abs(x->gencomplex.imag);
c/abs.c:      cl_object aux = i;
c/abs.c:static cl_object
c/abs.c:ecl_abs_csfloat(cl_object x)
c/abs.c:static cl_object
c/abs.c:ecl_abs_cdfloat(cl_object x)
c/abs.c:static cl_object
c/abs.c:ecl_abs_clfloat(cl_object x)
c/accessor.c:no_applicable_method(cl_env_ptr env, cl_object gfun, cl_object args)
c/accessor.c:static cl_object
c/accessor.c:fill_spec_vector(cl_object vector, cl_object gfun, cl_object instance)
c/accessor.c:  cl_object *argtype = vector->vector.self.t;
c/accessor.c:static cl_object
c/accessor.c:slot_method_name(cl_object gfun, cl_object args)
c/accessor.c:  cl_object methods = _ecl_funcall3(ECL_SYM("COMPUTE-APPLICABLE-METHODS",938),
c/accessor.c:    cl_object first = ECL_CONS_CAR(methods);
c/accessor.c:    cl_object slotd = _ecl_funcall3(ECL_SYM("SLOT-VALUE",973), first,
c/accessor.c:static cl_object
c/accessor.c:slot_method_index(cl_object gfun, cl_object instance, cl_object args)
c/accessor.c:  cl_object slot_name = slot_method_name(gfun, args);
c/accessor.c:    cl_object table = _ecl_funcall3(ECL_SYM("SLOT-VALUE",973),
c/accessor.c:search_slot_index(const cl_env_ptr env, cl_object gfun, cl_object instance)
c/accessor.c:add_new_index(const cl_env_ptr env, cl_object gfun, cl_object instance, cl_object args)
c/accessor.c:  cl_object index = slot_method_index(gfun, instance, args);
c/accessor.c:ensure_up_to_date_instance(cl_object instance)
c/accessor.c:cl_object
c/accessor.c:ecl_slot_reader_dispatch(cl_narg narg, ... /* cl_object instance */)
c/accessor.c:  cl_object gfun = env->function;
c/accessor.c:  cl_object index, value;
c/accessor.c:  cl_object instance;
c/accessor.c:    instance = va_arg(args, cl_object);
c/accessor.c:    cl_object args = ecl_list1(instance);
c/accessor.c:    cl_object slot_name = slot_method_name(gfun, ecl_list1(instance));
c/accessor.c:	cl_object __value0 = value;
c/accessor.c:cl_object
c/accessor.c:ecl_slot_writer_dispatch(cl_narg narg, ... /* cl_object value, cl_object instance */)
c/accessor.c:  cl_object gfun = env->function;
c/accessor.c:  cl_object index;
c/accessor.c:  cl_object value, instance;
c/accessor.c:    value = va_arg(args, cl_object);
c/accessor.c:    instance = va_arg(args, cl_object);
c/accessor.c:    cl_object args = cl_list(2, value, instance);
c/accessor.c:	cl_object __value0 = value;
c/alloc_2.c:static int cl_object_kind, cl_object_mark_proc_index;
c/alloc_2.c:static void **cl_object_free_list;
c/alloc_2.c:  cl_object (*allocator)(register struct ecl_type_information *);
c/alloc_2.c:ecl_object_byte_size(cl_type t)
c/alloc_2.c:    FEerror("ecl_object_byte_size invoked with an immediate type ~D",
c/alloc_2.c:    FEerror("ecl_object_byte_size invoked with an unknown type ~D",
c/alloc_2.c:static cl_object
c/alloc_2.c:  cl_object op;
c/alloc_2.c:static cl_object
c/alloc_2.c:  cl_object op;
c/alloc_2.c:static cl_object
c/alloc_2.c:  cl_object op;
c/alloc_2.c:static cl_object
c/alloc_2.c:    opp = &(cl_object_free_list[lg]);
c/alloc_2.c:      op = (ptr_t)GENERAL_MALLOC((word)lb, cl_object_kind);
c/alloc_2.c:    op = (ptr_t)GENERAL_MALLOC((word)lb, cl_object_kind);
c/alloc_2.c:  ((cl_object)op)->d.t = type_info->t;
c/alloc_2.c:  return (cl_object)op;
c/alloc_2.c:cl_object_mark_proc(void *addr, struct GC_ms_entry *msp, struct GC_ms_entry *msl,
c/alloc_2.c:  cl_type t = ((cl_object)addr)->d.t;
c/alloc_2.c:  cl_object o = (cl_object)addr;
c/alloc_2.c:static cl_object
c/alloc_2.c:  cl_object op;
c/alloc_2.c:  op = GC_generic_malloc(type_info->size, cl_object_kind);
c/alloc_2.c:cl_object
c/alloc_2.c:    cl_object obj;
c/alloc_2.c:    obj = (cl_object)GC_MALLOC_ATOMIC(type_info[t].size);
c/alloc_2.c:    cl_object obj;
c/alloc_2.c:    obj = (cl_object)GC_MALLOC(type_info[t].size);
c/alloc_2.c:cl_object
c/alloc_2.c:  cl_object x;
c/alloc_2.c:  x = (cl_object)GC_MALLOC_ATOMIC(size + extra_space);
c/alloc_2.c:cl_object
c/alloc_2.c:ecl_cons(cl_object a, cl_object d)
c/alloc_2.c:  return (cl_object)obj;
c/alloc_2.c:cl_object
c/alloc_2.c:ecl_list1(cl_object a)
c/alloc_2.c:  return (cl_object)obj;
c/alloc_2.c:cl_object
c/alloc_2.c:  cl_object i;
c/alloc_2.c:  i->instance.slots = (cl_object *)ecl_alloc(sizeof(cl_object) * slots);
c/alloc_2.c:  cl_object_free_list = (void **)GC_new_free_list_inner();
c/alloc_2.c:  cl_object_kind = GC_new_kind_inner(cl_object_free_list,
c/alloc_2.c:  cl_object_free_list = (void **)GC_new_free_list_inner();
c/alloc_2.c:  cl_object_mark_proc_index = GC_new_proc((GC_mark_proc)cl_object_mark_proc);
c/alloc_2.c:  cl_object_kind = GC_new_kind_inner(cl_object_free_list,
c/alloc_2.c:                                     GC_MAKE_PROC(cl_object_mark_proc_index, 0),
c/alloc_2.c:standard_finalizer(cl_object o)
c/alloc_2.c:wrapped_finalizer(cl_object o, cl_object finalizer);
c/alloc_2.c:deferred_finalizer(cl_object* x)
c/alloc_2.c:wrapped_finalizer(cl_object o, cl_object finalizer)
c/alloc_2.c:       cl_object* wrapper = GC_MALLOC(2*sizeof(cl_object));
c/alloc_2.c:cl_object
c/alloc_2.c:si_get_finalizer(cl_object o)
c/alloc_2.c:  cl_object output;
c/alloc_2.c:    output = (cl_object)odata;
c/alloc_2.c:	cl_object __value0 = output;
c/alloc_2.c:ecl_set_finalizer_unprotected(cl_object o, cl_object finalizer)
c/alloc_2.c:cl_object
c/alloc_2.c:si_set_finalizer(cl_object o, cl_object finalizer)
c/alloc_2.c:cl_object
c/alloc_2.c:si_gc_stats(cl_object enable)
c/alloc_2.c:  cl_object old_status;
c/alloc_2.c:  cl_object size1;
c/alloc_2.c:  cl_object size2;
c/alloc_2.c:	cl_object __value0 = size1;
c/alloc_2.c:	cl_object __value1 = size2;
c/alloc_2.c:	cl_object __value2 = old_status;
c/alloc_2.c:  /*memset(env->values[env->nvalues], 0, (64-env->nvalues)*sizeof(cl_object));*/
c/alloc_2.c:  cl_object l;
c/alloc_2.c:      cl_object dll = ECL_CONS_CAR(l);
c/alloc_2.c:      cl_object process = l->vector.self.t[i];
c/alloc_2.c:ecl_register_root(cl_object *p)
c/alloc_2.c:cl_object
c/alloc_2.c:cl_object
c/alloc_2.c:static cl_object
c/alloc_2.c:ecl_alloc_weak_pointer(cl_object o)
c/alloc_2.c:    si_set_finalizer((cl_object)obj, ECL_T);
c/alloc_2.c:  return (cl_object)obj;
c/alloc_2.c:cl_object
c/alloc_2.c:si_make_weak_pointer(cl_object o)
c/alloc_2.c:  cl_object pointer = ecl_alloc_weak_pointer(o);
c/alloc_2.c:	cl_object __value0 = pointer;
c/alloc_2.c:static cl_object
c/alloc_2.c:ecl_weak_pointer_value(cl_object o)
c/alloc_2.c:cl_object
c/alloc_2.c:si_weak_pointer_value(cl_object o)
c/alloc_2.c:  cl_object value;
c/alloc_2.c:  value = (cl_object)GC_call_with_alloc_lock((GC_fn_type)ecl_weak_pointer_value, o);
c/alloc_2.c:	cl_object __value0 = value;
c/alloc_2.c:	cl_object __value1 = ECL_T;
c/alloc_2.c:	cl_object __value0 = ECL_NIL;
c/alloc_2.c:	cl_object __value1 = ECL_NIL;
c/all_symbols.c:mangle_name(cl_object output, unsigned char *source, int l)
c/all_symbols.c:cl_object si_mangle_name(cl_narg narg, cl_object symbol, ...)
c/all_symbols.c:  cl_object output;
c/all_symbols.c:  cl_object package;
c/all_symbols.c:  cl_object found = ECL_NIL;
c/all_symbols.c:  cl_object maxarg = ecl_make_fixnum(ECL_CALL_ARGUMENTS_LIMIT);
c/all_symbols.c:  cl_object minarg = ecl_make_fixnum(0);
c/all_symbols.c:  cl_object name;
c/all_symbols.c:	cl_object as_function;
c/all_symbols.c:		as_function = va_arg(ARGS,cl_object);
c/all_symbols.c:	cl_object __value0 = ECL_T;
c/all_symbols.c:	cl_object __value1 = ecl_make_constant_base_string("ECL_NIL",-1);
c/all_symbols.c:	cl_object __value2 = minarg;
c/all_symbols.c:	cl_object __value3 = maxarg;
c/all_symbols.c:	cl_object __value0 = ECL_T;
c/all_symbols.c:	cl_object __value1 = ecl_make_constant_base_string("ECL_T",-1);
c/all_symbols.c:	cl_object __value2 = minarg;
c/all_symbols.c:	cl_object __value3 = maxarg;
c/all_symbols.c:      cl_object plist = cl_symbol_plist(symbol);
c/all_symbols.c:	cl_object __value0 = found;
c/all_symbols.c:	cl_object __value1 = output;
c/all_symbols.c:	cl_object __value2 = minarg;
c/all_symbols.c:	cl_object __value3 = maxarg;
c/all_symbols.c:    cl_object fun = symbol->symbol.gfdef;
c/all_symbols.c:        cl_object s = (cl_object)(cl_symbols + l);
c/all_symbols.c:	cl_object __value0 = found;
c/all_symbols.c:	cl_object __value1 = symbol->symbol.cname;
c/all_symbols.c:	cl_object __value2 = minarg;
c/all_symbols.c:	cl_object __value3 = maxarg;
c/all_symbols.c:	cl_object __value0 = ECL_NIL;
c/all_symbols.c:	cl_object __value1 = ECL_NIL;
c/all_symbols.c:	cl_object __value2 = minarg;
c/all_symbols.c:	cl_object __value3 = maxarg;
c/all_symbols.c:	cl_object __value0 = ECL_NIL;
c/all_symbols.c:	cl_object __value1 = ECL_NIL;
c/all_symbols.c:	cl_object __value2 = minarg;
c/all_symbols.c:	cl_object __value3 = maxarg;
c/all_symbols.c:	cl_object __value0 = found;
c/all_symbols.c:	cl_object __value1 = output;
c/all_symbols.c:	cl_object __value2 = minarg;
c/all_symbols.c:	cl_object __value3 = maxarg;
c/all_symbols.c:make_this_symbol(int i, cl_object s, int code,
c/all_symbols.c:                 cl_objectfn fun, int narg, cl_object value)
c/all_symbols.c:  cl_object package;
c/all_symbols.c:    cl_object f;
c/all_symbols.c:      f = ecl_make_cfun((cl_objectfn_fixed)fun, s, NULL, narg);
c/all_symbols.c:  cl_object s, value;
c/all_symbols.c:  cl_objectfn fun;
c/all_symbols.c:    s = (cl_object)(cl_symbols + i);
c/all_symbols.c:    fun = (cl_objectfn)cl_symbols[i].init.fun;
c/apply.c:cl_object
c/apply.c:APPLY(cl_narg n, cl_objectfn fn, cl_object *x)
c/apply.c:cl_object
c/apply.c:APPLY_fixed(cl_narg n, cl_object (*fn)(), cl_object *x)
c/array.c:static const cl_object ecl_aet_name[] = {
c/array.c:out_of_bounds_error(cl_index ndx, cl_object x)
c/array.c:  cl_object type = cl_list(3, ECL_SYM("INTEGER",439), ecl_make_fixnum(0),
c/array.c:FEwrong_dimensions(cl_object a, cl_index rank)
c/array.c:  cl_object list = cl_make_list(3, ecl_make_fixnum(rank),
c/array.c:  cl_object type = cl_list(3, ECL_SYM("ARRAY",98), ECL_SYM("*",20), list);
c/array.c:checked_index(cl_object function, cl_object a, int which, cl_object index,
c/array.c:ecl_to_index(cl_object n)
c/array.c:cl_object
c/array.c:cl_row_major_aref(cl_object x, cl_object indx)
c/array.c:	cl_object __value0 = ecl_aref(x, j);
c/array.c:cl_object
c/array.c:si_row_major_aset(cl_object x, cl_object indx, cl_object val)
c/array.c:	cl_object __value0 = ecl_aset(x, j, val);
c/array.c:cl_object cl_aref(cl_narg narg, cl_object x, ...)
c/array.c:	cl_object __value0 = ecl_aref_unsafe(x, j);
c/array.c:cl_object
c/array.c:ecl_aref_unsafe(cl_object x, cl_index index)
c/array.c:cl_object
c/array.c:ecl_aref(cl_object x, cl_index index)
c/array.c:cl_object
c/array.c:ecl_aref1(cl_object x, cl_index index)
c/array.c:ecl_row_major_ptr(cl_object x, cl_index index, cl_index bytes)
c/array.c:cl_object si_aset(cl_narg narg, cl_object x, ...)
c/array.c:    cl_object v;
c/array.c:	cl_object __value0 = ecl_aset_unsafe(x, j, v);
c/array.c:cl_object
c/array.c:ecl_aset_unsafe(cl_object x, cl_index index, cl_object value)
c/array.c:cl_object
c/array.c:ecl_aset(cl_object x, cl_index index, cl_object value)
c/array.c:cl_object
c/array.c:ecl_aset1(cl_object x, cl_index index, cl_object value)
c/array.c:cl_object
c/array.c:si_make_pure_array(cl_object etype, cl_object dims, cl_object adj,
c/array.c:                   cl_object fillp, cl_object displ, cl_object disploff)
c/array.c:  cl_object x;
c/array.c:    cl_object d = ECL_CONS_CAR(dims);
c/array.c:        cl_object type = ecl_make_integer_type(ecl_make_fixnum(0),
c/array.c:      cl_object type = ecl_make_integer_type(ecl_make_fixnum(0),
c/array.c:	cl_object __value0 = x;
c/array.c:cl_object
c/array.c:si_make_vector(cl_object etype, cl_object dim, cl_object adj,
c/array.c:               cl_object fillp, cl_object displ, cl_object disploff)
c/array.c:  cl_object x;
c/array.c:    cl_object type = ecl_make_integer_type(ecl_make_fixnum(0),
c/array.c:	cl_object __value0 = x;
c/array.c:cl_object *
c/array.c:  cl_object *p = ecl_alloc_align(sizeof(cl_object) * l, sizeof(cl_object));
c/array.c:ecl_array_allocself(cl_object x)
c/array.c:cl_object
c/array.c:  cl_object x;
c/array.c:ecl_symbol_to_elttype(cl_object x)
c/array.c:cl_object
c/array.c:cl_object
c/array.c:si_array_element_type_byte_size(cl_object type) {
c/array.c:  cl_object size = ecl_make_fixnum(ecl_aet_size[aet]);
c/array.c:	cl_object __value0 = size;
c/array.c:	cl_object __value1 = ecl_elttype_to_symbol(aet);
c/array.c:cl_object
c/array.c:cl_array_element_type(cl_object a)
c/array.c:	cl_object __value0 = ecl_elttype_to_symbol(ecl_array_elttype(a));
c/array.c:ecl_displace(cl_object from, cl_object to, cl_object offset)
c/array.c:      cl_object type = ecl_make_integer_type(ecl_make_fixnum(0),
c/array.c:      cl_object track_list = to->array.displaced;
c/array.c:cl_object
c/array.c:si_array_raw_data(cl_object x)
c/array.c:  cl_object output, to_array;
c/array.c:    cl_object fillp = ECL_NIL;
c/array.c:	cl_object __value0 = output;
c/array.c:ecl_array_elttype(cl_object x)
c/array.c:cl_object
c/array.c:cl_array_rank(cl_object a)
c/array.c:	cl_object __value0 = ecl_make_fixnum(ecl_array_rank(a));
c/array.c:ecl_array_rank(cl_object a)
c/array.c:cl_object
c/array.c:cl_array_dimension(cl_object a, cl_object index)
c/array.c:	cl_object __value0 = ecl_make_fixnum(ecl_array_dimension(a, ecl_to_size(index)));
c/array.c:ecl_array_dimension(cl_object a, cl_index index)
c/array.c:cl_object
c/array.c:cl_array_total_size(cl_object a)
c/array.c:	cl_object __value0 = ecl_make_fixnum(a->array.dim);
c/array.c:cl_object
c/array.c:cl_adjustable_array_p(cl_object a)
c/array.c:	cl_object __value0 = (ECL_ADJUSTABLE_ARRAY_P(a) ? ECL_T : ECL_NIL);
c/array.c:cl_object
c/array.c:cl_array_displacement(cl_object a)
c/array.c:  cl_object to_array;
c/array.c:cl_object
c/array.c:cl_svref(cl_object x, cl_object index)
c/array.c:cl_object
c/array.c:si_svset(cl_object x, cl_object index, cl_object v)
c/array.c:cl_object
c/array.c:mp_compare_and_swap_svref(cl_object x, cl_object index, cl_object old, cl_object new)
c/array.c:cl_object
c/array.c:mp_atomic_incf_svref(cl_object x, cl_object index, cl_object increment)
c/array.c:cl_object
c/array.c:cl_array_has_fill_pointer_p(cl_object a)
c/array.c:  cl_object r;
c/array.c:cl_object
c/array.c:cl_fill_pointer(cl_object a)
c/array.c:cl_object
c/array.c:si_fill_pointer_set(cl_object a, cl_object fp)
c/array.c:    cl_object type = ecl_make_integer_type(ecl_make_fixnum(0),
c/array.c:cl_object
c/array.c:si_replace_array(cl_object olda, cl_object newa)
c/array.c:  cl_object dlist;
c/array.c:    cl_object other_array = CAR(dlist);
c/array.c:    cl_object offset;
c/array.c:ecl_copy_subarray(cl_object dest, cl_index i0, cl_object orig,
c/array.c:ecl_reverse_subarray(cl_object x, cl_index i0, cl_index i1)
c/array.c:      cl_object y = x->vector.self.t[i];
c/array.c:cl_object
c/array.c:si_copy_subarray(cl_object dest, cl_object start0,
c/array.c:                 cl_object orig, cl_object start1, cl_object length)
c/array.c:	cl_object __value0 = dest;
c/array.c:cl_object
c/array.c:si_fill_array_with_elt(cl_object x, cl_object elt, cl_object start, cl_object end)
c/array.c:    cl_object *p = x->vector.self.t + first;
c/array.c:	cl_object __value0 = x;
c/assignment.c:static void FEconstant_assignment(cl_object var) ecl_attr_noreturn;
c/assignment.c:FEconstant_assignment(cl_object var)
c/assignment.c:cl_object
c/assignment.c:cl_set(cl_object var, cl_object value)
c/assignment.c:cl_object
c/assignment.c:mp_compare_and_swap_symbol_value(cl_object var, cl_object old, cl_object new)
c/assignment.c:cl_object
c/assignment.c:mp_atomic_incf_symbol_value(cl_object var, cl_object increment)
c/assignment.c:cl_object
c/assignment.c:ecl_setq(cl_env_ptr env, cl_object var, cl_object value)
c/assignment.c:static cl_object
c/assignment.c:  cl_object name = the_env->function->cclosure.env;
c/assignment.c:static cl_object
c/assignment.c:make_setf_function_error(cl_object name)
c/assignment.c:  return ecl_make_cclosure_va((cl_objectfn)unbound_setf_function_error,
c/assignment.c:cl_object
c/assignment.c:ecl_setf_definition(cl_object sym, cl_object createp)
c/assignment.c:  cl_object pair;
c/assignment.c:cl_object
c/assignment.c:si_setf_definition(cl_object sym, cl_object value)
c/assignment.c:	cl_object __value0 = ecl_setf_definition(sym, value);
c/assignment.c:ecl_rem_setf_definition(cl_object sym)
c/assignment.c:    cl_object pair = ecl_gethash_safe(sym, cl_core.setf_definitions, ECL_NIL);
c/assignment.c:cl_object si_fset(cl_narg narg, cl_object fname, cl_object def, ...)
c/assignment.c:  cl_object sym = si_function_block_name(fname);
c/assignment.c:  cl_object pack;
c/assignment.c:	cl_object macro;
c/assignment.c:	cl_object pprint;
c/assignment.c:		macro = va_arg(ARGS,cl_object);
c/assignment.c:		pprint = va_arg(ARGS,cl_object);
c/assignment.c:    cl_object pair = ecl_setf_definition(sym, def);
c/assignment.c:	cl_object __value0 = def;
c/assignment.c:cl_object
c/assignment.c:cl_makunbound(cl_object sym)
c/assignment.c:	cl_object __value0 = sym;
c/assignment.c:cl_object
c/assignment.c:cl_fmakunbound(cl_object fname)
c/assignment.c:  cl_object sym = si_function_block_name(fname);
c/assignment.c:  cl_object pack = ecl_symbol_package(sym);
c/assignment.c:	cl_object __value0 = fname;
c/assignment.c:ecl_clear_compiler_properties(cl_object sym)
c/assignment.c:cl_object
c/assignment.c:si_get_sysprop(cl_object sym, cl_object prop)
c/assignment.c:    cl_object plist = ecl_gethash_safe(sym, cl_core.system_properties, ECL_NIL);
c/assignment.c:	cl_object __value0 = ECL_NIL;
c/assignment.c:	cl_object __value1 = ECL_NIL;
c/assignment.c:	cl_object __value0 = prop;
c/assignment.c:	cl_object __value1 = ECL_T;
c/assignment.c:cl_object
c/assignment.c:si_put_sysprop(cl_object sym, cl_object prop, cl_object value)
c/assignment.c:    cl_object plist = ecl_gethash_safe(sym, cl_core.system_properties, ECL_NIL);
c/assignment.c:	cl_object __value0 = value;
c/assignment.c:cl_object
c/assignment.c:si_rem_sysprop(cl_object sym, cl_object prop)
c/assignment.c:  cl_object plist, found;
c/atan.c:cl_object
c/atan.c:ecl_atan2(cl_object y, cl_object x)
c/atan.c:  cl_object output;
c/atan.c:cl_object
c/atan.c:ecl_atan1(cl_object y)
c/atan.c:    cl_object z = ecl_times(cl_core.imag_unit, y);
c/atan.c:    cl_object z1, z = ecl_times(cl_core.imag_unit, y);
c/atan.c:cl_object cl_atan(cl_narg narg, cl_object x, ...)
c/atan.c:	cl_object y;
c/atan.c:		y = va_arg(ARGS,cl_object);
c/atan.c:	cl_object __value0 = ecl_atan1(x);
c/atan.c:	cl_object __value0 = ecl_atan2(x, y);
c/atomic.c:cl_object
c/atomic.c:ecl_atomic_get(cl_object *slot)
c/atomic.c:  cl_object old;
c/atomic.c:    old = (cl_object)AO_load((AO_t*)slot);
c/atomic.c:ecl_atomic_push(cl_object *slot, cl_object c)
c/atomic.c:  cl_object cons = ecl_list1(c), car;
c/atomic.c:    car = (cl_object)AO_load((AO_t*)slot);
c/atomic.c:cl_object
c/atomic.c:ecl_atomic_pop(cl_object *slot)
c/atomic.c:  cl_object cons, rest;
c/atomic.c:    cons = (cl_object)AO_load((AO_t*)slot);
c/backq.c:extern int _cl_backq_car(cl_object *px);
c/backq.c:static cl_object backq(cl_object x);
c/backq.c:static cl_object
c/backq.c:kwote(cl_object x)
c/backq.c:_cl_backq_cdr(cl_object *px)
c/backq.c:  cl_object x = *px, ax, dx;
c/backq.c:_cl_backq_car(cl_object *px)
c/backq.c:  cl_object x = *px;
c/backq.c:static cl_object
c/backq.c:backq(cl_object x)
c/backq.c:static cl_object
c/backq.c:quasiquote_macro(cl_object whole, cl_object env)
c/backq.c:	cl_object __value0 = backq(CADR(whole));
c/backtrace.c:cl_object
c/backtrace.c:si_dump_c_backtrace(cl_object size)
c/barrier.c:FEerror_not_a_barrier(cl_object barrier)
c/barrier.c:cl_object
c/barrier.c:ecl_make_barrier(cl_object name, cl_index count)
c/barrier.c:  cl_object output = ecl_alloc_object(t_barrier);
c/barrier.c:cl_object mp_make_barrier(cl_narg narg, cl_object count, ...)
c/barrier.c:	static cl_object KEYS[1] = {(cl_object)(cl_symbols+1300)};
c/barrier.c:	cl_object name;
c/barrier.c:	cl_object KEY_VARS[2];
c/barrier.c:	cl_object __value0 = ecl_make_barrier(name, fixnnint(count));
c/barrier.c:cl_object
c/barrier.c:mp_barrier_name(cl_object barrier)
c/barrier.c:cl_object
c/barrier.c:mp_barrier_count(cl_object barrier)
c/barrier.c:cl_object
c/barrier.c:mp_barrier_arrivers_count(cl_object barrier)
c/barrier.c:cl_object mp_barrier_unblock(cl_narg narg, cl_object barrier, ...)
c/barrier.c:	static cl_object KEYS[3] = {(cl_object)(cl_symbols+1496), (cl_object)(cl_symbols+1495), (cl_object)(cl_symbols+1497)};
c/barrier.c:	cl_object reset_count;
c/barrier.c:	cl_object disable;
c/barrier.c:	cl_object kill_waiting;
c/barrier.c:	cl_object KEY_VARS[6];
c/barrier.c:static cl_object
c/barrier.c:barrier_wait_condition(cl_env_ptr env, cl_object barrier)
c/barrier.c:cl_object
c/barrier.c:mp_barrier_wait(cl_object barrier)
c/barrier.c:  cl_object output;
c/big.c:_ecl_big_register_free(cl_object x)
c/big.c:static cl_object
c/big.c:  cl_object new_big = ecl_alloc_compact_object(t_bignum, bytes);
c/big.c:static cl_object
c/big.c:_ecl_big_copy(cl_object old)
c/big.c:  cl_object new_big = _ecl_alloc_compact_bignum(dim);
c/big.c:cl_object
c/big.c:_ecl_big_register_copy(cl_object old)
c/big.c:  cl_object new_big = _ecl_big_copy(old);
c/big.c:static cl_object
c/big.c:big_normalize(cl_object x)
c/big.c:cl_object
c/big.c:_ecl_big_register_normalize(cl_object x)
c/big.c:cl_object
c/big.c:    cl_object y = big_normalize(z);
c/big.c:cl_object
c/big.c:_ecl_big_times_big(cl_object a, cl_object b)
c/big.c:  cl_object z = _ecl_alloc_compact_bignum(size);
c/big.c:cl_object
c/big.c:_ecl_big_times_fix(cl_object b, cl_fixnum i)
c/big.c:  cl_object z;
c/big.c:cl_object
c/big.c:_ecl_big_plus_fix(cl_object a, cl_fixnum b)
c/big.c:cl_object
c/big.c:_ecl_big_plus_big(cl_object a, cl_object b)
c/big.c:  cl_object z = _ecl_alloc_compact_bignum(size_z);
c/big.c:cl_object
c/big.c:_ecl_big_minus_big(cl_object a, cl_object b)
c/big.c:  cl_object z = _ecl_alloc_compact_bignum(size_z);
c/big.c:cl_object
c/big.c:_ecl_fix_minus_big(cl_fixnum a, cl_object b)
c/big.c:  cl_object z = _ecl_alloc_compact_bignum(size_z);
c/big.c:cl_object
c/big.c:_ecl_big_negate(cl_object a)
c/big.c:  cl_object z = _ecl_alloc_compact_bignum(size_a);
c/big.c:cl_object
c/big.c:_ecl_big_divided_by_big(cl_object a, cl_object b)
c/big.c:  cl_object z;
c/big.c:cl_object
c/big.c:_ecl_big_gcd(cl_object a, cl_object b)
c/big.c:  cl_object z = _ecl_big_register0();
c/big.c:cl_object
c/big.c:_ecl_big_divided_by_fix(cl_object x, cl_fixnum y)
c/big.c:cl_object
c/big.c:_ecl_big_ceiling(cl_object a, cl_object b, cl_object *pr)
c/big.c:  cl_object q = _ecl_big_register0();
c/big.c:  cl_object r = _ecl_big_register1();
c/big.c:cl_object
c/big.c:_ecl_big_floor(cl_object a, cl_object b, cl_object *pr)
c/big.c:  cl_object q = _ecl_big_register0();
c/big.c:  cl_object r = _ecl_big_register1();
c/big.c:cl_object
c/big.c:_ecl_fix_divided_by_big(cl_fixnum x, cl_object y)
c/big.c:cl_object
c/big.c:_ecl_big_set_fixnum(cl_object x, cl_fixnum f)
c/big.c:cl_object
c/big.c:_ecl_big_set_index(cl_object x, cl_index f)
c/big.c:_ecl_big_get_fixnum(cl_object x)
c/big.c:_ecl_big_get_index(cl_object x)
c/big.c:cl_object
c/big.c:_ecl_big_set_fixnum(cl_object x, cl_fixnum f)
c/big.c:cl_object
c/big.c:_ecl_big_set_index(cl_object x, cl_index f)
c/big.c:_ecl_big_get_fixnum(cl_object x)
c/big.c:_ecl_big_get_index(cl_object x)
c/big.c:_ecl_big_fits_in_fixnum(cl_object x)
c/big.c:_ecl_big_fits_in_index(cl_object x)
c/big.c:_ecl_big_fits_in_fixnum(cl_object x)
c/big.c:_ecl_big_fits_in_index(cl_object x)
c/big.c:_ecl_big_fits_in_fixnum(cl_object x)
c/big.c:_ecl_big_fits_in_index(cl_object x)
c/big.c:fixint(cl_object x)
c/big.c:fixnnint(cl_object x)
c/big.c:_ecl_big_to_long_double(cl_object o)
c/big.c:mpz_ior_op(cl_object out, cl_object i, cl_object j)
c/big.c:mpz_xor_op(cl_object out, cl_object i, cl_object j)
c/big.c:mpz_and_op(cl_object out, cl_object i, cl_object j)
c/big.c:mpz_eqv_op(cl_object out, cl_object i, cl_object j)
c/big.c:mpz_nand_op(cl_object out, cl_object i, cl_object j)
c/big.c:mpz_nor_op(cl_object out, cl_object i, cl_object j)
c/big.c:mpz_andc1_op(cl_object out, cl_object i, cl_object j)
c/big.c:mpz_orc1_op(cl_object out, cl_object i, cl_object j)
c/big.c:mpz_andc2_op(cl_object out, cl_object i, cl_object j)
c/big.c:mpz_orc2_op(cl_object out, cl_object i, cl_object j)
c/big.c:mpz_b_clr_op(cl_object out, cl_object i, cl_object j)
c/big.c:mpz_b_set_op(cl_object o, cl_object i, cl_object j)
c/big.c:mpz_b_1_op(cl_object out, cl_object i, cl_object j)
c/big.c:mpz_b_2_op(cl_object out, cl_object i, cl_object j)
c/big.c:mpz_b_c1_op(cl_object out, cl_object i, cl_object j)
c/big.c:mpz_b_c2_op(cl_object out, cl_object i, cl_object j)
c/cache.c:  cl_object table = cache->table;
c/cache.c:clear_one_from_cache(ecl_cache_ptr cache, cl_object target)
c/cache.c:  cl_object table = cache->table;
c/cache.c:    cl_object key = table->vector.self.t[i];
c/cache.c:  cl_object list = ecl_atomic_get(&cache->clear_list);
c/cache.c:  cl_object table = cache->table;
c/cache.c:    cl_object key = table->vector.self.t[i];
c/cache.c:ecl_cache_remove_one(ecl_cache_ptr cache, cl_object first_key)
c/cache.c:vector_hash_key(cl_object keys)
c/cache.c:    cl_object table = cache->table;
c/cache.c:    cl_object keys = cache->keys;
c/cache.c:    cl_object *min_e;
c/cache.c:      cl_object *e = table->vector.self.t + i;
c/cache.c:      cl_object hkey = RECORD_KEY(e);
c/cache.c:      cl_object *e = table->vector.self.t;
c/cdata.c:cl_object
c/cdata.c:si_get_cdata(cl_object filename)
c/cdata.c:  cl_object map, array, displaced;
c/cdata.c:	cl_object __value0 = map;
c/cdata.c:	cl_object __value1 = displaced;
c/cdata.c:cl_object
c/cdata.c:si_add_cdata(cl_object filename, cl_object data)
c/cdata.c:  cl_object stream, offset;
c/ceiling.c:cl_object cl_ceiling(cl_narg narg, cl_object x, ...)
c/ceiling.c:	cl_object y;
c/ceiling.c:		y = va_arg(ARGS,cl_object);
c/ceiling.c:cl_object
c/ceiling.c:ecl_ceiling1(cl_object x)
c/ceiling.c:  cl_object v0, v1;
c/ceiling.c:	cl_object __value0 = v0;
c/ceiling.c:	cl_object __value1 = v1;
c/ceiling.c:cl_object
c/ceiling.c:ecl_ceiling2(cl_object x, cl_object y)
c/ceiling.c:  cl_object v0, v1;
c/cfun.c:cl_object
c/cfun.c:ecl_make_cfun(cl_objectfn_fixed c_function, cl_object name, cl_object cblock, int narg)
c/cfun.c:  cl_object cf;
c/cfun.c:cl_object
c/cfun.c:ecl_make_cfun_va(cl_objectfn c_function, cl_object name, cl_object cblock, int narg_fixed)
c/cfun.c:  cl_object cf;
c/cfun.c:cl_object
c/cfun.c:ecl_make_cclosure_va(cl_objectfn c_function, cl_object env, cl_object block, int narg_fixed)
c/cfun.c:  cl_object cc;
c/cfun.c:ecl_def_c_function(cl_object sym, cl_objectfn_fixed c_function, int narg)
c/cfun.c:ecl_def_c_macro(cl_object sym, cl_objectfn_fixed c_function, int narg)
c/cfun.c:ecl_def_c_macro_va(cl_object sym, cl_objectfn c_function, int narg_fixed)
c/cfun.c:ecl_def_c_function_va(cl_object sym, cl_objectfn c_function, int narg_fixed)
c/cfun.c:cl_object
c/cfun.c:si_compiled_function_name(cl_object fun)
c/cfun.c:  cl_object output;
c/cfun.c:cl_object
c/cfun.c:cl_function_lambda_expression(cl_object fun)
c/cfun.c:  cl_object output, name = ECL_NIL, lex = ECL_NIL;
c/cfun.c:cl_object
c/cfun.c:si_compiled_function_block(cl_object fun)
c/cfun.c:  cl_object output;
c/cfun.c:	cl_object __value0 = output;
c/cfun.c:cl_object
c/cfun.c:si_compiled_function_file(cl_object b)
c/cfun.c:ecl_set_function_source_file_info(cl_object b, cl_object source, cl_object position)
c/cfun.c:ecl_cmp_defmacro(cl_object fun)
c/cfun.c:ecl_cmp_defun(cl_object fun)
c/character.c:ecl_char_code(cl_object c)
c/character.c:ecl_base_char_code(cl_object c)
c/character.c:cl_object
c/character.c:cl_standard_char_p(cl_object c)
c/character.c:	cl_object __value0 = (ecl_standard_char_p(i)? ECL_T : ECL_NIL);
c/character.c:cl_object
c/character.c:cl_graphic_char_p(cl_object c)
c/character.c:	cl_object __value0 = (ecl_graphic_char_p(ecl_char_code(c))? ECL_T : ECL_NIL);
c/character.c:cl_object
c/character.c:cl_alpha_char_p(cl_object c)
c/character.c:	cl_object __value0 = (ecl_alpha_char_p(ecl_char_code(c))? ECL_T : ECL_NIL);
c/character.c:cl_object
c/character.c:cl_upper_case_p(cl_object c)
c/character.c:	cl_object __value0 = (ecl_upper_case_p(ecl_char_code(c))? ECL_T : ECL_NIL);
c/character.c:cl_object
c/character.c:cl_lower_case_p(cl_object c)
c/character.c:	cl_object __value0 = (ecl_lower_case_p(ecl_char_code(c))? ECL_T : ECL_NIL);
c/character.c:cl_object
c/character.c:cl_both_case_p(cl_object c)
c/character.c:	cl_object __value0 = (ecl_both_case_p(ecl_char_code(c))? ECL_T : ECL_NIL);
c/character.c:ecl_string_case(cl_object s)
c/character.c:cl_object cl_digit_char_p(cl_narg narg, cl_object c, ...)
c/character.c:	cl_object radix;
c/character.c:		radix = va_arg(ARGS,cl_object);
c/character.c:	cl_object __value0 = ((value < 0)? ECL_NIL: ecl_make_fixnum(value));
c/character.c:cl_object
c/character.c:cl_alphanumericp(cl_object c)
c/character.c:	cl_object __value0 = (ecl_alphanumericp(i)? ECL_T : ECL_NIL);
c/character.c:cl_object cl_charE(cl_narg narg, cl_object c, ...)
c/character.c:	cl_object __value0 = ECL_NIL;
c/character.c:	cl_object __value0 = ECL_T;
c/character.c:ecl_char_eq(cl_object x, cl_object y)
c/character.c:cl_object cl_charNE(cl_narg narg, ...)
c/character.c:  cl_object c;
c/character.c:	cl_object __value0 = ECL_NIL;
c/character.c:	cl_object __value0 = ECL_T;
c/character.c:static cl_object
c/character.c:  cl_object c, d;
c/character.c:ecl_char_cmp(cl_object x, cl_object y)
c/character.c:cl_object cl_charL(cl_narg narg, ...)
c/character.c:	cl_object __value0 = Lchar_cmp(the_env, narg, 1, 1, args);
c/character.c:cl_object cl_charG(cl_narg narg, ...)
c/character.c:	cl_object __value0 = Lchar_cmp(the_env, narg,-1, 1, args);
c/character.c:cl_object cl_charLE(cl_narg narg, ...)
c/character.c:	cl_object __value0 = Lchar_cmp(the_env, narg, 1, 0, args);
c/character.c:cl_object cl_charGE(cl_narg narg, ...)
c/character.c:	cl_object __value0 = Lchar_cmp(the_env, narg,-1, 0, args);
c/character.c:cl_object cl_char_equal(cl_narg narg, cl_object c, ...)
c/character.c:	cl_object __value0 = ECL_NIL;
c/character.c:	cl_object __value0 = ECL_T;
c/character.c:ecl_char_equal(cl_object x, cl_object y)
c/character.c:cl_object cl_char_not_equal(cl_narg narg, ...)
c/character.c:  cl_object c;
c/character.c:	cl_object __value0 = ECL_NIL;
c/character.c:	cl_object __value0 = ECL_T;
c/character.c:static cl_object
c/character.c:  cl_object c, d;
c/character.c:ecl_char_compare(cl_object x, cl_object y)
c/character.c:cl_object cl_char_lessp(cl_narg narg, ...)
c/character.c:	cl_object __value0 = Lchar_compare(the_env, narg, 1, 1, args);
c/character.c:cl_object cl_char_greaterp(cl_narg narg, ...)
c/character.c:	cl_object __value0 = Lchar_compare(the_env, narg,-1, 1, args);
c/character.c:cl_object cl_char_not_greaterp(cl_narg narg, ...)
c/character.c:	cl_object __value0 = Lchar_compare(the_env, narg, 1, 0, args);
c/character.c:cl_object cl_char_not_lessp(cl_narg narg, ...)
c/character.c:	cl_object __value0 = Lchar_compare(the_env, narg,-1, 0, args);
c/character.c:cl_object
c/character.c:cl_character(cl_object x)
c/character.c:	cl_object __value0 = x;
c/character.c:cl_object
c/character.c:cl_char_code(cl_object c)
c/character.c:	cl_object __value0 = ecl_make_fixnum(ecl_char_code(c));
c/character.c:cl_object
c/character.c:cl_code_char(cl_object c)
c/character.c:	cl_object __value0 = c;
c/character.c:cl_object
c/character.c:cl_char_upcase(cl_object c)
c/character.c:	cl_object __value0 = ECL_CODE_CHAR(ecl_char_upcase(code));
c/character.c:cl_object
c/character.c:cl_char_downcase(cl_object c)
c/character.c:	cl_object __value0 = ECL_CODE_CHAR(ecl_char_downcase(code));
c/character.c:cl_object cl_digit_char(cl_narg narg, cl_object weight, ...)
c/character.c:	cl_object radix;
c/character.c:		radix = va_arg(ARGS,cl_object);
c/character.c:    cl_object output = ECL_NIL;
c/character.c:	cl_object __value0 = output;
c/character.c:cl_object
c/character.c:cl_char_int(cl_object c)
c/character.c:cl_object
c/character.c:cl_char_name(cl_object c)
c/character.c:  cl_object output;
c/character.c:	cl_object __value0 = output;
c/character.c:cl_object
c/character.c:cl_name_char(cl_object name)
c/character.c:  cl_object c;
c/cmpaux.c:cl_object
c/cmpaux.c:si_specialp(cl_object sym)
c/cmpaux.c:	cl_object __value0 = ((ecl_symbol_type(sym) & ecl_stp_special)? ECL_T : ECL_NIL);
c/cmpaux.c:ecl_to_char(cl_object x)
c/cmpaux.c:ecl_to_fixnum(cl_object x)
c/cmpaux.c:ecl_to_unsigned_integer(cl_object x)
c/cmpaux.c:ecl_aref_bv(cl_object x, cl_index index)
c/cmpaux.c:ecl_aset_bv(cl_object x, cl_index index, int value)
c/cmpaux.c:cl_throw(cl_object tag)
c/cmpaux.c:cl_return_from(cl_object block_id, cl_object block_name)
c/cmpaux.c:cl_go(cl_object tag_id, cl_object label)
c/cmpaux.c:cl_object
c/cmpaux.c:  cl_object rest = ECL_NIL;
c/cmpaux.c:  cl_object *r = &rest;
c/cmpaux.c:             cl_object *keys,           /* keywords for the function */
c/cmpaux.c:             cl_object *vars,           /* where to put values (vars[0..nkey-1])
c/cmpaux.c:             cl_object *rest,           /* if rest != NULL, where to collect rest values */
c/cmpaux.c:  cl_object supplied_allow_other_keys = OBJNULL;
c/cmpaux.c:  cl_object unknown_keyword = OBJNULL;
c/cmpaux.c:    cl_object keyword = ecl_va_arg(args);
c/cmpaux.c:    cl_object value = ecl_va_arg(args);
c/compiler.c:static cl_object asm_end(cl_env_ptr env, cl_index handle, cl_object definition);
c/compiler.c:static cl_fixnum c_var_ref(cl_env_ptr env, cl_object var, int allow_symbol_macro, bool ensure_defined);
c/compiler.c:static int c_block(cl_env_ptr env, cl_object args, int flags);
c/compiler.c:static int c_case(cl_env_ptr env, cl_object args, int flags);
c/compiler.c:static int c_catch(cl_env_ptr env, cl_object args, int flags);
c/compiler.c:static int c_compiler_let(cl_env_ptr env, cl_object args, int flags);
c/compiler.c:static int c_cond(cl_env_ptr env, cl_object args, int flags);
c/compiler.c:static int c_eval_when(cl_env_ptr env, cl_object args, int flags);
c/compiler.c:static int c_flet(cl_env_ptr env, cl_object args, int flags);
c/compiler.c:static int c_funcall(cl_env_ptr env, cl_object args, int flags);
c/compiler.c:static int c_function(cl_env_ptr env, cl_object args, int flags);
c/compiler.c:static int c_go(cl_env_ptr env, cl_object args, int flags);
c/compiler.c:static int c_if(cl_env_ptr env, cl_object args, int flags);
c/compiler.c:static int c_labels(cl_env_ptr env, cl_object args, int flags);
c/compiler.c:static int c_let(cl_env_ptr env, cl_object args, int flags);
c/compiler.c:static int c_leta(cl_env_ptr env, cl_object args, int flags);
c/compiler.c:static int c_load_time_value(cl_env_ptr env, cl_object args, int flags);
c/compiler.c:static int c_locally(cl_env_ptr env, cl_object args, int flags);
c/compiler.c:static int c_macrolet(cl_env_ptr env, cl_object args, int flags);
c/compiler.c:static int c_multiple_value_bind(cl_env_ptr env, cl_object args, int flags);
c/compiler.c:static int c_multiple_value_call(cl_env_ptr env, cl_object args, int flags);
c/compiler.c:static int c_multiple_value_prog1(cl_env_ptr env, cl_object args, int flags);
c/compiler.c:static int c_multiple_value_setq(cl_env_ptr env, cl_object args, int flags);
c/compiler.c:static int c_not(cl_env_ptr env, cl_object args, int flags);
c/compiler.c:static int c_nth_value(cl_env_ptr env, cl_object args, int flags);
c/compiler.c:static int c_prog1(cl_env_ptr env, cl_object args, int flags);
c/compiler.c:static int c_progv(cl_env_ptr env, cl_object args, int flags);
c/compiler.c:static int c_psetq(cl_env_ptr env, cl_object args, int flags);
c/compiler.c:static int c_quote(cl_env_ptr env, cl_object args, int flags);
c/compiler.c:static int c_values(cl_env_ptr env, cl_object args, int flags);
c/compiler.c:static int c_setq(cl_env_ptr env, cl_object args, int flags);
c/compiler.c:static int c_return(cl_env_ptr env, cl_object args, int flags);
c/compiler.c:static int c_return_from(cl_env_ptr env, cl_object args, int flags);
c/compiler.c:static int c_symbol_macrolet(cl_env_ptr env, cl_object args, int flags);
c/compiler.c:static int c_tagbody(cl_env_ptr env, cl_object args, int flags);
c/compiler.c:static int c_the(cl_env_ptr env, cl_object args, int flags);
c/compiler.c:static int c_throw(cl_env_ptr env, cl_object args, int flags);
c/compiler.c:static int c_unwind_protect(cl_env_ptr env, cl_object args, int flags);
c/compiler.c:static int c_while(cl_env_ptr env, cl_object args, int flags);
c/compiler.c:static int c_with_backend(cl_env_ptr env, cl_object args, int flags);
c/compiler.c:static int c_until(cl_env_ptr env, cl_object args, int flags);
c/compiler.c:static void eval_form(cl_env_ptr env, cl_object form);
c/compiler.c:static int execute_each_form(cl_env_ptr env, cl_object body);
c/compiler.c:static int compile_toplevel_body(cl_env_ptr env, cl_object args, int flags);
c/compiler.c:static int compile_body(cl_env_ptr env, cl_object args, int flags);
c/compiler.c:static int compile_form(cl_env_ptr env, cl_object args, int push);
c/compiler.c:static int compile_with_load_time_forms(cl_env_ptr env, cl_object form, int flags);
c/compiler.c:static int compile_constant(cl_env_ptr env, cl_object stmt, int flags);
c/compiler.c:static int c_cons(cl_env_ptr env, cl_object args, int push);
c/compiler.c:static int c_endp(cl_env_ptr env, cl_object args, int push);
c/compiler.c:static int c_car(cl_env_ptr env, cl_object args, int push);
c/compiler.c:static int c_cdr(cl_env_ptr env, cl_object args, int push);
c/compiler.c:static int c_list(cl_env_ptr env, cl_object args, int push);
c/compiler.c:static int c_listA(cl_env_ptr env, cl_object args, int push);
c/compiler.c:static cl_object ecl_make_lambda(cl_env_ptr env, cl_object name, cl_object lambda);
c/compiler.c:static cl_object
c/compiler.c:pop(cl_object *l) {
c/compiler.c:  cl_object head, list = *l;
c/compiler.c:static cl_object
c/compiler.c:pop_maybe_nil(cl_object *l) {
c/compiler.c:  cl_object head, list = *l;
c/compiler.c:static cl_object
c/compiler.c:push(cl_object v, cl_object *l) {
c/compiler.c:  cl_object list = *l;
c/compiler.c:static cl_object
c/compiler.c:asm_end(cl_env_ptr env, cl_index beginning, cl_object definition) {
c/compiler.c:  cl_object bytecodes;
c/compiler.c:  cl_object file = ECL_SYM_VAL(env,ECL_SYM("EXT::*SOURCE-LOCATION*",1202)), position;
c/compiler.c:  cl_object v = (cl_object)code;
c/compiler.c:asm_constant(cl_env_ptr env, cl_object c)
c/compiler.c:  cl_object constants = c_env->constants;
c/compiler.c:    env->stack[pc] = (cl_object)(cl_fixnum)delta;
c/compiler.c:  int (*compiler)(cl_env_ptr, cl_object, int);
c/compiler.c:assert_type_symbol(cl_object v)
c/compiler.c:c_search_constant(cl_env_ptr env, cl_object c)
c/compiler.c:  cl_object p = c_env->constants;
c/compiler.c:c_register_constant(cl_env_ptr env, cl_object c)
c/compiler.c:asm_c(cl_env_ptr env, cl_object o) {
c/compiler.c:asm_op2c(cl_env_ptr env, int code, cl_object o) {
c/compiler.c:static cl_object
c/compiler.c:c_register_block(cl_env_ptr env, cl_object name)
c/compiler.c:  cl_object loc = new_location(c_env);
c/compiler.c:c_register_tags(cl_env_ptr env, cl_object all_tags)
c/compiler.c:  cl_object loc = new_location(c_env);
c/compiler.c:c_register_function(cl_env_ptr env, cl_object name)
c/compiler.c:static cl_object
c/compiler.c:c_macro_expand1(cl_env_ptr env, cl_object stmt)
c/compiler.c:c_register_symbol_macro(cl_env_ptr env, cl_object name, cl_object exp_fun)
c/compiler.c:c_register_macro(cl_env_ptr env, cl_object name, cl_object exp_fun)
c/compiler.c:c_register_var(cl_env_ptr env, cl_object var, bool special, bool bound)
c/compiler.c:c_register_boundary(cl_env_ptr env, cl_object type)
c/compiler.c:guess_compiler_environment(cl_env_ptr env, cl_object interpreter_env)
c/compiler.c:      cl_object record = ECL_CONS_CAR(interpreter_env);
c/compiler.c:        cl_object record0 = ECL_CONS_CAR(record);
c/compiler.c:        cl_object record1 = ECL_CONS_CDR(record);
c/compiler.c:c_new_env(cl_env_ptr the_env, cl_compiler_env_ptr new, cl_object env,
c/compiler.c:      cl_object record = CAR(env);
c/compiler.c:static cl_object
c/compiler.c:c_tag_ref(cl_env_ptr env, cl_object the_tag, cl_object the_type)
c/compiler.c:  cl_object l;
c/compiler.c:    cl_object type, name, record = ECL_CONS_CAR(l);
c/compiler.c:        cl_object label = ecl_assql(the_tag, name);
c/compiler.c:c_var_ref(cl_env_ptr env, cl_object var, int allow_symbol_macro, bool ensure_defined)
c/compiler.c:  cl_object l, record, special, name;
c/compiler.c:c_declared_special(register cl_object var, register cl_object specials)
c/compiler.c:c_declare_specials(cl_env_ptr env, cl_object specials)
c/compiler.c:    cl_object var = pop(&specials);
c/compiler.c:static cl_object
c/compiler.c:c_process_declarations(cl_object body)
c/compiler.c:c_pbind(cl_env_ptr env, cl_object var, cl_object specials)
c/compiler.c:c_bind(cl_env_ptr env, cl_object var, cl_object specials)
c/compiler.c:c_undo_bindings(cl_env_ptr the_env, cl_object old_vars, int only_specials)
c/compiler.c:  cl_object env;
c/compiler.c:      cl_object record, name, special;
c/compiler.c:compile_setq(cl_env_ptr env, int op, cl_object var)
c/compiler.c:c_block(cl_env_ptr env, cl_object body, int old_flags) {
c/compiler.c:  cl_object name = pop(&body);
c/compiler.c:  cl_object block_record;
c/compiler.c:c_arguments(cl_env_ptr env, cl_object args) {
c/compiler.c:static int asm_function(cl_env_ptr env, cl_object args, int flags);
c/compiler.c:c_call(cl_env_ptr env, cl_object args, int flags) {
c/compiler.c:  cl_object name;
c/compiler.c:  if (name >= (cl_object)cl_symbols
c/compiler.c:      && name < (cl_object)(cl_symbols + cl_num_symbols_in_core))
c/compiler.c:      cl_object f = ECL_SYM_FUN(name);
c/compiler.c:c_funcall(cl_env_ptr env, cl_object args, int flags) {
c/compiler.c:  cl_object name;
c/compiler.c:    cl_object kind = ECL_CONS_CAR(name);
c/compiler.c:perform_c_case(cl_env_ptr env, cl_object args, int flags) {
c/compiler.c:  cl_object test, clause;
c/compiler.c:        cl_object v = pop(&test);
c/compiler.c:c_case(cl_env_ptr env, cl_object clause, int flags) {
c/compiler.c:c_catch(cl_env_ptr env, cl_object args, int flags) {
c/compiler.c:  cl_object old_env;
c/compiler.c:c_compiler_let(cl_env_ptr env, cl_object args, int flags) {
c/compiler.c:  cl_object bindings;
c/compiler.c:    cl_object form = pop(&bindings);
c/compiler.c:    cl_object var = pop(&form);
c/compiler.c:    cl_object value = pop_maybe_nil(&form);
c/compiler.c:c_cond(cl_env_ptr env, cl_object args, int flags) {
c/compiler.c:  cl_object test, clause;
c/compiler.c:c_while_until(cl_env_ptr env, cl_object body, int flags, bool is_while) {
c/compiler.c:  cl_object test = pop(&body);
c/compiler.c:c_while(cl_env_ptr env, cl_object body, int flags) {
c/compiler.c:c_until(cl_env_ptr env, cl_object body, int flags) {
c/compiler.c:c_with_backend(cl_env_ptr env, cl_object args, int flags)
c/compiler.c:  cl_object forms = ECL_NIL;
c/compiler.c:    cl_object tag = pop(&args);
c/compiler.c:    cl_object form = pop(&args);
c/compiler.c:eval_when_flags(cl_object situation)
c/compiler.c:  cl_object p;
c/compiler.c:    cl_object keyword;
c/compiler.c:c_eval_when(cl_env_ptr env, cl_object args, int flags) {
c/compiler.c:  cl_object situation_list = pop(&args);
c/compiler.c:c_register_functions(cl_env_ptr env, cl_object l)
c/compiler.c:    cl_object definition = pop(&l);
c/compiler.c:    cl_object name = pop(&definition);
c/compiler.c:c_labels_flet(cl_env_ptr env, int op, cl_object args, int flags) {
c/compiler.c:#define push_back(v,l) { cl_object c = *l = CONS(v, *l); l = &ECL_CONS_CDR(c); }
c/compiler.c:  cl_object l, def_list = pop(&args);
c/compiler.c:  cl_object old_vars = env->c_env->variables;
c/compiler.c:  cl_object old_funs = env->c_env->macros;
c/compiler.c:  cl_object fnames = ECL_NIL;
c/compiler.c:  cl_object v, *f = &fnames;
c/compiler.c:    cl_object definition = pop(&l);
c/compiler.c:    cl_object name = pop(&definition);
c/compiler.c:    cl_object lambda = ecl_make_lambda(env, name, definition);
c/compiler.c:c_flet(cl_env_ptr env, cl_object args, int flags) {
c/compiler.c:c_function(cl_env_ptr env, cl_object args, int flags) {
c/compiler.c:  cl_object function = pop(&args);
c/compiler.c:static cl_object
c/compiler.c:  cl_object lexenv = ECL_NIL;
c/compiler.c:  cl_object records;
c/compiler.c:    cl_object record = ECL_CONS_CAR(records);
c/compiler.c:    cl_object record = ECL_CONS_CAR(records);
c/compiler.c:asm_function(cl_env_ptr env, cl_object function, int flags) {
c/compiler.c:    cl_object ndx = c_tag_ref(env, function, ECL_SYM(":FUNCTION",1264));
c/compiler.c:    cl_object kind = ECL_CONS_CAR(function);
c/compiler.c:    cl_object body = ECL_CONS_CDR(function);
c/compiler.c:    cl_object name;
c/compiler.c:    cl_object lambda = ecl_make_lambda(env, name, body);
c/compiler.c:    cl_object macro_lexenv = create_macro_lexenv(c_env);
c/compiler.c:c_go(cl_env_ptr env, cl_object args, int flags) {
c/compiler.c:  cl_object tag = pop(&args);
c/compiler.c:  cl_object info = c_tag_ref(env, tag, ECL_SYM(":TAG",1342));
c/compiler.c:c_if(cl_env_ptr env, cl_object form, int flags) {
c/compiler.c:  cl_object test = pop(&form);
c/compiler.c:  cl_object then = pop(&form);
c/compiler.c:c_labels(cl_env_ptr env, cl_object args, int flags) {
c/compiler.c:c_let_leta(cl_env_ptr env, int op, cl_object args, int flags) {
c/compiler.c:  cl_object bindings, specials, body, l, vars;
c/compiler.c:  cl_object old_variables = env->c_env->variables;
c/compiler.c:    cl_object aux = pop(&l);
c/compiler.c:    cl_object var, value;
c/compiler.c:c_let(cl_env_ptr env, cl_object args, int flags) {
c/compiler.c:c_leta(cl_env_ptr env, cl_object args, int flags) {
c/compiler.c:c_load_time_value(cl_env_ptr env, cl_object args, int flags)
c/compiler.c:  cl_object value;
c/compiler.c:c_locally(cl_env_ptr env, cl_object args, int flags) {
c/compiler.c:  cl_object old_env = env->c_env->variables;
c/compiler.c:c_macrolet(cl_env_ptr the_env, cl_object args, int flags)
c/compiler.c:  cl_object old_env = c_env->macros;
c/compiler.c:  cl_object env = funcall(3, ECL_SYM("SI::CMP-ENV-REGISTER-MACROLET",1663), pop(&args),
c/compiler.c:c_vbind(cl_env_ptr env, cl_object var, int n, cl_object specials)
c/compiler.c:c_multiple_value_bind(cl_env_ptr env, cl_object args, int flags)
c/compiler.c:  cl_object vars = pop(&args);
c/compiler.c:    cl_object value = pop(&args);
c/compiler.c:    cl_object old_variables = env->c_env->variables;
c/compiler.c:    cl_object body = c_process_declarations(args);
c/compiler.c:    cl_object specials = env->values[3];
c/compiler.c:      cl_object var = pop(&vars);
c/compiler.c:c_multiple_value_call(cl_env_ptr env, cl_object args, int flags) {
c/compiler.c:  cl_object name;
c/compiler.c:c_multiple_value_prog1(cl_env_ptr env, cl_object args, int flags) {
c/compiler.c:c_multiple_value_setq(cl_env_ptr env, cl_object orig_args, int flags) {
c/compiler.c:  cl_object args = orig_args;
c/compiler.c:  cl_object orig_vars;
c/compiler.c:  cl_object vars = ECL_NIL, values;
c/compiler.c:  cl_object old_variables = env->c_env->variables;
c/compiler.c:    cl_object v = pop(&orig_vars);
c/compiler.c:c_not(cl_env_ptr env, cl_object args, int flags) {
c/compiler.c:c_nth_value(cl_env_ptr env, cl_object args, int flags) {
c/compiler.c:c_prog1(cl_env_ptr env, cl_object args, int flags) {
c/compiler.c:  cl_object form = pop(&args);
c/compiler.c:c_progv(cl_env_ptr env, cl_object args, int flags) {
c/compiler.c:  cl_object vars = pop(&args);
c/compiler.c:  cl_object values = pop(&args);
c/compiler.c:c_psetq(cl_env_ptr env, cl_object old_args, int flags) {
c/compiler.c:  cl_object args = ECL_NIL, vars = ECL_NIL;
c/compiler.c:    cl_object var = pop(&old_args);
c/compiler.c:    cl_object value = pop(&old_args);
c/compiler.c:    cl_object var = pop(&args);
c/compiler.c:    cl_object value = pop(&args);
c/compiler.c:c_return_aux(cl_env_ptr env, cl_object name, cl_object stmt, int flags)
c/compiler.c:  cl_object ndx = c_tag_ref(env, name, ECL_SYM(":BLOCK",1224));
c/compiler.c:  cl_object output = pop_maybe_nil(&stmt);
c/compiler.c:c_return(cl_env_ptr env, cl_object stmt, int flags) {
c/compiler.c:c_return_from(cl_env_ptr env, cl_object stmt, int flags) {
c/compiler.c:  cl_object name = pop(&stmt);
c/compiler.c:c_setq(cl_env_ptr env, cl_object args, int flags) {
c/compiler.c:    cl_object var = pop(&args);
c/compiler.c:    cl_object value = pop(&args);
c/compiler.c:c_symbol_macrolet(cl_env_ptr env, cl_object args, int flags)
c/compiler.c:  cl_object def_list, specials, body;
c/compiler.c:  cl_object old_variables = env->c_env->variables;
c/compiler.c:    cl_object definition = pop(&def_list);
c/compiler.c:    cl_object name = pop(&definition);
c/compiler.c:    cl_object expansion = pop(&definition);
c/compiler.c:    cl_object arglist = cl_list(2, cl_gensym(0), cl_gensym(0));
c/compiler.c:    cl_object function;
c/compiler.c:c_tagbody(cl_env_ptr env, cl_object args, int flags)
c/compiler.c:  cl_object old_env = env->c_env->variables;
c/compiler.c:  cl_object labels = ECL_NIL, label, body;
c/compiler.c:c_the(cl_env_ptr env, cl_object stmt, int flags) {
c/compiler.c:  cl_object value;
c/compiler.c:c_throw(cl_env_ptr env, cl_object stmt, int flags) {
c/compiler.c:  cl_object tag = pop(&stmt);
c/compiler.c:  cl_object form = pop(&stmt);
c/compiler.c:c_unwind_protect(cl_env_ptr env, cl_object args, int flags) {
c/compiler.c:c_values(cl_env_ptr env, cl_object args, int flags) {
c/compiler.c:defer_load_object(cl_env_ptr env, cl_object place, cl_object created)
c/compiler.c:maybe_make_load_forms(cl_env_ptr env, cl_object constant)
c/compiler.c:  cl_object init, make, created;
c/compiler.c:    cl_object place = ECL_CONS_CAR(created);
c/compiler.c:compile_constant(cl_env_ptr env, cl_object stmt, int flags)
c/compiler.c:c_quote(cl_env_ptr env, cl_object args, int flags)
c/compiler.c:compile_symbol(cl_env_ptr env, cl_object stmt, int flags)
c/compiler.c:  cl_object stmt1 = c_macro_expand1(env, stmt);
c/compiler.c:compile_form(cl_env_ptr env, cl_object stmt, int flags) {
c/compiler.c:  cl_object function;
c/compiler.c:    cl_object index = ecl_gethash(function, cl_core.compiler_dispatch);
c/compiler.c:    cl_object new_stmt = c_macro_expand1(env, stmt);
c/compiler.c:eval_nontrivial_form(cl_env_ptr env, cl_object form) {
c/compiler.c:  cl_object bytecodes;
c/compiler.c:    env->values[0] = ecl_interpret((cl_object)&frame,
c/compiler.c:eval_form(cl_env_ptr env, cl_object form) {
c/compiler.c:execute_each_form(cl_env_ptr env, cl_object body)
c/compiler.c:  cl_object form = ECL_NIL, next_form;
c/compiler.c:static cl_object
c/compiler.c:  cl_object bytecodes = ecl_alloc_simple_vector(l, ecl_aet_index);
c/compiler.c:restore_bytecodes(cl_env_ptr env, cl_object bytecodes)
c/compiler.c:    ECL_STACK_PUSH(env, (cl_object)p[l-1]);
c/compiler.c:add_load_form(cl_env_ptr env, cl_object object)
c/compiler.c:  cl_object constant = pop(&object);
c/compiler.c:  cl_object make_form = pop(&object);
c/compiler.c:  cl_object init_form = pop(&object);
c/compiler.c:  cl_object deferred_init_forms;
c/compiler.c:    cl_object previous_locs = c_env->ltf_locations;
c/compiler.c:    cl_object old_init_until = c_env->ltf_defer_init_until;
c/compiler.c:      cl_object bytecodes_init = save_bytecodes(env, handle_init, current_pc(env));
c/compiler.c:      cl_object l = si_memq(c_env->ltf_defer_init_until, c_env->ltf_being_created);
c/compiler.c:        cl_object constant_and_inits = ECL_CONS_CAR(l);
c/compiler.c:compile_with_load_time_forms(cl_env_ptr env, cl_object form, int flags)
c/compiler.c:    cl_object bytecodes = save_bytecodes(env, handle, current_pc(env));
c/compiler.c:    cl_object p = cl_nreverse(c_env->load_time_forms);
c/compiler.c:compile_each_form(cl_env_ptr env, cl_object body, int flags)
c/compiler.c:  cl_object form = ECL_NIL, next_form;
c/compiler.c:compile_toplevel_body(cl_env_ptr env, cl_object body, int flags)
c/compiler.c:compile_body(cl_env_ptr env, cl_object body, int flags)
c/compiler.c:  cl_object form = ECL_NIL, next_form;
c/compiler.c:c_cons(cl_env_ptr env, cl_object args, int flags)
c/compiler.c:c_endp(cl_env_ptr env, cl_object args, int flags)
c/compiler.c:  cl_object list = pop(&args);
c/compiler.c:c_car(cl_env_ptr env, cl_object args, int flags)
c/compiler.c:  cl_object list = pop(&args);
c/compiler.c:c_cdr(cl_env_ptr env, cl_object args, int flags)
c/compiler.c:  cl_object list = pop(&args);
c/compiler.c:c_list_listA(cl_env_ptr env, cl_object args, int flags, int op)
c/compiler.c:c_list(cl_env_ptr env, cl_object args, int flags)
c/compiler.c:c_listA(cl_env_ptr env, cl_object args, int flags)
c/compiler.c:cl_object
c/compiler.c:si_need_to_make_load_form_p(cl_object object)
c/compiler.c:  cl_object load_form_cache = ECL_NIL;
c/compiler.c:  cl_object waiting_objects = ecl_list1(object);
c/compiler.c:    cl_object bc = object->bclosure.code;
c/compiler.c:cl_object si_process_declarations(cl_narg narg, cl_object body, ...)
c/compiler.c:  cl_object documentation = ECL_NIL, declarations = ECL_NIL, specials = ECL_NIL;
c/compiler.c:	cl_object doc;
c/compiler.c:		doc = va_arg(ARGS,cl_object);
c/compiler.c:    cl_object form;
c/compiler.c:      cl_object sentence = pop(&form);
c/compiler.c:          cl_object v = pop(&sentence);
c/compiler.c:	cl_object __value0 = cl_nreverse(declarations);
c/compiler.c:	cl_object __value1 = body;
c/compiler.c:	cl_object __value2 = documentation;
c/compiler.c:	cl_object __value3 = specials;
c/compiler.c:cl_object
c/compiler.c:si_process_lambda(cl_object lambda)
c/compiler.c:  cl_object documentation, declarations, specials;
c/compiler.c:  cl_object lambda_list, body;
c/compiler.c:cl_object
c/compiler.c:si_process_lambda_list(cl_object org_lambda_list, cl_object context)
c/compiler.c:#define push(v,l) { cl_object c = *l = CONS(v, *l); l = &ECL_CONS_CDR(c); }
c/compiler.c:  cl_object lists[4] = {ECL_NIL, ECL_NIL, ECL_NIL, ECL_NIL};
c/compiler.c:  cl_object *reqs = lists, *opts = lists+1, *keys = lists+2, *auxs = lists+3;
c/compiler.c:  cl_object v, rest = ECL_NIL, lambda_list = org_lambda_list;
c/compiler.c:  cl_object allow_other_keys = ECL_NIL;
c/compiler.c:  cl_object key_flag = ECL_NIL;
c/compiler.c:    cl_object spp = ECL_NIL;
c/compiler.c:    cl_object init = ECL_NIL;
c/compiler.c:      cl_object x = v;
c/compiler.c:    cl_object init = ECL_NIL;
c/compiler.c:    cl_object spp = ECL_NIL;
c/compiler.c:    cl_object key;
c/compiler.c:      cl_object x = v;
c/compiler.c:    cl_object init;
c/compiler.c:      cl_object x = v;
c/compiler.c:	cl_object __value0 = CONS(ecl_make_fixnum(nreq), lists[0]);
c/compiler.c:	cl_object __value1 = CONS(ecl_make_fixnum(nopt), lists[1]);
c/compiler.c:	cl_object __value2 = rest;
c/compiler.c:	cl_object __value3 = key_flag;
c/compiler.c:	cl_object __value4 = CONS(ecl_make_fixnum(nkey), lists[2]);
c/compiler.c:	cl_object __value5 = allow_other_keys;
c/compiler.c:	cl_object __value6 = lists[3];
c/compiler.c:c_default(cl_env_ptr env, cl_object var, cl_object stmt, cl_object flag, cl_object specials)
c/compiler.c:cl_object
c/compiler.c:ecl_make_lambda(cl_env_ptr env, cl_object name, cl_object lambda) {
c/compiler.c:  cl_object reqs, opts, rest, key, keys, auxs, allow_other_keys;
c/compiler.c:  cl_object specials, decl, body, output;
c/compiler.c:    cl_object var = pop(&reqs);
c/compiler.c:    cl_object var = pop(&opts);
c/compiler.c:    cl_object stmt = pop(&opts);
c/compiler.c:    cl_object flag = pop(&opts);
c/compiler.c:    cl_object aux = CONS(allow_other_keys,ECL_NIL);
c/compiler.c:    cl_object names = ECL_NIL;
c/compiler.c:      cl_object name = pop(&keys);
c/compiler.c:      cl_object var = pop(&keys);
c/compiler.c:      cl_object stmt = pop(&keys);
c/compiler.c:      cl_object flag = pop(&keys);
c/compiler.c:    cl_object var = pop(&auxs);
c/compiler.c:    cl_object value = pop(&auxs);
c/compiler.c:      cl_object l = ECL_CONS_CAR(decl);
c/compiler.c:static cl_object
c/compiler.c:ecl_function_block_name(cl_object name)
c/compiler.c:      cl_object output = ECL_CONS_CAR(name);
c/compiler.c:cl_object
c/compiler.c:si_function_block_name(cl_object name)
c/compiler.c:  cl_object output = ecl_function_block_name(name);
c/compiler.c:	cl_object __value0 = output;
c/compiler.c:cl_object
c/compiler.c:si_valid_function_name_p(cl_object name)
c/compiler.c:	cl_object __value0 = (name? ECL_T : ECL_NIL);
c/compiler.c:cl_object
c/compiler.c:si_make_lambda(cl_object name, cl_object rest)
c/compiler.c:  cl_object lambda;
c/compiler.c:	cl_object __value0 = lambda;
c/compiler.c:cl_object
c/compiler.c:si_bc_compile_from_stream(cl_object input)
c/compiler.c:  cl_object bytecodes = ECL_NIL;
c/compiler.c:      cl_object position, form, source_location;
c/compiler.c:cl_object si_eval_with_env(cl_narg narg, cl_object form, ...)
c/compiler.c:  cl_object interpreter_env, compiler_env;
c/compiler.c:	cl_object env;
c/compiler.c:	cl_object stepping;
c/compiler.c:	cl_object compiler_env_p;
c/compiler.c:	cl_object mode;
c/compiler.c:		env = va_arg(ARGS,cl_object);
c/compiler.c:		stepping = va_arg(ARGS,cl_object);
c/compiler.c:		compiler_env_p = va_arg(ARGS,cl_object);
c/compiler.c:		mode = va_arg(ARGS,cl_object);
c/compiler.c:  cl_object dispatch_table =
c/condition_variable.c:cl_object
c/condition_variable.c:  cl_object output = ecl_alloc_object(t_condition_variable);
c/condition_variable.c:	cl_object __value0 = output;
c/condition_variable.c:static cl_object
c/condition_variable.c:condition_variable_wait(cl_env_ptr env, cl_object cv)
c/condition_variable.c:  cl_object lock = cv->condition_variable.lock;
c/condition_variable.c:  cl_object own_process = env->own_process;
c/condition_variable.c:cl_object
c/condition_variable.c:mp_condition_variable_wait(cl_object cv, cl_object lock)
c/condition_variable.c:  cl_object own_process = env->own_process;
c/condition_variable.c:	cl_object __value0 = ECL_T;
c/condition_variable.c:cl_object
c/condition_variable.c:mp_condition_variable_timedwait(cl_object cv, cl_object lock, cl_object seconds)
c/condition_variable.c:cl_object
c/condition_variable.c:mp_condition_variable_signal(cl_object cv)
c/condition_variable.c:	cl_object __value0 = ECL_T;
c/condition_variable.c:cl_object
c/condition_variable.c:mp_condition_variable_broadcast(cl_object cv)
c/condition_variable.c:	cl_object __value0 = ECL_T;
c/conjugate.c:cl_object
c/conjugate.c:cl_conjugate(cl_object x)
c/conjugate.c:	cl_object __value0 = ecl_conjugate(x);
c/conjugate.c:static cl_object
c/conjugate.c:ecl_conjugate_real(cl_object x)
c/conjugate.c:static cl_object
c/conjugate.c:ecl_conjugate_complex(cl_object x)
c/conjugate.c:static cl_object
c/conjugate.c:ecl_conjugate_csfloat(cl_object x)
c/conjugate.c:  cl_object result = ecl_alloc_object(t_csfloat);
c/conjugate.c:static cl_object
c/conjugate.c:ecl_conjugate_cdfloat(cl_object x)
c/conjugate.c:  cl_object result = ecl_alloc_object(t_cdfloat);
c/conjugate.c:static cl_object
c/conjugate.c:ecl_conjugate_clfloat(cl_object x)
c/conjugate.c:  cl_object result = ecl_alloc_object(t_clfloat);
c/cons.c:cl_object _ecl_car(cl_object x)
c/cons.c:cl_object _ecl_cdr(cl_object x)
c/cons.c:cl_object _ecl_caar(cl_object x)
c/cons.c:cl_object _ecl_cdar(cl_object x)
c/cons.c:cl_object _ecl_cadr(cl_object x)
c/cons.c:cl_object _ecl_cddr(cl_object x)
c/cons.c:cl_object _ecl_caaar(cl_object x)
c/cons.c:cl_object _ecl_cdaar(cl_object x)
c/cons.c:cl_object _ecl_cadar(cl_object x)
c/cons.c:cl_object _ecl_cddar(cl_object x)
c/cons.c:cl_object _ecl_caadr(cl_object x)
c/cons.c:cl_object _ecl_cdadr(cl_object x)
c/cons.c:cl_object _ecl_caddr(cl_object x)
c/cons.c:cl_object _ecl_cdddr(cl_object x)
c/cons.c:cl_object _ecl_caaaar(cl_object x)
c/cons.c:cl_object _ecl_cdaaar(cl_object x)
c/cons.c:cl_object _ecl_cadaar(cl_object x)
c/cons.c:cl_object _ecl_cddaar(cl_object x)
c/cons.c:cl_object _ecl_caadar(cl_object x)
c/cons.c:cl_object _ecl_cdadar(cl_object x)
c/cons.c:cl_object _ecl_caddar(cl_object x)
c/cons.c:cl_object _ecl_cdddar(cl_object x)
c/cons.c:cl_object _ecl_caaadr(cl_object x)
c/cons.c:cl_object _ecl_cdaadr(cl_object x)
c/cons.c:cl_object _ecl_cadadr(cl_object x)
c/cons.c:cl_object _ecl_cddadr(cl_object x)
c/cons.c:cl_object _ecl_caaddr(cl_object x)
c/cons.c:cl_object _ecl_cdaddr(cl_object x)
c/cons.c:cl_object _ecl_cadddr(cl_object x)
c/cons.c:cl_object _ecl_cddddr(cl_object x)
c/cons.c:cl_object ecl_car(cl_object x)
c/cons.c:cl_object ecl_cdr(cl_object x)
c/cons.c:cl_object ecl_caar(cl_object x)
c/cons.c:cl_object ecl_cdar(cl_object x)
c/cons.c:cl_object ecl_cadr(cl_object x)
c/cons.c:cl_object ecl_cddr(cl_object x)
c/cons.c:cl_object ecl_caaar(cl_object x)
c/cons.c:cl_object ecl_cdaar(cl_object x)
c/cons.c:cl_object ecl_cadar(cl_object x)
c/cons.c:cl_object ecl_cddar(cl_object x)
c/cons.c:cl_object ecl_caadr(cl_object x)
c/cons.c:cl_object ecl_cdadr(cl_object x)
c/cons.c:cl_object ecl_caddr(cl_object x)
c/cons.c:cl_object ecl_cdddr(cl_object x)
c/cons.c:cl_object ecl_caaaar(cl_object x)
c/cons.c:cl_object ecl_cdaaar(cl_object x)
c/cons.c:cl_object ecl_cadaar(cl_object x)
c/cons.c:cl_object ecl_cddaar(cl_object x)
c/cons.c:cl_object ecl_caadar(cl_object x)
c/cons.c:cl_object ecl_cdadar(cl_object x)
c/cons.c:cl_object ecl_caddar(cl_object x)
c/cons.c:cl_object ecl_cdddar(cl_object x)
c/cons.c:cl_object ecl_caaadr(cl_object x)
c/cons.c:cl_object ecl_cdaadr(cl_object x)
c/cons.c:cl_object ecl_cadadr(cl_object x)
c/cons.c:cl_object ecl_cddadr(cl_object x)
c/cons.c:cl_object ecl_caaddr(cl_object x)
c/cons.c:cl_object ecl_cdaddr(cl_object x)
c/cons.c:cl_object ecl_cadddr(cl_object x)
c/cons.c:cl_object ecl_cddddr(cl_object x)
c/cons.c:cl_object cl_car(cl_object x)
c/cons.c:cl_object cl_cdr(cl_object x)
c/cons.c:cl_object cl_caar(cl_object x)
c/cons.c:cl_object cl_cdar(cl_object x)
c/cons.c:cl_object cl_cadr(cl_object x)
c/cons.c:cl_object cl_cddr(cl_object x)
c/cons.c:cl_object cl_caaar(cl_object x)
c/cons.c:cl_object cl_cdaar(cl_object x)
c/cons.c:cl_object cl_cadar(cl_object x)
c/cons.c:cl_object cl_cddar(cl_object x)
c/cons.c:cl_object cl_caadr(cl_object x)
c/cons.c:cl_object cl_cdadr(cl_object x)
c/cons.c:cl_object cl_caddr(cl_object x)
c/cons.c:cl_object cl_cdddr(cl_object x)
c/cons.c:cl_object cl_caaaar(cl_object x)
c/cons.c:cl_object cl_cdaaar(cl_object x)
c/cons.c:cl_object cl_cadaar(cl_object x)
c/cons.c:cl_object cl_cddaar(cl_object x)
c/cons.c:cl_object cl_caadar(cl_object x)
c/cons.c:cl_object cl_cdadar(cl_object x)
c/cons.c:cl_object cl_caddar(cl_object x)
c/cons.c:cl_object cl_cdddar(cl_object x)
c/cons.c:cl_object cl_caaadr(cl_object x)
c/cons.c:cl_object cl_cdaadr(cl_object x)
c/cons.c:cl_object cl_cadadr(cl_object x)
c/cons.c:cl_object cl_cddadr(cl_object x)
c/cons.c:cl_object cl_caaddr(cl_object x)
c/cons.c:cl_object cl_cdaddr(cl_object x)
c/cons.c:cl_object cl_cadddr(cl_object x)
c/cons.c:cl_object cl_cddddr(cl_object x)
c/cos.c:cl_object
c/cos.c:cl_cos(cl_object x)
c/cos.c:	cl_object __value0 = ecl_cos(x);
c/cos.c:static cl_object
c/cos.c:ecl_cos_rational(cl_object x)
c/cos.c:static cl_object
c/cos.c:ecl_cos_single_float(cl_object x)
c/cos.c:static cl_object
c/cos.c:ecl_cos_double_float(cl_object x)
c/cos.c:static cl_object
c/cos.c:ecl_cos_long_float(cl_object x)
c/cos.c:static cl_object
c/cos.c:ecl_cos_complex(cl_object x)
c/cos.c:  cl_object dx = x->gencomplex.real;
c/cos.c:  cl_object dy = x->gencomplex.imag;
c/cos.c:  cl_object a = ecl_times(ecl_cos(dx), ecl_cosh(dy));
c/cos.c:  cl_object b = ecl_times(ecl_negate(ecl_sin(dx)), ecl_sinh(dy));
c/cos.c:static cl_object
c/cos.c:ecl_cos_csfloat(cl_object x)
c/cos.c:  cl_object result = ecl_alloc_object(t_csfloat);
c/cos.c:static cl_object
c/cos.c:ecl_cos_cdfloat(cl_object x)
c/cos.c:  cl_object result = ecl_alloc_object(t_cdfloat);
c/cos.c:static cl_object
c/cos.c:ecl_cos_clfloat(cl_object x)
c/cos.c:  cl_object result = ecl_alloc_object(t_clfloat);
c/cosh.c:cl_object
c/cosh.c:cl_cosh(cl_object x)
c/cosh.c:	cl_object __value0 = ecl_cosh(x);
c/cosh.c:static cl_object
c/cosh.c:ecl_cosh_rational(cl_object x)
c/cosh.c:static cl_object
c/cosh.c:ecl_cosh_single_float(cl_object x)
c/cosh.c:static cl_object
c/cosh.c:ecl_cosh_double_float(cl_object x)
c/cosh.c:static cl_object
c/cosh.c:ecl_cosh_long_float(cl_object x)
c/cosh.c:static cl_object
c/cosh.c:ecl_cosh_complex(cl_object x)
c/cosh.c:  cl_object dx = x->gencomplex.real;
c/cosh.c:  cl_object dy = x->gencomplex.imag;
c/cosh.c:  cl_object a = ecl_times(ecl_cosh(dx), ecl_cos(dy));
c/cosh.c:  cl_object b = ecl_times(ecl_sinh(dx), ecl_sin(dy));
c/cosh.c:static cl_object
c/cosh.c:ecl_cosh_csfloat(cl_object x)
c/cosh.c:  cl_object result = ecl_alloc_object(t_csfloat);
c/cosh.c:static cl_object
c/cosh.c:ecl_cosh_cdfloat(cl_object x)
c/cosh.c:  cl_object result = ecl_alloc_object(t_cdfloat);
c/cosh.c:static cl_object
c/cosh.c:ecl_cosh_clfloat(cl_object x)
c/cosh.c:  cl_object result = ecl_alloc_object(t_clfloat);
c/disassembler.c:static cl_opcode *disassemble(cl_object bytecodes, cl_opcode *vector);
c/disassembler.c:print_arg(const char *s, cl_object x) {
c/disassembler.c:print_oparg_arg(const char *s, cl_fixnum n, cl_object x) {
c/disassembler.c:disassemble_lambda(cl_object bytecodes) {
c/disassembler.c:disassemble_flet(cl_object bytecodes, cl_opcode *vector) {
c/disassembler.c:  cl_object *data = bytecodes->bytecodes.data->vector.self.t;
c/disassembler.c:    cl_object fun;
c/disassembler.c:disassemble_labels(cl_object bytecodes, cl_opcode *vector) {
c/disassembler.c:  cl_object *data = bytecodes->bytecodes.data->vector.self.t;
c/disassembler.c:    cl_object fun;
c/disassembler.c:disassemble_progv(cl_object bytecodes, cl_opcode *vector) {
c/disassembler.c:disassemble_tagbody(cl_object bytecodes, cl_opcode *vector) {
c/disassembler.c:disassemble(cl_object bytecodes, cl_opcode *vector) {
c/disassembler.c:  cl_object o;
c/disassembler.c:  cl_object line_format;
c/disassembler.c:  cl_object *data = bytecodes->bytecodes.data->vector.self.t;
c/disassembler.c:  cl_object line_no;
c/disassembler.c:cl_object
c/disassembler.c:si_bc_disassemble(cl_object v)
c/disassembler.c:	cl_object __value0 = v;
c/disassembler.c:	cl_object __value0 = ECL_NIL;
c/disassembler.c:cl_object
c/disassembler.c:si_bc_split(cl_object b)
c/disassembler.c:  cl_object vector, data, name, lex = ECL_NIL;
c/disassembler.c:	cl_object __value0 = lex;
c/disassembler.c:	cl_object __value1 = vector;
c/disassembler.c:	cl_object __value2 = data;
c/disassembler.c:	cl_object __value3 = name;
c/disassembler.c:cl_object
c/disassembler.c:si_bc_join(cl_object lex, cl_object code, cl_object data, cl_object name)
c/disassembler.c:  cl_object output;
c/disassembler.c:	cl_object __value0 = output;
c/divide.c:cl_object cl_N(cl_narg narg, cl_object num, ...)
c/divide.c:	cl_object __value0 = ecl_divide(ecl_make_fixnum(1), num);
c/divide.c:	cl_object __value0 = num;
c/divide.c:static cl_object
c/divide.c:complex_divide(cl_object ar, cl_object ai, cl_object br, cl_object bi)
c/divide.c:  cl_object z1 = ecl_plus(ecl_times(ar, br), ecl_times(ai, bi));
c/divide.c:  cl_object z2 = ecl_minus(ecl_times(ai, br), ecl_times(ar, bi));
c/divide.c:  cl_object absB = ecl_plus(ecl_times(br, br), ecl_times(bi, bi));
c/divide.c:cl_object
c/divide.c:ecl_divide(cl_object x, cl_object y)
c/divide.c:  cl_object ret;
c/divide.c:        cl_object z = ecl_times(x->ratio.den, y);
c/divide.c:        cl_object num = ecl_times(x->ratio.num,y->ratio.den);
c/divide.c:        cl_object den = ecl_times(x->ratio.den,y->ratio.num);
Binary file c/dpp.exe matches
Binary file c/dpp.obj matches
c/error.c:static cl_object
c/error.c:cl_symbol_or_object(cl_object x)
c/error.c:    return (cl_object)(cl_symbols + ecl_fixnum(x));
c/error.c:  cl_object tag;
c/error.c:  cl_object rest;
c/error.c:cl_object
c/error.c:CEerror(cl_object c, const char *err, int narg, ...)
c/error.c:  cl_object rest;
c/error.c:  cl_object real_args, text;
c/error.c:    cl_object stmt = ecl_symbol_value(ECL_SYM("SI::*CURRENT-FORM*",1667));
c/error.c:  cl_object rest;
c/error.c:FEreader_error(const char *s, cl_object stream, int narg, ...)
c/error.c:  cl_object message = ecl_make_constant_base_string(s,-1);
c/error.c:  cl_object args_list;
c/error.c:    cl_object prefix = ecl_make_constant_base_string("Reader error in file ~S, "
c/error.c:    cl_object position = cl_file_position(1, stream);
c/error.c:FEcannot_open(cl_object fn)
c/error.c:FEend_of_file(cl_object strm)
c/error.c:FEclosed_stream(cl_object strm)
c/error.c:cl_object
c/error.c:si_signal_type_error(cl_object value, cl_object type)
c/error.c:FEwrong_type_argument(cl_object type, cl_object value)
c/error.c:FEwrong_type_only_arg(cl_object function, cl_object value, cl_object type)
c/error.c:FEwrong_type_nth_arg(cl_object function, cl_narg narg, cl_object value, cl_object type)
c/error.c:FEwrong_type_key_arg(cl_object function, cl_object key, cl_object value, cl_object type)
c/error.c:FEwrong_index(cl_object function, cl_object a, int which, cl_object ndx,
c/error.c:  cl_object limit = ecl_make_integer(nonincl_limit-1);
c/error.c:  cl_object type = ecl_make_integer_type(ecl_make_fixnum(0), limit);
c/error.c:  cl_object message = ecl_make_constant_base_string((which<0) ? message1 : message2,-1);
c/error.c:FEunbound_variable(cl_object sym)
c/error.c:FEundefined_function(cl_object fname)
c/error.c:FEprint_not_readable(cl_object x)
c/error.c:FEwrong_num_arguments(cl_object fun)
c/error.c:FEinvalid_macro_call(cl_object name)
c/error.c:FEinvalid_variable(const char *s, cl_object obj)
c/error.c:FEillegal_variable_name(cl_object v)
c/error.c:FEassignment_to_constant(cl_object v)
c/error.c:FEbinding_a_constant(cl_object v)
c/error.c:FEinvalid_function(cl_object obj)
c/error.c:FEinvalid_function_name(cl_object fname)
c/error.c:static cl_object
c/error.c:universal_error_handler(cl_object continue_string, cl_object datum,
c/error.c:                        cl_object args)
c/error.c:  cl_object stream;
c/error.c:FEdivision_by_zero(cl_object x, cl_object y)
c/error.c:cl_object
c/error.c:  cl_object rest, error = _ecl_strerror(errno);
c/error.c:  cl_object rest, win_msg_obj;
c/error.c:cl_object cl_error(cl_narg narg, cl_object eformat, ...)
c/error.c:cl_object cl_cerror(cl_narg narg, cl_object cformat, cl_object eformat, ...)
c/error.c:	cl_object __value0 = funcall(4, ECL_SYM("SI::UNIVERSAL-ERROR-HANDLER",1179), cformat, eformat,
c/error.c:cl_object si_serror(cl_narg narg, cl_object cformat, cl_object eformat, ...)
c/error.c:	cl_object __value0 = funcall(4, ECL_SYM("SI::STACK-ERROR-HANDLER",1180), cformat, eformat,
c/error.c:                     (cl_objectfn_fixed)universal_error_handler,
c/eval.c:cl_object *
c/eval.c:cl_object
c/eval.c:ecl_apply_from_stack_frame(cl_object frame, cl_object x)
c/eval.c:  cl_object *sp = frame->frame.base;
c/eval.c:  cl_object fun = x;
c/eval.c:  cl_object ret;
c/eval.c:cl_objectfn
c/eval.c:ecl_function_dispatch(cl_env_ptr env, cl_object x)
c/eval.c:  cl_object fun = x;
c/eval.c:cl_object
c/eval.c:cl_funcall(cl_narg narg, cl_object function, ...)
c/eval.c:  cl_object output;
c/eval.c:cl_object cl_apply(cl_narg narg, cl_object fun, cl_object lastarg, ...)
c/eval.c:      cl_object out;
c/eval.c:      const cl_object frame = ecl_stack_frame_open(the_env,
c/eval.c:                                                   (cl_object)&frame_aux,
c/eval.c:cl_object
c/eval.c:cl_eval(cl_object form)
c/eval.c:cl_object cl_constantp(cl_narg narg, cl_object arg, ...)
c/eval.c:	cl_object env;
c/eval.c:		env = va_arg(ARGS,cl_object);
c/eval.c:cl_object si_constantp_inner(cl_narg narg, cl_object form, ...)
c/eval.c:  cl_object value;
c/eval.c:	cl_object env;
c/eval.c:		env = va_arg(ARGS,cl_object);
c/eval.c:cl_object si_constant_form_value(cl_narg narg, cl_object form, ...)
c/eval.c:  cl_object value;
c/eval.c:	cl_object env;
c/eval.c:		env = va_arg(ARGS,cl_object);
c/eval.c:	cl_object __value0 = value;
c/exp.c:cl_object
c/exp.c:cl_exp(cl_object x)
c/exp.c:	cl_object __value0 = ecl_exp(x);
c/exp.c:static cl_object
c/exp.c:ecl_exp_rational(cl_object x)
c/exp.c:static cl_object
c/exp.c:ecl_exp_single_float(cl_object x)
c/exp.c:static cl_object
c/exp.c:ecl_exp_double_float(cl_object x)
c/exp.c:static cl_object
c/exp.c:ecl_exp_long_float(cl_object x)
c/exp.c:static cl_object
c/exp.c:ecl_exp_complex(cl_object x)
c/exp.c:  cl_object y, y1;
c/exp.c:static cl_object
c/exp.c:ecl_exp_csfloat(cl_object x)
c/exp.c:  cl_object result = ecl_alloc_object(t_csfloat);
c/exp.c:static cl_object
c/exp.c:ecl_exp_cdfloat(cl_object x)
c/exp.c:  cl_object result = ecl_alloc_object(t_cdfloat);
c/exp.c:static cl_object
c/exp.c:ecl_exp_clfloat(cl_object x)
c/exp.c:  cl_object result = ecl_alloc_object(t_clfloat);
c/expt.c:cl_object
c/expt.c:cl_expt(cl_object x, cl_object y)
c/expt.c:	cl_object __value0 = ecl_expt(x, y);
c/expt.c:static cl_object
c/expt.c:expt_zero(cl_object x, cl_object y)
c/expt.c:  cl_object z;
c/expt.c:static cl_object
c/expt.c:ecl_expt_generic(cl_object x, cl_object y) {
c/expt.c:  cl_object z = ecl_make_fixnum(1);
c/expt.c:static cl_object
c/expt.c:ecl_expt_float(cl_object x, cl_object y) {
c/expt.c:  cl_object ret;
c/expt.c:static cl_object
c/expt.c:ecl_expt_complex_float(cl_object x, cl_object y) {
c/expt.c:  cl_object ret;
c/expt.c:cl_object
c/expt.c:ecl_expt(cl_object x, cl_object y)
c/expt.c:    cl_object z = ecl_log1(ecl_times(x, expt_zero(x, y)));
c/ffi.c:static const cl_object ecl_aet_to_ffi_table[ecl_aet_bc+1] = {
c/ffi.c:  cl_object name;
c/ffi.c:  cl_object name;
c/ffi.c:  FFI_DESC(ECL_SYM(":OBJECT",1305), cl_object),
c/ffi.c:  const cl_object symbol;
c/ffi.c:ecl_type_to_libffi_type(cl_object type) {
c/ffi.c:cl_object
c/ffi.c:ecl_make_foreign_data(cl_object tag, cl_index size, void *data)
c/ffi.c:  cl_object output = ecl_alloc_object(t_foreign);
c/ffi.c:cl_object
c/ffi.c:ecl_allocate_foreign_data(cl_object tag, cl_index size)
c/ffi.c:  cl_object output = ecl_alloc_object(t_foreign);
c/ffi.c:ecl_foreign_data_pointer_safe(cl_object f)
c/ffi.c:ecl_base_string_pointer_safe(cl_object f)
c/ffi.c:cl_object
c/ffi.c:ecl_null_terminated_base_string(cl_object f)
c/ffi.c:cl_object
c/ffi.c:si_allocate_foreign_data(cl_object tag, cl_object size)
c/ffi.c:  cl_object output = ecl_alloc_object(t_foreign);
c/ffi.c:	cl_object __value0 = output;
c/ffi.c:cl_object
c/ffi.c:si_free_foreign_data(cl_object f)
c/ffi.c:cl_object
c/ffi.c:si_make_foreign_data_from_array(cl_object array)
c/ffi.c:  cl_object tag;
c/ffi.c:	cl_object __value0 = ecl_make_foreign_data(tag, 0, array->array.self.bc);
c/ffi.c:cl_object
c/ffi.c:si_foreign_data_p(cl_object f)
c/ffi.c:	cl_object __value0 = (ECL_FOREIGN_DATA_P(f)? ECL_T : ECL_NIL);
c/ffi.c:cl_object
c/ffi.c:si_foreign_data_address(cl_object f)
c/ffi.c:	cl_object __value0 = ecl_make_unsigned_integer((cl_index)f->foreign.data);
c/ffi.c:cl_object
c/ffi.c:si_foreign_data_tag(cl_object f)
c/ffi.c:	cl_object __value0 = f->foreign.tag;
c/ffi.c:cl_object
c/ffi.c:si_foreign_data_equal(cl_object f1, cl_object f2)
c/ffi.c:	cl_object __value0 = ((f1->foreign.data == f2->foreign.data)? ECL_T : ECL_NIL);
c/ffi.c:cl_object
c/ffi.c:si_foreign_data_pointer(cl_object f, cl_object andx, cl_object asize,
c/ffi.c:                        cl_object tag)
c/ffi.c:  cl_object output;
c/ffi.c:	cl_object __value0 = output;
c/ffi.c:cl_object
c/ffi.c:si_foreign_data_ref(cl_object f, cl_object andx, cl_object asize, cl_object tag)
c/ffi.c:  cl_object output;
c/ffi.c:	cl_object __value0 = output;
c/ffi.c:cl_object
c/ffi.c:si_foreign_data_set(cl_object f, cl_object andx, cl_object value)
c/ffi.c:	cl_object __value0 = value;
c/ffi.c:foreign_type_code(cl_object type)
c/ffi.c:ecl_foreign_type_code(cl_object type)
c/ffi.c:ecl_foreign_cc_code(cl_object cc)
c/ffi.c:cl_object
c/ffi.c:    return *(cl_object *)p;
c/ffi.c:ecl_foreign_data_set_elt(void *p, enum ecl_ffi_tag tag, cl_object value)
c/ffi.c:    *(cl_object *)p = value;
c/ffi.c:cl_object
c/ffi.c:si_foreign_data_ref_elt(cl_object f, cl_object andx, cl_object type)
c/ffi.c:	cl_object __value0 = ecl_foreign_data_ref_elt((void*)(f->foreign.data + ndx), tag);
c/ffi.c:cl_object
c/ffi.c:si_foreign_data_set_elt(cl_object f, cl_object andx, cl_object type, cl_object value)
c/ffi.c:	cl_object __value0 = value;
c/ffi.c:cl_object
c/ffi.c:si_size_of_foreign_elt_type(cl_object type)
c/ffi.c:	cl_object __value0 = ecl_make_fixnum(ecl_foreign_type_table[tag].size);
c/ffi.c:cl_object
c/ffi.c:si_alignment_of_foreign_elt_type(cl_object type)
c/ffi.c:	cl_object __value0 = ecl_make_fixnum(ALIGNMENT(tag));
c/ffi.c:cl_object
c/ffi.c:si_foreign_elt_type_p(cl_object type)
c/ffi.c:	cl_object __value0 = ((foreign_type_code(type) < 0)? ECL_NIL : ECL_T);
c/ffi.c:cl_object
c/ffi.c:si_null_pointer_p(cl_object f)
c/ffi.c:	cl_object __value0 = ((f->foreign.data == NULL)? ECL_T : ECL_NIL);
c/ffi.c:cl_object
c/ffi.c:si_foreign_data_recast(cl_object f, cl_object size, cl_object tag)
c/ffi.c:	cl_object __value0 = f;
c/ffi.c:cl_object
c/ffi.c:si_load_foreign_module(cl_object filename)
c/ffi.c:  cl_object output;
c/ffi.c:      cl_object aux = ecl_library_error(output);
c/ffi.c:	cl_object __value0 = output;
c/ffi.c:cl_object
c/ffi.c:si_unload_foreign_module(cl_object module)
c/ffi.c:  cl_object output = ECL_NIL;
c/ffi.c:	cl_object __value0 = output;
c/ffi.c:cl_object
c/ffi.c:si_find_foreign_symbol(cl_object var, cl_object module, cl_object type, cl_object size)
c/ffi.c:  cl_object block;
c/ffi.c:  cl_object output = ECL_NIL;
c/ffi.c:	cl_object __value0 = output;
c/ffi.c:prepare_cif(cl_env_ptr the_env, ffi_cif *cif, cl_object return_type,
c/ffi.c:            cl_object arg_types, cl_object args,
c/ffi.c:            cl_object cc_type, ffi_type ***output_copy)
c/ffi.c:  cl_object arg_type;
c/ffi.c:      cl_object object = ECL_CONS_CAR(args);
c/ffi.c:cl_object si_call_cfun(cl_narg narg, cl_object fun, cl_object return_type, cl_object arg_types, cl_object args, ...)
c/ffi.c:  cl_object object;
c/ffi.c:	cl_object cc_type;
c/ffi.c:		cc_type = va_arg(ARGS,cl_object);
c/ffi.c:	cl_object __value0 = object;
c/ffi.c:  cl_object data = (cl_object)userdata;
c/ffi.c:  cl_object fun = ECL_CONS_CAR(data);
c/ffi.c:  cl_object ret_type = (data = ECL_CONS_CDR(data), ECL_CONS_CAR(data));
c/ffi.c:  cl_object arg_types = (data = ECL_CONS_CDR(data), ECL_CONS_CAR(data));
c/ffi.c:  const cl_object frame = ecl_stack_frame_open(the_env, (cl_object)&frame_aux, 0);
c/ffi.c:  cl_object x;
c/ffi.c:    cl_object type = ECL_CONS_CAR(arg_types);
c/ffi.c:cl_object
c/ffi.c:si_free_ffi_closure(cl_object closure)
c/ffi.c:cl_object si_make_dynamic_callback(cl_narg narg, cl_object fun, cl_object sym, cl_object return_type, cl_object arg_types, ...)
c/ffi.c:	cl_object cc_type;
c/ffi.c:		cc_type = va_arg(ARGS,cl_object);
c/ffi.c:    cl_object closure_object = ecl_make_foreign_data(ECL_SYM(":POINTER-VOID",1410),
c/ffi.c:    cl_object data = cl_list(5,
c/ffi.c:	cl_object __value0 = closure_object;
c/file.c:static cl_index ecl_read_byte8(cl_object stream, unsigned char *c, cl_index n);
c/file.c:static cl_index ecl_write_byte8(cl_object stream, unsigned char *c, cl_index n);
c/file.c:const struct ecl_file_ops *stream_dispatch_table(cl_object strm);
c/file.c:static int flisten(cl_object, FILE *);
c/file.c:static int file_listen(cl_object, int);
c/file.c:static cl_object alloc_stream();
c/file.c:static void cannot_close(cl_object stream) ecl_attr_noreturn;
c/file.c:static void file_libc_error(cl_object error_type, cl_object stream, const char *msg, int narg, ...) ecl_attr_noreturn;
c/file.c:static cl_object not_a_file_stream(cl_object fn) ecl_attr_noreturn;
c/file.c:static void not_an_input_stream(cl_object fn) ecl_attr_noreturn;
c/file.c:static void not_an_output_stream(cl_object fn) ecl_attr_noreturn;
c/file.c:static void not_a_character_stream(cl_object s) ecl_attr_noreturn;
c/file.c:static void not_a_binary_stream(cl_object s) ecl_attr_noreturn;
c/file.c:static int restartable_io_error(cl_object strm, const char *s);
c/file.c:static void unread_error(cl_object strm);
c/file.c:static void unread_twice(cl_object strm);
c/file.c:static void io_error(cl_object strm) ecl_attr_noreturn;
c/file.c:static cl_index encoding_error(cl_object strm, unsigned char *buffer, ecl_character c);
c/file.c:static ecl_character decoding_error(cl_object strm, unsigned char **buffer, int char_length, unsigned char *buffer_end);
c/file.c:static void wrong_file_handler(cl_object strm) ecl_attr_noreturn;
c/file.c:static void wsock_error( const char *err_msg, cl_object strm ) ecl_attr_noreturn;
c/file.c:not_output_write_byte8(cl_object strm, unsigned char *c, cl_index n)
c/file.c:not_input_read_byte8(cl_object strm, unsigned char *c, cl_index n)
c/file.c:not_binary_read_byte8(cl_object strm, unsigned char *c, cl_index n)
c/file.c:not_output_write_byte(cl_object c, cl_object strm)
c/file.c:static cl_object
c/file.c:not_input_read_byte(cl_object strm)
c/file.c:not_binary_write_byte(cl_object c, cl_object strm)
c/file.c:static cl_object
c/file.c:not_binary_read_byte(cl_object strm)
c/file.c:not_input_read_char(cl_object strm)
c/file.c:not_output_write_char(cl_object strm, ecl_character c)
c/file.c:not_input_unread_char(cl_object strm, ecl_character c)
c/file.c:not_input_listen(cl_object strm)
c/file.c:not_character_read_char(cl_object strm)
c/file.c:not_character_write_char(cl_object strm, ecl_character c)
c/file.c:not_character_decoder(cl_object stream, unsigned char **buffer, unsigned char *buffer_end) {
c/file.c:not_character_encoder(cl_object stream, unsigned char *buffer, ecl_character c) {
c/file.c:not_input_clear_input(cl_object strm)
c/file.c:not_output_clear_output(cl_object strm)
c/file.c:not_output_force_output(cl_object strm)
c/file.c:not_output_finish_output(cl_object strm)
c/file.c:unknown_column(cl_object strm)
c/file.c:closed_stream_read_byte8(cl_object strm, unsigned char *c, cl_index n)
c/file.c:closed_stream_write_byte8(cl_object strm, unsigned char *c, cl_index n)
c/file.c:closed_stream_read_char(cl_object strm)
c/file.c:closed_stream_write_char(cl_object strm, ecl_character c)
c/file.c:closed_stream_unread_char(cl_object strm, ecl_character c)
c/file.c:closed_stream_listen(cl_object strm)
c/file.c:closed_stream_clear_input(cl_object strm)
c/file.c:static cl_object
c/file.c:closed_stream_length(cl_object strm)
c/file.c:static cl_object
c/file.c:closed_stream_set_position(cl_object strm, cl_object position)
c/file.c:static cl_object
c/file.c:generic_read_byte_unsigned8(cl_object strm)
c/file.c:generic_write_byte_unsigned8(cl_object byte, cl_object strm)
c/file.c:static cl_object
c/file.c:generic_read_byte_signed8(cl_object strm)
c/file.c:generic_write_byte_signed8(cl_object byte, cl_object strm)
c/file.c:static cl_object
c/file.c:generic_read_byte_le(cl_object strm)
c/file.c:  cl_index (*read_byte8)(cl_object, unsigned char *, cl_index);
c/file.c:  cl_object output = ecl_make_fixnum(0);
c/file.c:    cl_object aux;
c/file.c:generic_write_byte_le(cl_object c, cl_object strm)
c/file.c:  cl_index (*write_byte8)(cl_object strm, unsigned char *c, cl_index n);
c/file.c:    cl_object b = cl_logand(2, c, ecl_make_fixnum(0xFF));
c/file.c:static cl_object
c/file.c:generic_read_byte(cl_object strm)
c/file.c:  cl_index (*read_byte8)(cl_object, unsigned char *, cl_index);
c/file.c:  cl_object output = NULL;
c/file.c:generic_write_byte(cl_object c, cl_object strm)
c/file.c:  cl_index (*write_byte8)(cl_object strm, unsigned char *c, cl_index n);
c/file.c:    cl_object b;
c/file.c:generic_peek_char(cl_object strm)
c/file.c:generic_void(cl_object strm)
c/file.c:generic_always_true(cl_object strm)
c/file.c:generic_always_false(cl_object strm)
c/file.c:static cl_object
c/file.c:generic_always_nil(cl_object strm)
c/file.c:generic_column(cl_object strm)
c/file.c:static cl_object
c/file.c:generic_set_position(cl_object strm, cl_object pos)
c/file.c:static cl_object
c/file.c:generic_close(cl_object strm)
c/file.c:generic_write_vector(cl_object strm, cl_object data, cl_index start, cl_index end)
c/file.c:    ecl_character (*write_char)(cl_object, ecl_character) = ops->write_char;                        
c/file.c:    void (*write_byte)(cl_object, cl_object) = ops->write_byte;
c/file.c:generic_read_vector(cl_object strm, cl_object data, cl_index start, cl_index end)
c/file.c:  cl_object expected_type;
c/file.c:    ecl_character (*read_char)(cl_object) = ops->read_char;
c/file.c:    cl_object (*read_byte)(cl_object) = ops->read_byte;
c/file.c:      cl_object x = read_byte(strm);
c/file.c:eformat_unread_char(cl_object strm, ecl_character c)
c/file.c:    cl_object l = strm->stream.byte_stack;
c/file.c:eformat_read_char(cl_object strm)
c/file.c:write_char_increment_column(cl_object strm, ecl_character c)
c/file.c:eformat_write_char(cl_object strm, ecl_character c)
c/file.c:eformat_read_char_cr(cl_object strm)
c/file.c:eformat_write_char_cr(cl_object strm, ecl_character c)
c/file.c:eformat_read_char_crlf(cl_object strm)
c/file.c:eformat_write_char_crlf(cl_object strm, ecl_character c)
c/file.c:passthrough_decoder(cl_object stream, unsigned char **buffer, unsigned char *buffer_end)
c/file.c:passthrough_encoder(cl_object stream, unsigned char *buffer, ecl_character c)
c/file.c:ascii_decoder(cl_object stream, unsigned char **buffer, unsigned char *buffer_end)
c/file.c:ascii_encoder(cl_object stream, unsigned char *buffer, ecl_character c)
c/file.c:ucs_4be_decoder(cl_object stream, unsigned char **buffer, unsigned char *buffer_end)
c/file.c:ucs_4be_encoder(cl_object stream, unsigned char *buffer, ecl_character c)
c/file.c:ucs_4le_decoder(cl_object stream, unsigned char **buffer, unsigned char *buffer_end)
c/file.c:ucs_4le_encoder(cl_object stream, unsigned char *buffer, ecl_character c)
c/file.c:ucs_4_decoder(cl_object stream, unsigned char **buffer, unsigned char *buffer_end)
c/file.c:ucs_4_encoder(cl_object stream, unsigned char *buffer, ecl_character c)
c/file.c:ucs_2be_decoder(cl_object stream, unsigned char **buffer, unsigned char *buffer_end)
c/file.c:ucs_2be_encoder(cl_object stream, unsigned char *buffer, ecl_character c)
c/file.c:ucs_2le_decoder(cl_object stream, unsigned char **buffer, unsigned char *buffer_end)
c/file.c:ucs_2le_encoder(cl_object stream, unsigned char *buffer, ecl_character c)
c/file.c:ucs_2_decoder(cl_object stream, unsigned char **buffer, unsigned char *buffer_end)
c/file.c:ucs_2_encoder(cl_object stream, unsigned char *buffer, ecl_character c)
c/file.c:user_decoder(cl_object stream, unsigned char **buffer, unsigned char *buffer_end)
c/file.c:  cl_object table = stream->stream.format_table;
c/file.c:  cl_object character;
c/file.c:user_encoder(cl_object stream, unsigned char *buffer, ecl_character c)
c/file.c:  cl_object byte = ecl_gethash_safe(ECL_CODE_CHAR(c), stream->stream.format_table, ECL_NIL);
c/file.c:user_multistate_decoder(cl_object stream, unsigned char **buffer, unsigned char *buffer_end)
c/file.c:  cl_object table_list = stream->stream.format_table;
c/file.c:  cl_object table = ECL_CONS_CAR(table_list);
c/file.c:  cl_object character;
c/file.c:user_multistate_encoder(cl_object stream, unsigned char *buffer, ecl_character c)
c/file.c:  cl_object table_list = stream->stream.format_table;
c/file.c:  cl_object p = table_list;
c/file.c:    cl_object table = ECL_CONS_CAR(p);
c/file.c:    cl_object byte = ecl_gethash_safe(ECL_CODE_CHAR(c), table, ECL_NIL);
c/file.c:        cl_object x = ecl_gethash_safe(ECL_T, table, ECL_NIL);
c/file.c:utf_8_decoder(cl_object stream, unsigned char **buffer, unsigned char *buffer_end)
c/file.c:utf_8_encoder(cl_object stream, unsigned char *buffer, ecl_character c)
c/file.c:clos_stream_read_byte8(cl_object strm, unsigned char *c, cl_index n)
c/file.c:    cl_object byte = _ecl_funcall2(ECL_SYM("GRAY::STREAM-READ-BYTE",1689), strm);
c/file.c:clos_stream_write_byte8(cl_object strm, unsigned char *c, cl_index n)
c/file.c:    cl_object byte = _ecl_funcall3(ECL_SYM("GRAY::STREAM-WRITE-BYTE",1697), strm,
c/file.c:static cl_object
c/file.c:clos_stream_read_byte(cl_object strm)
c/file.c:  cl_object b = _ecl_funcall2(ECL_SYM("GRAY::STREAM-READ-BYTE",1689), strm);
c/file.c:clos_stream_write_byte(cl_object c, cl_object strm)
c/file.c:clos_stream_read_char(cl_object strm)
c/file.c:  cl_object output = _ecl_funcall2(ECL_SYM("GRAY::STREAM-READ-CHAR",1690), strm);
c/file.c:clos_stream_write_char(cl_object strm, ecl_character c)
c/file.c:clos_stream_unread_char(cl_object strm, ecl_character c)
c/file.c:clos_stream_peek_char(cl_object strm)
c/file.c:  cl_object out = _ecl_funcall2(ECL_SYM("GRAY::STREAM-PEEK-CHAR",1688), strm);
c/file.c:clos_stream_read_vector(cl_object strm, cl_object data, cl_index start, cl_index end)
c/file.c:clos_stream_write_vector(cl_object strm, cl_object data, cl_index start, cl_index end)
c/file.c:clos_stream_listen(cl_object strm)
c/file.c:clos_stream_clear_input(cl_object strm)
c/file.c:clos_stream_clear_output(cl_object strm)
c/file.c:clos_stream_force_output(cl_object strm)
c/file.c:clos_stream_finish_output(cl_object strm)
c/file.c:clos_stream_input_p(cl_object strm)
c/file.c:clos_stream_output_p(cl_object strm)
c/file.c:clos_stream_interactive_p(cl_object strm)
c/file.c:static cl_object
c/file.c:clos_stream_element_type(cl_object strm)
c/file.c:static cl_object
c/file.c:clos_stream_get_position(cl_object strm)
c/file.c:static cl_object
c/file.c:clos_stream_set_position(cl_object strm, cl_object pos)
c/file.c:clos_stream_column(cl_object strm)
c/file.c:  cl_object col = _ecl_funcall2(ECL_SYM("GRAY::STREAM-LINE-COLUMN",1686), strm);
c/file.c:static cl_object
c/file.c:clos_stream_close(cl_object strm)
c/file.c:str_out_write_char(cl_object strm, ecl_character c)
c/file.c:static cl_object
c/file.c:str_out_element_type(cl_object strm)
c/file.c:  cl_object string = STRING_OUTPUT_STRING(strm);
c/file.c:static cl_object
c/file.c:str_out_get_position(cl_object strm)
c/file.c:static cl_object
c/file.c:str_out_set_position(cl_object strm, cl_object pos)
c/file.c:  cl_object string = STRING_OUTPUT_STRING(strm);
c/file.c:cl_object
c/file.c:si_make_string_output_stream_from_string(cl_object s)
c/file.c:  cl_object strm = alloc_stream();
c/file.c:	cl_object __value0 = strm;
c/file.c:cl_object
c/file.c:  cl_object s = extended?
c/file.c:  cl_object s = ecl_alloc_adjustable_base_string(line_length);
c/file.c:cl_object cl_make_string_output_stream(cl_narg narg, ...)
c/file.c:	static cl_object KEYS[1] = {(cl_object)(cl_symbols+1246)};
c/file.c:	cl_object element_type;
c/file.c:	cl_object KEY_VARS[2];
c/file.c:	cl_object __value0 = ecl_make_string_output_stream(128, extended);
c/file.c:cl_object
c/file.c:cl_get_output_stream_string(cl_object strm)
c/file.c:  cl_object strng;
c/file.c:	cl_object __value0 = strng;
c/file.c:str_in_read_char(cl_object strm)
c/file.c:str_in_unread_char(cl_object strm, ecl_character c)
c/file.c:str_in_peek_char(cl_object strm)
c/file.c:str_in_listen(cl_object strm)
c/file.c:static cl_object
c/file.c:str_in_element_type(cl_object strm)
c/file.c:  cl_object string = STRING_INPUT_STRING(strm);
c/file.c:static cl_object
c/file.c:str_in_get_position(cl_object strm)
c/file.c:static cl_object
c/file.c:str_in_set_position(cl_object strm, cl_object pos)
c/file.c:cl_object
c/file.c:ecl_make_string_input_stream(cl_object strng, cl_index istart, cl_index iend)
c/file.c:  cl_object strm;
c/file.c:cl_object cl_make_string_input_stream(cl_narg narg, cl_object strng, ...)
c/file.c:	cl_object istart;
c/file.c:	cl_object iend;
c/file.c:		istart = va_arg(ARGS,cl_object);
c/file.c:		iend = va_arg(ARGS,cl_object);
c/file.c:	cl_object __value0 = (ecl_make_string_input_stream(strng, p.start, p.end));
c/file.c:two_way_read_byte8(cl_object strm, unsigned char *c, cl_index n)
c/file.c:two_way_write_byte8(cl_object strm, unsigned char *c, cl_index n)
c/file.c:two_way_write_byte(cl_object byte, cl_object stream)
c/file.c:static cl_object
c/file.c:two_way_read_byte(cl_object stream)
c/file.c:two_way_read_char(cl_object strm)
c/file.c:two_way_write_char(cl_object strm, ecl_character c)
c/file.c:two_way_unread_char(cl_object strm, ecl_character c)
c/file.c:two_way_peek_char(cl_object strm)
c/file.c:two_way_read_vector(cl_object strm, cl_object data, cl_index start, cl_index n)
c/file.c:two_way_write_vector(cl_object strm, cl_object data, cl_index start, cl_index n)
c/file.c:two_way_listen(cl_object strm)
c/file.c:two_way_clear_input(cl_object strm)
c/file.c:two_way_clear_output(cl_object strm)
c/file.c:two_way_force_output(cl_object strm)
c/file.c:two_way_finish_output(cl_object strm)
c/file.c:two_way_interactive_p(cl_object strm)
c/file.c:static cl_object
c/file.c:two_way_element_type(cl_object strm)
c/file.c:two_way_column(cl_object strm)
c/file.c:static cl_object
c/file.c:two_way_close(cl_object strm)
c/file.c:cl_object
c/file.c:cl_make_two_way_stream(cl_object istrm, cl_object ostrm)
c/file.c:  cl_object strm;
c/file.c:	cl_object __value0 = strm;
c/file.c:cl_object
c/file.c:cl_two_way_stream_input_stream(cl_object strm)
c/file.c:	cl_object __value0 = TWO_WAY_STREAM_INPUT(strm);
c/file.c:cl_object
c/file.c:cl_two_way_stream_output_stream(cl_object strm)
c/file.c:	cl_object __value0 = TWO_WAY_STREAM_OUTPUT(strm);
c/file.c:broadcast_write_byte8(cl_object strm, unsigned char *c, cl_index n)
c/file.c:  cl_object l;
c/file.c:broadcast_write_char(cl_object strm, ecl_character c)
c/file.c:  cl_object l;
c/file.c:broadcast_write_byte(cl_object c, cl_object strm)
c/file.c:  cl_object l;
c/file.c:broadcast_clear_output(cl_object strm)
c/file.c:  cl_object l;
c/file.c:broadcast_force_output(cl_object strm)
c/file.c:  cl_object l;
c/file.c:broadcast_finish_output(cl_object strm)
c/file.c:  cl_object l;
c/file.c:static cl_object
c/file.c:broadcast_element_type(cl_object strm)
c/file.c:  cl_object l = BROADCAST_STREAM_LIST(strm);
c/file.c:static cl_object
c/file.c:broadcast_length(cl_object strm)
c/file.c:  cl_object l = BROADCAST_STREAM_LIST(strm);
c/file.c:static cl_object
c/file.c:broadcast_get_position(cl_object strm)
c/file.c:  cl_object l = BROADCAST_STREAM_LIST(strm);
c/file.c:static cl_object
c/file.c:broadcast_set_position(cl_object strm, cl_object pos)
c/file.c:  cl_object l = BROADCAST_STREAM_LIST(strm);
c/file.c:broadcast_column(cl_object strm)
c/file.c:  cl_object l = BROADCAST_STREAM_LIST(strm);
c/file.c:static cl_object
c/file.c:broadcast_close(cl_object strm)
c/file.c:cl_object cl_make_broadcast_stream(cl_narg narg, ...)
c/file.c:  cl_object x, streams;
c/file.c:	cl_object __value0 = x;
c/file.c:cl_object
c/file.c:cl_broadcast_stream_streams(cl_object strm)
c/file.c:echo_read_byte8(cl_object strm, unsigned char *c, cl_index n)
c/file.c:echo_write_byte8(cl_object strm, unsigned char *c, cl_index n)
c/file.c:echo_write_byte(cl_object c, cl_object strm)
c/file.c:static cl_object
c/file.c:echo_read_byte(cl_object strm)
c/file.c:  cl_object out = ecl_read_byte(ECHO_STREAM_INPUT(strm));
c/file.c:echo_read_char(cl_object strm)
c/file.c:echo_write_char(cl_object strm, ecl_character c)
c/file.c:echo_unread_char(cl_object strm, ecl_character c)
c/file.c:echo_peek_char(cl_object strm)
c/file.c:echo_listen(cl_object strm)
c/file.c:echo_clear_input(cl_object strm)
c/file.c:echo_clear_output(cl_object strm)
c/file.c:echo_force_output(cl_object strm)
c/file.c:echo_finish_output(cl_object strm)
c/file.c:static cl_object
c/file.c:echo_element_type(cl_object strm)
c/file.c:echo_column(cl_object strm)
c/file.c:static cl_object
c/file.c:echo_close(cl_object strm)
c/file.c:cl_object
c/file.c:cl_make_echo_stream(cl_object strm1, cl_object strm2)
c/file.c:  cl_object strm;
c/file.c:	cl_object __value0 = strm;
c/file.c:cl_object
c/file.c:cl_echo_stream_input_stream(cl_object strm)
c/file.c:	cl_object __value0 = ECHO_STREAM_INPUT(strm);
c/file.c:cl_object
c/file.c:cl_echo_stream_output_stream(cl_object strm)
c/file.c:	cl_object __value0 = ECHO_STREAM_OUTPUT(strm);
c/file.c:concatenated_read_byte8(cl_object strm, unsigned char *c, cl_index n)
c/file.c:  cl_object l = CONCATENATED_STREAM_LIST(strm);
c/file.c:static cl_object
c/file.c:concatenated_read_byte(cl_object strm)
c/file.c:  cl_object l = CONCATENATED_STREAM_LIST(strm);
c/file.c:  cl_object c = ECL_NIL;
c/file.c:concatenated_read_char(cl_object strm)
c/file.c:  cl_object l = CONCATENATED_STREAM_LIST(strm);
c/file.c:concatenated_unread_char(cl_object strm, ecl_character c)
c/file.c:  cl_object l = CONCATENATED_STREAM_LIST(strm);
c/file.c:concatenated_listen(cl_object strm)
c/file.c:  cl_object l = CONCATENATED_STREAM_LIST(strm);
c/file.c:static cl_object
c/file.c:concatenated_close(cl_object strm)
c/file.c:cl_object cl_make_concatenated_stream(cl_narg narg, ...)
c/file.c:  cl_object x, streams;
c/file.c:	cl_object __value0 = x;
c/file.c:cl_object
c/file.c:cl_concatenated_stream_streams(cl_object strm)
c/file.c:synonym_read_byte8(cl_object strm, unsigned char *c, cl_index n)
c/file.c:synonym_write_byte8(cl_object strm, unsigned char *c, cl_index n)
c/file.c:synonym_write_byte(cl_object c, cl_object strm)
c/file.c:static cl_object
c/file.c:synonym_read_byte(cl_object strm)
c/file.c:synonym_read_char(cl_object strm)
c/file.c:synonym_write_char(cl_object strm, ecl_character c)
c/file.c:synonym_unread_char(cl_object strm, ecl_character c)
c/file.c:synonym_peek_char(cl_object strm)
c/file.c:synonym_read_vector(cl_object strm, cl_object data, cl_index start, cl_index n)
c/file.c:synonym_write_vector(cl_object strm, cl_object data, cl_index start, cl_index n)
c/file.c:synonym_listen(cl_object strm)
c/file.c:synonym_clear_input(cl_object strm)
c/file.c:synonym_clear_output(cl_object strm)
c/file.c:synonym_force_output(cl_object strm)
c/file.c:synonym_finish_output(cl_object strm)
c/file.c:synonym_input_p(cl_object strm)
c/file.c:synonym_output_p(cl_object strm)
c/file.c:synonym_interactive_p(cl_object strm)
c/file.c:static cl_object
c/file.c:synonym_element_type(cl_object strm)
c/file.c:static cl_object
c/file.c:synonym_length(cl_object strm)
c/file.c:static cl_object
c/file.c:synonym_get_position(cl_object strm)
c/file.c:static cl_object
c/file.c:synonym_set_position(cl_object strm, cl_object pos)
c/file.c:synonym_column(cl_object strm)
c/file.c:cl_object
c/file.c:cl_make_synonym_stream(cl_object sym)
c/file.c:  cl_object x;
c/file.c:	cl_object __value0 = x;
c/file.c:cl_object
c/file.c:cl_synonym_stream_symbol(cl_object strm)
c/file.c:	cl_object __value0 = SYNONYM_STREAM_SYMBOL(strm);
c/file.c:consume_byte_stack(cl_object strm, unsigned char *c, cl_index n)
c/file.c:    cl_object l = strm->stream.byte_stack;
c/file.c:io_file_read_byte8(cl_object strm, unsigned char *c, cl_index n)
c/file.c:output_file_write_byte8(cl_object strm, unsigned char *c, cl_index n)
c/file.c:io_file_write_byte8(cl_object strm, unsigned char *c, cl_index n)
c/file.c:    cl_object aux = ecl_file_position(strm);
c/file.c:io_file_listen(cl_object strm)
c/file.c:io_file_clear_input(cl_object strm)
c/file.c:io_file_interactive_p(cl_object strm)
c/file.c:static cl_object
c/file.c:io_file_element_type(cl_object strm)
c/file.c:static cl_object
c/file.c:io_file_length(cl_object strm)
c/file.c:  cl_object output = ecl_file_len(f);
c/file.c:static cl_object
c/file.c:io_file_get_position(cl_object strm)
c/file.c:  cl_object output;
c/file.c:    cl_object l = strm->stream.byte_stack;
c/file.c:static cl_object
c/file.c:io_file_set_position(cl_object strm, cl_object large_disp)
c/file.c:static cl_object
c/file.c:io_file_close(cl_object strm)
c/file.c:static ecl_character io_file_decode_char_from_buffer(cl_object strm, unsigned char *buffer, unsigned char **buffer_pos, unsigned char **buffer_end, bool seekable, cl_index min_needed_bytes) {
c/file.c:  cl_object __stream = (strm); \
c/file.c:io_file_read_vector(cl_object strm, cl_object data, cl_index start, cl_index end)
c/file.c:io_file_write_vector(cl_object strm, cl_object data, cl_index start, cl_index end)
c/file.c:parse_external_format(cl_object stream, cl_object format, int flags)
c/file.c:set_stream_elt_type(cl_object stream, cl_fixnum byte_size, int flags,
c/file.c:                    cl_object external_format)
c/file.c:  cl_object t;
c/file.c:    cl_object (*read_byte)(cl_object);
c/file.c:    void (*write_byte)(cl_object,cl_object);
c/file.c:cl_object
c/file.c:si_stream_external_format_set(cl_object stream, cl_object format)
c/file.c:      cl_object elt_type = ecl_stream_element_type(stream);
c/file.c:cl_object
c/file.c:ecl_make_file_stream_from_fd(cl_object fname, int fd, enum ecl_smmode smm,
c/file.c:                             cl_fixnum byte_size, int flags, cl_object external_format)
c/file.c:  cl_object stream = alloc_stream();
c/file.c:input_stream_read_byte8(cl_object strm, unsigned char *c, cl_index n)
c/file.c:output_stream_write_byte8(cl_object strm, unsigned char *c, cl_index n)
c/file.c:io_stream_write_byte8(cl_object strm, unsigned char *c, cl_index n)
c/file.c:    cl_object aux = ecl_file_position(strm);
c/file.c:static void io_stream_force_output(cl_object strm);
c/file.c:io_stream_read_byte8(cl_object strm, unsigned char *c, cl_index n)
c/file.c:io_stream_listen(cl_object strm)
c/file.c:io_stream_clear_input(cl_object strm)
c/file.c:io_stream_force_output(cl_object strm)
c/file.c:io_stream_interactive_p(cl_object strm)
c/file.c:static cl_object
c/file.c:io_stream_length(cl_object strm)
c/file.c:  cl_object output = ecl_file_len(fileno(f));
c/file.c:static cl_object
c/file.c:io_stream_get_position(cl_object strm)
c/file.c:  cl_object output;
c/file.c:    cl_object l = strm->stream.byte_stack;
c/file.c:static cl_object
c/file.c:io_stream_set_position(cl_object strm, cl_object large_disp)
c/file.c:static cl_object
c/file.c:io_stream_close(cl_object strm)
c/file.c:winsock_stream_read_byte8(cl_object strm, unsigned char *c, cl_index n)
c/file.c:winsock_stream_write_byte8(cl_object strm, unsigned char *c, cl_index n)
c/file.c:winsock_stream_listen(cl_object strm) 
c/file.c:winsock_stream_clear_input(cl_object strm)
c/file.c:static cl_object
c/file.c:winsock_stream_close(cl_object strm)
c/file.c:wcon_stream_read_byte8(cl_object strm, unsigned char *c, cl_index n)
c/file.c:wcon_stream_write_byte8(cl_object strm, unsigned char *c, cl_index n)
c/file.c:wcon_stream_listen(cl_object strm) 
c/file.c:wcon_stream_clear_input(cl_object strm)
c/file.c:wcon_stream_force_output(cl_object strm)
c/file.c:static cl_object
c/file.c:maybe_make_windows_console_FILE(cl_object fname, FILE *f, enum ecl_smmode smm,
c/file.c:                                cl_object external_format)
c/file.c:  cl_object output;
c/file.c:static cl_object
c/file.c:maybe_make_windows_console_fd(cl_object fname, int desc, enum ecl_smmode smm,
c/file.c:                              cl_object external_format)
c/file.c:  cl_object output;
c/file.c:cl_object
c/file.c:  cl_object encoding;
c/file.c:cl_object
c/file.c:si_set_buffering_mode(cl_object stream, cl_object buffer_mode_symbol)
c/file.c:	cl_object __value0 = stream;
c/file.c:cl_object
c/file.c:ecl_make_stream_from_FILE(cl_object fname, void *f, enum ecl_smmode smm,
c/file.c:                          cl_fixnum byte_size, int flags, cl_object external_format)
c/file.c:  cl_object stream;
c/file.c:cl_object
c/file.c:ecl_make_stream_from_fd(cl_object fname, int fd, enum ecl_smmode smm,
c/file.c:                        cl_fixnum byte_size, int flags, cl_object external_format)
c/file.c:ecl_stream_to_handle(cl_object s, bool output)
c/file.c:cl_object
c/file.c:si_file_stream_fd(cl_object s)
c/file.c:  cl_object ret;
c/file.c:	cl_object __value0 = ret;
c/file.c:seq_in_read_byte8(cl_object strm, unsigned char *c, cl_index n)
c/file.c:    cl_object vector = SEQ_INPUT_VECTOR(strm);
c/file.c:seq_in_unread_char(cl_object strm, ecl_character c)
c/file.c:seq_in_listen(cl_object strm)
c/file.c:static cl_object
c/file.c:seq_in_get_position(cl_object strm)
c/file.c:static cl_object
c/file.c:seq_in_set_position(cl_object strm, cl_object pos)
c/file.c:static cl_object
c/file.c:make_sequence_input_stream(cl_object vector, cl_index istart, cl_index iend,
c/file.c:                           cl_object external_format)
c/file.c:  cl_object strm;
c/file.c:  cl_object type_name;
c/file.c:cl_object si_make_sequence_input_stream(cl_narg narg, cl_object vector, ...)
c/file.c:	static cl_object KEYS[3] = {(cl_object)(cl_symbols+1337), (cl_object)(cl_symbols+1247), (cl_object)(cl_symbols+1258)};
c/file.c:	cl_object start;
c/file.c:	cl_object end;
c/file.c:	cl_object external_format;
c/file.c:	cl_object KEY_VARS[6];
c/file.c:	cl_object __value0 = make_sequence_input_stream(vector, p.start, p.end,
c/file.c:seq_out_write_byte8(cl_object strm, unsigned char *c, cl_index n)
c/file.c:    cl_object vector = SEQ_OUTPUT_VECTOR(strm);
c/file.c:static cl_object
c/file.c:seq_out_get_position(cl_object strm)
c/file.c:static cl_object
c/file.c:seq_out_set_position(cl_object strm, cl_object pos)
c/file.c:  cl_object vector = SEQ_OUTPUT_VECTOR(strm);
c/file.c:static cl_object
c/file.c:make_sequence_output_stream(cl_object vector, cl_object external_format)
c/file.c:  cl_object strm;
c/file.c:  cl_object type_name;
c/file.c:cl_object si_make_sequence_output_stream(cl_narg narg, cl_object vector, ...)
c/file.c:	static cl_object KEYS[1] = {(cl_object)(cl_symbols+1258)};
c/file.c:	cl_object external_format;
c/file.c:	cl_object KEY_VARS[2];
c/file.c:	cl_object __value0 = make_sequence_output_stream(vector, external_format);
c/file.c:stream_dispatch_table(cl_object strm)
c/file.c:ecl_read_byte8(cl_object strm, unsigned char *c, cl_index n)
c/file.c:ecl_write_byte8(cl_object strm, unsigned char *c, cl_index n)
c/file.c:ecl_read_char(cl_object strm)
c/file.c:ecl_read_char_noeof(cl_object strm)
c/file.c:cl_object
c/file.c:ecl_read_byte(cl_object strm)
c/file.c:ecl_write_byte(cl_object c, cl_object strm)
c/file.c:ecl_write_char(ecl_character c, cl_object strm)
c/file.c:ecl_unread_char(ecl_character c, cl_object strm)
c/file.c:ecl_listen_stream(cl_object strm)
c/file.c:ecl_clear_input(cl_object strm)
c/file.c:ecl_clear_output(cl_object strm)
c/file.c:ecl_force_output(cl_object strm)
c/file.c:ecl_finish_output(cl_object strm)
c/file.c:ecl_file_column(cl_object strm)
c/file.c:cl_object
c/file.c:ecl_file_length(cl_object strm)
c/file.c:cl_object
c/file.c:ecl_file_position(cl_object strm)
c/file.c:cl_object
c/file.c:ecl_file_position_set(cl_object strm, cl_object pos)
c/file.c:ecl_input_stream_p(cl_object strm)
c/file.c:ecl_output_stream_p(cl_object strm)
c/file.c:cl_object
c/file.c:ecl_stream_element_type(cl_object strm)
c/file.c:ecl_interactive_stream_p(cl_object strm)
c/file.c:ecl_peek_char(cl_object strm)
c/file.c:writestr_stream(const char *s, cl_object strm)
c/file.c:  cl_object buffer = si_get_buffer_string();
c/file.c:compute_char_size(cl_object stream, ecl_character c)
c/file.c:cl_object
c/file.c:cl_file_string_length(cl_object stream, cl_object string)
c/file.c:	cl_object __value0 = ECL_NIL;
c/file.c:	cl_object __value0 = ecl_make_fixnum(1);
c/file.c:	cl_object __value0 = ecl_make_fixnum(l);
c/file.c:cl_object
c/file.c:si_do_write_sequence(cl_object seq, cl_object stream, cl_object s, cl_object e)
c/file.c:    cl_object elt_type = cl_stream_element_type(stream);
c/file.c:    cl_object s = ecl_nthcdr(start, seq);
c/file.c:        cl_object elt = CAR(s);
c/file.c:	cl_object __value0 = seq;
c/file.c:cl_object
c/file.c:si_do_read_sequence(cl_object seq, cl_object stream, cl_object s, cl_object e)
c/file.c:    cl_object elt_type = cl_stream_element_type(stream);
c/file.c:        cl_object c;
c/file.c:	cl_object __value0 = ecl_make_fixnum(start);
c/file.c:cl_object
c/file.c:si_file_column(cl_object strm)
c/file.c:	cl_object __value0 = (column >= 0 ? ecl_make_fixnum(column) : ECL_NIL);
c/file.c:cl_object
c/file.c:cl_file_length(cl_object strm)
c/file.c:	cl_object __value0 = ecl_file_length(strm);
c/file.c:cl_object cl_file_position(cl_narg narg, cl_object file_stream, ...)
c/file.c:  cl_object output;
c/file.c:	cl_object position;
c/file.c:		position = va_arg(ARGS,cl_object);
c/file.c:	cl_object __value0 = output;
c/file.c:cl_object
c/file.c:cl_input_stream_p(cl_object strm)
c/file.c:	cl_object __value0 = (ecl_input_stream_p(strm) ? ECL_T : ECL_NIL);
c/file.c:cl_object
c/file.c:cl_output_stream_p(cl_object strm)
c/file.c:	cl_object __value0 = (ecl_output_stream_p(strm) ? ECL_T : ECL_NIL);
c/file.c:cl_object
c/file.c:cl_interactive_stream_p(cl_object strm)
c/file.c:	cl_object __value0 = (stream_dispatch_table(strm)->interactive_p(strm)? ECL_T : ECL_NIL);
c/file.c:cl_object
c/file.c:cl_open_stream_p(cl_object strm)
c/file.c:	cl_object __value0 = (strm->stream.closed ? ECL_NIL : ECL_T);
c/file.c:cl_object
c/file.c:cl_stream_element_type(cl_object strm)
c/file.c:	cl_object __value0 = ecl_stream_element_type(strm);
c/file.c:cl_object
c/file.c:cl_stream_external_format(cl_object strm)
c/file.c:  cl_object output;
c/file.c:	cl_object __value0 = output;
c/file.c:cl_object
c/file.c:cl_streamp(cl_object strm)
c/file.c:	cl_object __value0 = (ECL_ANSI_STREAM_P(strm) ? ECL_T : ECL_NIL);
c/file.c:cl_object
c/file.c:si_copy_stream(cl_object in, cl_object out, cl_object wait)
c/file.c:	cl_object __value0 = ((c==EOF) ? ECL_T : ECL_NIL);
c/file.c:ecl_normalize_stream_element_type(cl_object element_type)
c/file.c:    cl_object type;
c/file.c:FEinvalid_option(cl_object option, cl_object value)
c/file.c:cl_object
c/file.c:ecl_open_stream(cl_object fn, enum ecl_smmode smm, cl_object if_exists,
c/file.c:                cl_object if_does_not_exist, cl_fixnum byte_size,
c/file.c:                int flags, cl_object external_format)
c/file.c:  cl_object output, file_kind;
c/file.c:  cl_object filename = si_coerce_to_filename(fn);
c/file.c:cl_object cl_open(cl_narg narg, cl_object filename, ...)
c/file.c:	static cl_object KEYS[6] = {(cl_object)(cl_symbols+1240), (cl_object)(cl_symbols+1246), (cl_object)(cl_symbols+1270), (cl_object)(cl_symbols+1268), (cl_object)(cl_symbols+1258), (cl_object)(cl_symbols+1352)};
c/file.c:	cl_object direction;
c/file.c:	cl_object element_type;
c/file.c:	cl_object if_exists;
c/file.c:	cl_object if_does_not_exist;
c/file.c:	cl_object external_format;
c/file.c:	cl_object cstream;
c/file.c:	cl_object strm;
c/file.c:	cl_object KEY_VARS[12];
c/file.c:	cl_object __value0 = strm;
c/file.c:cl_object cl_close(cl_narg narg, cl_object strm, ...)
c/file.c:	static cl_object KEYS[1] = {(cl_object)(cl_symbols+1217)};
c/file.c:	cl_object abort;
c/file.c:	cl_object KEY_VARS[2];
c/file.c:	cl_object __value0 = stream_dispatch_table(strm)->close(strm);
c/file.c:file_listen(cl_object stream, int fileno)
c/file.c:flisten(cl_object stream, FILE *fp)
c/file.c:cl_object
c/file.c:  cl_object output;
c/file.c:    cl_object y = _ecl_big_register0();
c/file.c:ecl_integer_to_off_t(cl_object offset)
c/file.c:static cl_object
c/file.c:  cl_object x = ecl_alloc_object(t_stream);
c/file.c:static cl_object
c/file.c:not_a_file_stream(cl_object strm)
c/file.c:not_an_input_stream(cl_object strm)
c/file.c:not_an_output_stream(cl_object strm)
c/file.c:not_a_character_stream(cl_object s)
c/file.c:not_a_binary_stream(cl_object s)
c/file.c:cannot_close(cl_object stream)
c/file.c:file_libc_error(cl_object error_type, cl_object stream,
c/file.c:  cl_object rest, error = _ecl_strerror(errno);
c/file.c:  si_signal_simple_error(4, (cl_object)(cl_symbols + ecl_fixnum(error_type)), Cnil,
c/file.c:unread_error(cl_object s)
c/file.c:unread_twice(cl_object s)
c/file.c:maybe_clearerr(cl_object strm)
c/file.c:restartable_io_error(cl_object strm, const char *s)
c/file.c:io_error(cl_object strm)
c/file.c:wrong_file_handler(cl_object strm)
c/file.c:encoding_error(cl_object stream, unsigned char *buffer, ecl_character c)
c/file.c:  cl_object code = _ecl_funcall4(ECL_SYM("EXT::ENCODING-ERROR",1914), stream,
c/file.c:decoding_error(cl_object stream, unsigned char **buffer, int char_length, unsigned char *buffer_end)
c/file.c:  cl_object octets = ECL_NIL, code;
c/file.c:wsock_error( const char *err_msg, cl_object strm )
c/file.c:  cl_object msg_obj;
c/file.c:  cl_object standard_input;
c/file.c:  cl_object standard_output;
c/file.c:  cl_object error_output;
c/file.c:  cl_object aux;
c/file.c:  cl_object null_stream;
c/file.c:  cl_object external_format = ECL_NIL;
c/float_to_digits.c:  cl_object r;
c/float_to_digits.c:  cl_object s;
c/float_to_digits.c:  cl_object mm;
c/float_to_digits.c:  cl_object mp;
c/float_to_digits.c:static cl_object
c/float_to_digits.c:times2(cl_object x)
c/float_to_digits.c:setup(cl_object number, float_approx *approx)
c/float_to_digits.c:  cl_object f = cl_integer_decode_float(number);
c/float_to_digits.c:    cl_object be = EXPT_RADIX(e);
c/float_to_digits.c:      cl_object be1 = ecl_times(be, ecl_make_fixnum(FLT_RADIX));
c/float_to_digits.c:  cl_object x = ecl_plus(approx->r, approx->mp);
c/float_to_digits.c:static cl_object
c/float_to_digits.c:generate(cl_object digits, float_approx *approx)
c/float_to_digits.c:  cl_object d, x;
c/float_to_digits.c:change_precision(float_approx *approx, cl_object position, cl_object relativep)
c/float_to_digits.c:    cl_object k = ecl_make_fixnum(0);
c/float_to_digits.c:    cl_object l = ecl_make_fixnum(1);
c/float_to_digits.c:      cl_object e1 = cl_expt(PRINT_BASE, position);
c/float_to_digits.c:      cl_object e2 = ecl_divide(e1, ecl_make_fixnum(2));
c/float_to_digits.c:    cl_object x = ecl_times(approx->s, cl_expt(PRINT_BASE, position));
c/float_to_digits.c:    cl_object e = ecl_divide(x, ecl_make_fixnum(2));
c/float_to_digits.c:    cl_object low = cl_max(2, approx->mm, e);
c/float_to_digits.c:    cl_object high = cl_max(2, approx->mp, e);
c/float_to_digits.c:cl_object
c/float_to_digits.c:si_float_to_digits(cl_object digits, cl_object number, cl_object position,
c/float_to_digits.c:                   cl_object relativep)
c/float_to_digits.c:	cl_object __value0 = ecl_make_fixnum(k);
c/float_to_digits.c:	cl_object __value1 = digits;
c/float_to_string.c:cl_object
c/float_to_string.c:_ecl_ensure_buffer(cl_object buffer, cl_fixnum length)
c/float_to_string.c:_ecl_string_push_c_string(cl_object s, const char *c)
c/float_to_string.c:insert_char(cl_object buffer, cl_index where, cl_fixnum c)
c/float_to_string.c:static cl_object
c/float_to_string.c:push_base_string(cl_object buffer, cl_object s)
c/float_to_string.c:print_float_exponent(cl_object buffer, cl_object number, cl_fixnum exp)
c/float_to_string.c:  cl_object r = ecl_symbol_value(ECL_SYM("*READ-DEFAULT-FLOAT-FORMAT*",64));
c/float_to_string.c:cl_object
c/float_to_string.c:si_float_to_string_free(cl_object buffer_or_nil, cl_object number,
c/float_to_string.c:                        cl_object e_min, cl_object e_max)
c/float_to_string.c:  cl_object exp, buffer;
c/float_to_string.c:    cl_object s = funcall(2, ECL_SYM("EXT::FLOAT-NAN-STRING",1773), number);
c/float_to_string.c:	cl_object __value0 = push_base_string(buffer_or_nil, si_coerce_to_base_string(s));
c/float_to_string.c:    cl_object s = funcall(2, ECL_SYM("EXT::FLOAT-INFINITY-STRING",1774), number);
c/float_to_string.c:	cl_object __value0 = push_base_string(buffer_or_nil, si_coerce_to_base_string(s));
c/float_to_string.c:	cl_object __value0 = buffer;
c/floor.c:cl_object cl_floor(cl_narg narg, cl_object x, ...)
c/floor.c:	cl_object y;
c/floor.c:		y = va_arg(ARGS,cl_object);
c/floor.c:cl_object
c/floor.c:ecl_floor1(cl_object x)
c/floor.c:  cl_object v0, v1;
c/floor.c:cl_object
c/floor.c:ecl_floor2(cl_object x, cl_object y)
c/floor.c:  cl_object v0, v1;
c/format.c:  cl_object     stream;
c/format.c:  cl_object     aux_stream;
c/format.c:  cl_object     aux_string;
c/format.c:  cl_object     ctl_str;
c/format.c:  cl_object     args, current;
c/format.c:  cl_object     param[FMT_MAX_PARAM];
c/format.c:static cl_object doformat(cl_narg narg, cl_object strm, cl_object string, ecl_va_list args, bool in_formatter);
c/format.c:static cl_object
c/format.c:  cl_object stream;
c/format.c:  cl_object p;
c/format.c:  cl_object p = fmt->args, target = fmt->current;
c/format.c:static cl_object
c/format.c:static cl_object
c/format.c:  cl_object output, l = fmt->current;
c/format.c:fmt_set_arg_list(format_stack fmt, cl_object l)
c/format.c:static cl_object
c/format.c:set_param(format_stack fmt, int i, int t, cl_object v)
c/format.c:    cl_object p = fmt->param[i];
c/format.c:  cl_object x;
c/format.c:  cl_object x;
c/format.c:fmt_integer(format_stack fmt, cl_object x, bool colon, bool atsign,
c/format.c:  cl_object x;
c/format.c:  cl_object x;
c/format.c:  cl_object x;
c/format.c:fmt_exponent1(cl_object stream, int e)
c/format.c:  cl_object x, y;
c/format.c:  cl_object x;
c/format.c:  cl_object x;
c/format.c:  cl_object s, l;
c/format.c:  cl_object x;
c/format.c:  cl_object x;
c/format.c:  cl_object l;
c/format.c:    volatile cl_object l0;
c/format.c:  volatile cl_object fields;
c/format.c:  cl_object p;
c/format.c:  volatile cl_object special = ECL_NIL;
c/format.c:    cl_object this_field = ecl_make_string_output_stream(64, 1);
c/format.c:cl_object si::formatter-aux(cl_narg narg, cl_object strm, cl_object string, ...)
c/format.c:	cl_object __value0 = doformat(narg, strm, string, args, TRUE);
c/format.c:static cl_object
c/format.c:doformat(cl_narg narg, cl_object strm, cl_object string, ecl_va_list args, bool in_formatter)
c/format.c:  cl_object output = cl_grab_rest_args(args);
c/format.c:  cl_object x;
c/format.c:cl_object cl_format(cl_narg narg, cl_object strm, cl_object string, ...)
c/format.c:  cl_object output = ECL_NIL;
c/format.c:	cl_object __value0 = output;
c/gfun.c:static cl_object generic_function_dispatch_vararg(cl_narg, ...);
c/gfun.c:cl_object
c/gfun.c:  cl_object fun = env->function;
c/gfun.c:cl_object
c/gfun.c:static cl_object
c/gfun.c:  cl_object output;
c/gfun.c:  cl_object fun = env->function;
c/gfun.c:  const cl_object frame = ecl_stack_frame_open(env, (cl_object)&frame_aux, narg);
c/gfun.c:reshape_instance(cl_object x, int delta)
c/gfun.c:  cl_object aux = ecl_allocate_instance(ECL_CLASS_OF(x), size);
c/gfun.c:         sizeof(cl_object));
c/gfun.c:cl_object
c/gfun.c:clos_set_funcallable_instance_function(cl_object x, cl_object function_or_t)
c/gfun.c:	cl_object __value0 = x;
c/gfun.c:cl_object
c/gfun.c:si_generic_function_p(cl_object x)
c/gfun.c:	cl_object __value0 = ((ECL_INSTANCEP(x) && (x->instance.isgf))? ECL_T : ECL_NIL);
c/gfun.c:static cl_object
c/gfun.c:fill_spec_vector(cl_object vector, cl_object frame, cl_object gf)
c/gfun.c:  cl_object *args = frame->frame.base;
c/gfun.c:  cl_object spec_how_list = GFUN_SPEC(gf);
c/gfun.c:  cl_object *argtype = vector->vector.self.t;
c/gfun.c:    cl_object spec_how = ECL_CONS_CAR(spec_how_list);
c/gfun.c:    cl_object spec_type = ECL_CONS_CAR(spec_how);
c/gfun.c:    cl_object eql_spec;
c/gfun.c:static cl_object
c/gfun.c:frame_to_list(cl_object frame)
c/gfun.c:  cl_object arglist, *p;
c/gfun.c:static cl_object
c/gfun.c:frame_to_classes(cl_object frame)
c/gfun.c:  cl_object arglist, *p;
c/gfun.c:static cl_object
c/gfun.c:generic_compute_applicable_method(cl_env_ptr env, cl_object frame, cl_object gf)
c/gfun.c:  cl_object memoize;
c/gfun.c:  cl_object methods = _ecl_funcall3(ECL_SYM("CLOS::COMPUTE-APPLICABLE-METHODS-USING-CLASSES",1556),
c/gfun.c:    cl_object arglist = frame_to_list(frame);
c/gfun.c:static cl_object
c/gfun.c:restricted_compute_applicable_method(cl_env_ptr env, cl_object frame, cl_object gf)
c/gfun.c:  cl_object arglist = frame_to_list(frame);
c/gfun.c:  cl_object methods = clos_std_compute_applicable_methods(gf, arglist);
c/gfun.c:static cl_object
c/gfun.c:compute_applicable_method(cl_env_ptr env, cl_object frame, cl_object gf)
c/gfun.c:cl_object
c/gfun.c:_ecl_standard_dispatch(cl_object frame, cl_object gf)
c/gfun.c:  cl_object func, vector;
c/gfun.c:    const cl_object new_frame = (cl_object)&frame_aux;
c/gfun.c:      cl_object keys = cl_copy_seq(vector);
c/gfun.c:  if (frame == (cl_object)&frame_aux)
c/gfun.c:static cl_object
c/gfun.c:  cl_object output;
c/gfun.c:cl_object
c/gfun.c:si_clear_gfun_hash(cl_object what)
c/gfun.c:  cl_object list;
c/gfun.c:    cl_object process = ECL_CONS_CAR(list);
c/hash.c:assert_type_hash_table(cl_object function, cl_narg narg, cl_object p)
c/hash.c:_hash_eql(cl_hashkey h, cl_object x)
c/hash.c:_hash_equal(int depth, cl_hashkey h, cl_object x)
c/hash.c:    cl_object array = x->random.value;
c/hash.c:_hash_equalp(int depth, cl_hashkey h, cl_object x)
c/hash.c:static cl_hashkey _hash_generic(cl_object ht, cl_object key) {
c/hash.c:  cl_object hash_fun = ht->hash.generic_hash;
c/hash.c:  cl_object h_object = _ecl_funcall2(hash_fun, key);
c/hash.c:      cl_object hkey = e->key, hvalue = e->value;                       \
c/hash.c:_ecl_hash_loop_eq(cl_hashkey h, cl_object key, cl_object hashtable)
c/hash.c:static cl_object
c/hash.c:_ecl_gethash_eq(cl_object key, cl_object hashtable, cl_object def)
c/hash.c:_ecl_remhash_eq(cl_object key, cl_object hashtable)
c/hash.c:static cl_object
c/hash.c:_ecl_sethash_eq(cl_object key, cl_object hashtable, cl_object value)
c/hash.c:_ecl_hash_loop_eql(cl_hashkey h, cl_object key, cl_object hashtable)
c/hash.c:static cl_object
c/hash.c:_ecl_gethash_eql(cl_object key, cl_object hashtable, cl_object def)
c/hash.c:static cl_object
c/hash.c:_ecl_sethash_eql(cl_object key, cl_object hashtable, cl_object value)
c/hash.c:_ecl_remhash_eql(cl_object key, cl_object hashtable)
c/hash.c:_ecl_hash_loop_equal(cl_hashkey h, cl_object key, cl_object hashtable)
c/hash.c:static cl_object
c/hash.c:_ecl_gethash_equal(cl_object key, cl_object hashtable, cl_object def)
c/hash.c:static cl_object
c/hash.c:_ecl_sethash_equal(cl_object key, cl_object hashtable, cl_object value)
c/hash.c:_ecl_remhash_equal(cl_object key, cl_object hashtable)
c/hash.c:_ecl_hash_loop_equalp(cl_hashkey h, cl_object key, cl_object hashtable)
c/hash.c:static cl_object
c/hash.c:_ecl_gethash_equalp(cl_object key, cl_object hashtable, cl_object def)
c/hash.c:static cl_object
c/hash.c:_ecl_sethash_equalp(cl_object key, cl_object hashtable, cl_object value)
c/hash.c:_ecl_remhash_equalp(cl_object key, cl_object hashtable)
c/hash.c:_ecl_hash_loop_pack(cl_hashkey h, cl_object key, cl_object hashtable)
c/hash.c:  cl_object ho = ecl_make_fixnum(h & 0xFFFFFFF);
c/hash.c:static cl_object
c/hash.c:_ecl_gethash_pack(cl_object key, cl_object hashtable, cl_object def)
c/hash.c:static cl_object
c/hash.c:_ecl_sethash_pack(cl_object key, cl_object hashtable, cl_object value)
c/hash.c:_ecl_remhash_pack(cl_object key, cl_object hashtable)
c/hash.c:_ecl_generic_hash_test(cl_object fun, cl_object key, cl_object hkey) {
c/hash.c:_ecl_hash_loop_generic(cl_hashkey h, cl_object key, cl_object hashtable)
c/hash.c:  cl_object test_fun = hashtable->hash.generic_test;
c/hash.c:static cl_object
c/hash.c:_ecl_gethash_generic(cl_object key, cl_object hashtable, cl_object def)
c/hash.c:static cl_object
c/hash.c:_ecl_sethash_generic(cl_object key, cl_object hashtable, cl_object value)
c/hash.c:_ecl_remhash_generic(cl_object key, cl_object hashtable)
c/hash.c:_ecl_hash_key(cl_object h, cl_object o) {
c/hash.c:copy_entry(struct ecl_hashtable_entry *e, cl_object h)
c/hash.c:_ecl_weak_hash_loop(cl_hashkey h, cl_object key, cl_object hashtable,
c/hash.c:static cl_object
c/hash.c:_ecl_gethash_weak(cl_object key, cl_object hashtable, cl_object def)
c/hash.c:static cl_object
c/hash.c:_ecl_sethash_weak(cl_object key, cl_object hashtable, cl_object value)
c/hash.c:_ecl_remhash_weak(cl_object key, cl_object hashtable)
c/hash.c:static cl_object
c/hash.c:_ecl_sethash_sync(cl_object key, cl_object hashtable, cl_object value)
c/hash.c:  cl_object output = ECL_NIL;
c/hash.c:  cl_object sync_lock = hashtable->hash.sync_lock;
c/hash.c:static cl_object
c/hash.c:_ecl_gethash_sync(cl_object key, cl_object hashtable, cl_object def)
c/hash.c:  cl_object output = ECL_NIL;
c/hash.c:  cl_object sync_lock = hashtable->hash.sync_lock;
c/hash.c:_ecl_remhash_sync(cl_object key, cl_object hashtable)
c/hash.c:  cl_object sync_lock = hashtable->hash.sync_lock;
c/hash.c:cl_object
c/hash.c:ecl_gethash(cl_object key, cl_object hashtable)
c/hash.c:cl_object
c/hash.c:ecl_gethash_safe(cl_object key, cl_object hashtable, cl_object def)
c/hash.c:cl_object
c/hash.c:_ecl_sethash(cl_object key, cl_object hashtable, cl_object value)
c/hash.c:cl_object
c/hash.c:ecl_sethash(cl_object key, cl_object hashtable, cl_object value)
c/hash.c:cl_object
c/hash.c:ecl_extend_hashtable(cl_object hashtable)
c/hash.c:  cl_object old, new;
c/hash.c:  cl_object new_size_obj;
c/hash.c:cl_object cl_make_hash_table(cl_narg narg, ...)
c/hash.c:	static cl_object KEYS[7] = {(cl_object)(cl_symbols+1343), (cl_object)(cl_symbols+1266), (cl_object)(cl_symbols+2035), (cl_object)(cl_symbols+2037), (cl_object)(cl_symbols+1335), (cl_object)(cl_symbols+1324), (cl_object)(cl_symbols+1325)};
c/hash.c:	cl_object test;
c/hash.c:	cl_object hash_function;
c/hash.c:	cl_object weakness;
c/hash.c:	cl_object synchronized;
c/hash.c:	cl_object size;
c/hash.c:	cl_object rehash_size;
c/hash.c:	cl_object rehash_threshold;
c/hash.c:	cl_object KEY_VARS[14];
c/hash.c:    cl_object hash = cl__make_hash_table(test, size, rehash_size, rehash_threshold);
c/hash.c:	cl_object __value0 = hash;
c/hash.c:do_clrhash(cl_object ht)
c/hash.c:cl_object
c/hash.c:cl__make_hash_table(cl_object test, cl_object size, cl_object rehash_size,
c/hash.c:                    cl_object rehash_threshold)
c/hash.c:  cl_object h;
c/hash.c:  cl_object hash_test = ECL_NIL, hash_func = ECL_NIL;
c/hash.c:  cl_object (*get)(cl_object, cl_object, cl_object);
c/hash.c:  cl_object (*set)(cl_object, cl_object, cl_object);
c/hash.c:  bool (*rem)(cl_object, cl_object);
c/hash.c:ecl_reconstruct_serialized_hashtable(cl_object h) {
c/hash.c:cl_object
c/hash.c:cl_hash_table_p(cl_object ht)
c/hash.c:	cl_object __value0 = (ECL_HASH_TABLE_P(ht) ? ECL_T : ECL_NIL);
c/hash.c:cl_object
c/hash.c:si_hash_table_weakness(cl_object ht)
c/hash.c:  cl_object output = ECL_NIL;
c/hash.c:	cl_object __value0 = output;
c/hash.c:cl_object
c/hash.c:si_hash_table_synchronized_p(cl_object ht)
c/hash.c:cl_object cl_gethash(cl_narg narg, cl_object key, cl_object ht, ...)
c/hash.c:	cl_object no_value;
c/hash.c:		no_value = va_arg(ARGS,cl_object);
c/hash.c:      cl_object v = ht->hash.get(key, ht, OBJNULL);
c/hash.c:	cl_object __value0 = v;
c/hash.c:	cl_object __value1 = ECL_T;
c/hash.c:	cl_object __value0 = no_value;
c/hash.c:	cl_object __value1 = ECL_NIL;
c/hash.c:cl_object
c/hash.c:si_hash_set(cl_object key, cl_object ht, cl_object val)
c/hash.c:	cl_object __value0 = val;
c/hash.c:ecl_remhash(cl_object key, cl_object hashtable)
c/hash.c:cl_object
c/hash.c:cl_remhash(cl_object key, cl_object ht)
c/hash.c:	cl_object __value0 = (ecl_remhash(key, ht)? ECL_T : ECL_NIL);
c/hash.c:cl_object
c/hash.c:cl_clrhash(cl_object ht)
c/hash.c:	cl_object __value0 = ht;
c/hash.c:cl_object
c/hash.c:cl_hash_table_test(cl_object ht)
c/hash.c:  cl_object output;
c/hash.c:	cl_object __value0 = output;
c/hash.c:cl_object
c/hash.c:cl_hash_table_size(cl_object ht)
c/hash.c:	cl_object __value0 = ecl_make_fixnum(ht->hash.size);
c/hash.c:ecl_hash_table_count(cl_object ht)
c/hash.c:cl_object
c/hash.c:cl_hash_table_count(cl_object ht)
c/hash.c:	cl_object __value0 = (ecl_make_fixnum(ecl_hash_table_count(ht)));
c/hash.c:static cl_object
c/hash.c:  cl_object env = the_env->function->cclosure.env;
c/hash.c:  cl_object index = CAR(env);
c/hash.c:  cl_object ht = CADR(env);
c/hash.c:        cl_object ndx = ecl_make_fixnum(i);
c/hash.c:	cl_object __value0 = ndx;
c/hash.c:	cl_object __value1 = e.key;
c/hash.c:	cl_object __value2 = e.value;
c/hash.c:	cl_object __value0 = ECL_NIL;
c/hash.c:cl_object
c/hash.c:si_hash_table_iterator(cl_object ht)
c/hash.c:	cl_object __value0 = ecl_make_cclosure_va(si_hash_table_iterate,
c/hash.c:cl_object
c/hash.c:cl_hash_table_rehash_size(cl_object ht)
c/hash.c:	cl_object __value0 = ht->hash.rehash_size;
c/hash.c:cl_object
c/hash.c:cl_hash_table_rehash_threshold(cl_object ht)
c/hash.c:	cl_object __value0 = ht->hash.threshold;
c/hash.c:cl_object
c/hash.c:cl_sxhash(cl_object key)
c/hash.c:	cl_object __value0 = ecl_make_fixnum(output & mask);
c/hash.c:cl_object si_hash_eql(cl_narg narg, ...)
c/hash.c:    cl_object o = ecl_va_arg(args);
c/hash.c:	cl_object __value0 = ecl_make_fixnum(h);
c/hash.c:cl_object si_hash_equal(cl_narg narg, ...)
c/hash.c:    cl_object o = ecl_va_arg(args);
c/hash.c:	cl_object __value0 = ecl_make_fixnum(h);
c/hash.c:cl_object si_hash_equalp(cl_narg narg, ...)
c/hash.c:    cl_object o = ecl_va_arg(args);
c/hash.c:	cl_object __value0 = ecl_make_fixnum(h);
c/hash.c:cl_object
c/hash.c:cl_maphash(cl_object fun, cl_object ht)
c/hash.c:      cl_object key = e.key;
c/hash.c:      cl_object val = e.value;
c/hash.c:	cl_object __value0 = ECL_NIL;
c/hash.c:cl_object
c/hash.c:si_hash_table_content(cl_object ht)
c/hash.c:  cl_object output = ECL_NIL;
c/hash.c:	cl_object __value0 = output;
c/hash.c:cl_object
c/hash.c:si_hash_table_fill(cl_object ht, cl_object values)
c/hash.c:    cl_object pair = ecl_car(values);
c/hash.c:    cl_object key = ecl_car(pair);
c/hash.c:    cl_object value = ECL_CONS_CDR(pair);
c/hash.c:	cl_object __value0 = ht;
c/hash.c:cl_object
c/hash.c:si_copy_hash_table(cl_object orig)
c/hash.c:  cl_object hash;
c/hash.c:	cl_object __value0 = hash;
c/instance.c:cl_object
c/instance.c:ecl_allocate_instance(cl_object clas, cl_index size)
c/instance.c:  cl_object x = ecl_alloc_instance(size);
c/instance.c:cl_object
c/instance.c:si_allocate_raw_instance(cl_object orig, cl_object clas, cl_object size)
c/instance.c:  cl_object output = ecl_allocate_instance(clas, ecl_to_size(size));
c/instance.c:	cl_object __value0 = orig;
c/instance.c:cl_object
c/instance.c:si_instance_obsolete_p(cl_object x)
c/instance.c:cl_object
c/instance.c:si_instance_new_stamp(cl_object x)
c/instance.c:cl_object
c/instance.c:si_instance_get_stamp(cl_object x)
c/instance.c:  cl_object a = ecl_make_fixnum(x->instance.stamp);
c/instance.c:  cl_object b = ecl_make_fixnum(ECL_CLASS_OF(x)->instance.class_stamp);
c/instance.c:	cl_object __value0 = a;
c/instance.c:	cl_object __value1 = b;
c/instance.c:cl_object
c/instance.c:si_instance_slotds(cl_object x)
c/instance.c:	cl_object __value0 = x->instance.slotds;
c/instance.c:cl_object
c/instance.c:si_instance_sig_set(cl_object x)
c/instance.c:	cl_object __value0 = (x->instance.slotds = ECL_CLASS_SLOTS(ECL_CLASS_OF(x)));
c/instance.c:cl_object
c/instance.c:si_instance_class(cl_object x)
c/instance.c:	cl_object __value0 = ECL_CLASS_OF(x);
c/instance.c:cl_object
c/instance.c:si_instance_class_set(cl_object x, cl_object y)
c/instance.c:	cl_object __value0 = x;
c/instance.c:cl_object
c/instance.c:ecl_instance_ref(cl_object x, cl_fixnum i)
c/instance.c:cl_object
c/instance.c:si_instance_ref(cl_object x, cl_object index)
c/instance.c:	cl_object __value0 = x->instance.slots[i];
c/instance.c:cl_object
c/instance.c:clos_safe_instance_ref(cl_object x, cl_object index)
c/instance.c:	cl_object __value0 = x;
c/instance.c:cl_object
c/instance.c:ecl_instance_set(cl_object x, cl_fixnum i, cl_object v)
c/instance.c:cl_object
c/instance.c:si_instance_set(cl_object x, cl_object index, cl_object value)
c/instance.c:	cl_object __value0 = value;
c/instance.c:cl_object
c/instance.c:ecl_compare_and_swap_instance(cl_object x, cl_fixnum i, cl_object old, cl_object new)
c/instance.c:cl_object
c/instance.c:mp_compare_and_swap_instance(cl_object x, cl_object index, cl_object old, cl_object new)
c/instance.c:cl_object
c/instance.c:ecl_atomic_incf_instance(cl_object x, cl_fixnum i, cl_object increment)
c/instance.c:cl_object
c/instance.c:mp_atomic_incf_instance(cl_object x, cl_object index, cl_object increment)
c/instance.c:cl_object
c/instance.c:si_instancep(cl_object x)
c/instance.c:	cl_object __value0 = (ECL_INSTANCEP(x) ? ecl_make_fixnum(x->instance.length) : ECL_NIL);
c/instance.c:cl_object
c/instance.c:	cl_object __value0 = ECL_UNBOUND;
c/instance.c:cl_object
c/instance.c:si_sl_boundp(cl_object x)
c/instance.c:	cl_object __value0 = ((x == ECL_UNBOUND) ? ECL_NIL : ECL_T);
c/instance.c:cl_object
c/instance.c:si_sl_makunbound(cl_object x, cl_object index)
c/instance.c:	cl_object __value0 = x;
c/instance.c:cl_object
c/instance.c:si_copy_instance(cl_object x)
c/instance.c:  cl_object y;
c/instance.c:         x->instance.length * sizeof(cl_object));
c/instance.c:	cl_object __value0 = y;
c/instance.c:cl_object cl_find_class(cl_narg narg, cl_object name, ...)
c/instance.c:  cl_object class, hash;
c/instance.c:	cl_object errorp;
c/instance.c:	cl_object env;
c/instance.c:		errorp = va_arg(ARGS,cl_object);
c/instance.c:		env = va_arg(ARGS,cl_object);
c/instance.c:	cl_object __value0 = class;
c/instance.c:cl_object
c/instance.c:ecl_slot_value(cl_object x, const char *slot)
c/instance.c:  cl_object slot_name = ecl_read_from_cstring(slot);
c/instance.c:cl_object
c/instance.c:ecl_slot_value_set(cl_object x, const char *slot, cl_object value)
c/instance.c:  cl_object slot_name = ecl_read_from_cstring(slot);
c/instance.c:  cl_object slot_setter = ecl_read_from_cstring("(SETF SLOT-VALUE)");
c/instance.c:cl_object
c/instance.c:cl_class_of(cl_object x)
c/instance.c:	cl_object __value0 = ECL_CLASS_OF(x);
c/instance.c:    cl_object v = ECL_SYM("CLOS::+BUILTIN-CLASSES+",1535)->symbol.value;
c/instance.c:    cl_object output = Null(v)?
c/instance.c:	cl_object __value0 = output;
c/integer_to_string.c:static cl_object
c/integer_to_string.c:bignum_to_string(cl_object buffer, cl_object x, cl_object base)
c/integer_to_string.c:write_base_prefix(cl_object buffer, int base)
c/integer_to_string.c:cl_object
c/integer_to_string.c:si_integer_to_string(cl_object buffer, cl_object integer,
c/integer_to_string.c:                     cl_object base, cl_object radix, cl_object decimalp)
c/integer_to_string.c:	cl_object __value0 = buffer;
c/integer_to_string.c:                cl_object big = _ecl_big_register0();
c/interpreter.c:cl_object *
c/interpreter.c:  cl_object *new_stack, *old_stack;
c/interpreter.c:  new_stack = (cl_object *)ecl_alloc_atomic(new_size * sizeof(cl_object));
c/interpreter.c:  memcpy(new_stack, old_stack, env->stack_size * sizeof(cl_object));
c/interpreter.c:cl_object *
c/interpreter.c:  cl_object *b = env->stack_top;
c/interpreter.c:  cl_object *p = b + i;
c/interpreter.c:  memcpy(b, env->values, i * sizeof(cl_object));
c/interpreter.c:  cl_object *p = env->stack_top - n;
c/interpreter.c:  memcpy(env->values, p, n * sizeof(cl_object));
c/interpreter.c:cl_object
c/interpreter.c:ecl_stack_frame_open(cl_env_ptr env, cl_object f, cl_index size)
c/interpreter.c:  cl_object *base = env->stack_top;
c/interpreter.c:ecl_stack_frame_push(cl_object f, cl_object o)
c/interpreter.c:  cl_object *top = env->stack_top;
c/interpreter.c:ecl_stack_frame_push_values(cl_object f)
c/interpreter.c:cl_object
c/interpreter.c:ecl_stack_frame_pop_values(cl_object f)
c/interpreter.c:  cl_object o;
c/interpreter.c:ecl_stack_frame_close(cl_object f)
c/interpreter.c:static cl_object
c/interpreter.c:ecl_lex_env_get_record(register cl_object env, register int s)
c/interpreter.c:cl_object
c/interpreter.c:  cl_object output;
c/interpreter.c:cl_object
c/interpreter.c:  cl_object output;
c/interpreter.c:    cl_object fun = frame->frame.env->function;
c/interpreter.c:cl_object
c/interpreter.c:ecl_close_around(cl_object fun, cl_object lex) {
c/interpreter.c:  cl_object v;
c/interpreter.c:    reg0 = ecl_apply_from_stack_frame((cl_object)&frame, fun);  \
c/interpreter.c:static void too_many_arguments(cl_object bytecodes, cl_object frame) ecl_attr_noreturn;
c/interpreter.c:static void odd_number_of_keywords(cl_object bytecodes) ecl_attr_noreturn;
c/interpreter.c:static void unknown_keyword(cl_object bytecodes, cl_object frame) ecl_attr_noreturn;
c/interpreter.c:too_many_arguments(register cl_object bytecodes, register cl_object frame)
c/interpreter.c:odd_number_of_keywords(register cl_object bytecodes)
c/interpreter.c:unknown_keyword(register cl_object bytecodes, register cl_object frame)
c/interpreter.c:cl_object
c/interpreter.c:ecl_interpret(cl_object frame, cl_object env, cl_object bytecodes)
c/interpreter.c:  cl_object *data = bytecodes->bytecodes.data->vector.self.t;
c/interpreter.c:  cl_object reg0 = ECL_NIL, reg1 = ECL_NIL, lex_env = env;
c/interpreter.c:      cl_object var_name;
c/interpreter.c:      cl_object car = ECL_STACK_POP_UNSAFE(the_env);
c/interpreter.c:      cl_object var_name, value;
c/interpreter.c:      cl_object aux;
c/interpreter.c:      cl_object s;
c/interpreter.c:      cl_objectfn f;
c/interpreter.c:      cl_object s;
c/interpreter.c:      cl_objectfn f;
c/interpreter.c:      cl_object x = reg0;
c/interpreter.c:      cl_object frame = (cl_object)&frame_aux;
c/interpreter.c:      cl_object *first = frame->frame.base + frame_index;
c/interpreter.c:      cl_object *last = frame->frame.base + frame->frame.size;
c/interpreter.c:      cl_object keys_list, aok, *first, *last;
c/interpreter.c:        cl_object name = ECL_CONS_CAR(keys_list);
c/interpreter.c:        cl_object flag = ECL_NIL;
c/interpreter.c:        cl_object value = ECL_NIL;
c/interpreter.c:        cl_object *p = first;
c/interpreter.c:          cl_object *p = first;
c/interpreter.c:      cl_object old_lex;
c/interpreter.c:        cl_object f;
c/interpreter.c:          cl_object f;
c/interpreter.c:        cl_object l = lex_env;
c/interpreter.c:      cl_object block_record;
c/interpreter.c:      cl_object tag_name = ECL_STACK_POP_UNSAFE(the_env);
c/interpreter.c:      cl_object var_name;
c/interpreter.c:      cl_object var_name;
c/interpreter.c:      cl_object var_name;
c/interpreter.c:      cl_object var_name;
c/interpreter.c:      cl_object var_name;
c/interpreter.c:      cl_object var_name;
c/interpreter.c:      cl_object var;
c/interpreter.c:      cl_object var;
c/interpreter.c:      cl_object var, v;
c/interpreter.c:      ECL_STACK_PUSH(the_env, (cl_object)exit);
c/interpreter.c:      ECL_STACK_PUSH(the_env, (cl_object)vector); /* FIXME! */
c/interpreter.c:      memcpy(&ECL_STACK_REF(the_env, -(i+1)), the_env->values, i * sizeof(cl_object));
c/interpreter.c:      memcpy(&ECL_STACK_REF(the_env, -(i+1)), the_env->values, i * sizeof(cl_object));
c/interpreter.c:      cl_object *dest = the_env->values;
c/interpreter.c:        memcpy(dest, &ECL_STACK_REF(the_env,0), n * sizeof(cl_object));
c/interpreter.c:      memcpy(the_env->values, &ECL_STACK_REF(the_env, 0), n * sizeof(cl_object));
c/interpreter.c:      ECL_STACK_PUSH(the_env, (cl_object)exit);
c/interpreter.c:      cl_object values = reg0;
c/interpreter.c:      cl_object vars = ECL_STACK_POP_UNSAFE(the_env);
c/interpreter.c:      cl_object *p;
c/interpreter.c:      cl_object form;
c/interpreter.c:      cl_object a = ECL_SYM_VAL(the_env, ECL_SYM("SI::*STEP-ACTION*",1034));
c/interpreter.c:      cl_object a = ECL_SYM_VAL(the_env, ECL_SYM("SI::*STEP-ACTION*",1034));
c/interpreter.c:cl_object si_interpreter_stack(cl_narg narg, ...)
c/interpreter.c:	cl_object __value0 = ECL_NIL;
c/libraries.c:cl_object
c/libraries.c:  cl_object block = ecl_alloc(t_codeblock);
c/libraries.c:static cl_object
c/libraries.c:copy_object_file(cl_object original)
c/libraries.c:  cl_object copy = ecl_make_constant_base_string("TMP:ECL",-1);
c/libraries.c:    cl_object new_copy = ecl_make_constant_base_string(".dll",-1);
c/libraries.c:set_library_error(cl_object block) {
c/libraries.c:  cl_object output;
c/libraries.c:dlopen_wrapper(cl_object block)
c/libraries.c:  cl_object filename = block->cblock.name;
c/libraries.c:dlclose_wrapper(cl_object block)
c/libraries.c:static cl_object
c/libraries.c:ecl_library_find_by_name(cl_object filename)
c/libraries.c:  cl_object l;
c/libraries.c:    cl_object other = ECL_CONS_CAR(l);
c/libraries.c:    cl_object name = other->cblock.name;
c/libraries.c:static cl_object
c/libraries.c:  cl_object l;
c/libraries.c:    cl_object other = ECL_CONS_CAR(l);
c/libraries.c:static cl_object
c/libraries.c:ecl_library_open_inner(cl_object filename, bool self_destruct)
c/libraries.c:  cl_object block = ecl_make_codeblock();
c/libraries.c:      cl_object other = ecl_library_find_by_handle(block->cblock.handle);
c/libraries.c:cl_object
c/libraries.c:ecl_library_open(cl_object filename, bool force_reload) {
c/libraries.c:  cl_object block;
c/libraries.c:ecl_library_symbol(cl_object block, const char *symbol, bool lock) {
c/libraries.c:    cl_object l;
c/libraries.c:      cl_object block = ECL_CONS_CAR(l);
c/libraries.c:cl_object
c/libraries.c:ecl_library_error(cl_object block) {
c/libraries.c:ecl_library_close(cl_object block) {
c/libraries.c:cl_object
c/libraries.c:cl_object
c/list.c:  bool (*test_c_function)(struct cl_test *, cl_object);
c/list.c:  cl_object (*key_c_function)(struct cl_test *, cl_object);
c/list.c:  cl_object key_function;
c/list.c:  cl_objectfn key_fn;
c/list.c:  cl_object test_function;
c/list.c:  cl_objectfn test_fn;
c/list.c:  cl_object item_compared;
c/list.c:static cl_object subst(struct cl_test *t, cl_object new_obj, cl_object tree);
c/list.c:static cl_object nsubst(struct cl_test *t, cl_object new_obj, cl_object tree);
c/list.c:static cl_object sublis(struct cl_test *t, cl_object alist, cl_object tree);
c/list.c:static cl_object nsublis(struct cl_test *t, cl_object alist, cl_object tree);
c/list.c:static cl_object do_assoc(struct cl_test *t, cl_object alist);
c/list.c:test_compare(struct cl_test *t, cl_object x)
c/list.c:test_compare_not(struct cl_test *t, cl_object x)
c/list.c:test_eq(struct cl_test *t, cl_object x)
c/list.c:test_eql(struct cl_test *t, cl_object x)
c/list.c:test_equal(struct cl_test *t, cl_object x)
c/list.c:test_equalp(struct cl_test *t, cl_object x)
c/list.c:static cl_object
c/list.c:key_function(struct cl_test *t, cl_object x)
c/list.c:static cl_object
c/list.c:key_identity(struct cl_test *t, cl_object x)
c/list.c:setup_test(struct cl_test *t, cl_object item, cl_object test,
c/list.c:           cl_object test_not, cl_object key)
c/list.c:cl_object cl_list(cl_narg narg, ...)
c/list.c:  cl_object head = ECL_NIL;
c/list.c:    cl_object tail = head = ecl_list1(ecl_va_arg(args));
c/list.c:      cl_object cons = ecl_list1(ecl_va_arg(args));
c/list.c:	cl_object __value0 = head;
c/list.c:cl_object cl_listX(cl_narg narg, ...)
c/list.c:  cl_object head;
c/list.c:    cl_object tail = head = ecl_list1(head);
c/list.c:      cl_object cons = ecl_list1(ecl_va_arg(args));
c/list.c:	cl_object __value0 = head;
c/list.c:static cl_object *
c/list.c:append_into(cl_object head, cl_object *tail, cl_object l)
c/list.c:    cl_object cons = ecl_list1(ECL_CONS_CAR(l));
c/list.c:cl_object cl_append(cl_narg narg, ...)
c/list.c:  cl_object head = ECL_NIL, *tail = &head;
c/list.c:    cl_object other = ecl_va_arg(rest);
c/list.c:	cl_object __value0 = head;
c/list.c:cl_object
c/list.c:ecl_append(cl_object x, cl_object y)
c/list.c:  cl_object head = ECL_NIL;
c/list.c:  cl_object *tail = &head;
c/list.c:#define LENTH(n) (cl_object x) {                        \
c/list.c:cl_object cl_fifth        LENTH(4)
c/list.c:cl_object cl_sixth        LENTH(5)
c/list.c:cl_object cl_seventh      LENTH(6)
c/list.c:cl_object cl_eighth       LENTH(7)
c/list.c:cl_object cl_ninth        LENTH(8)
c/list.c:cl_object cl_tenth        LENTH(9)
c/list.c:tree_equal(struct cl_test *t, cl_object x, cl_object y)
c/list.c:cl_object cl_tree_equal(cl_narg narg, cl_object x, cl_object y, ...)
c/list.c:  cl_object output;
c/list.c:	static cl_object KEYS[2] = {(cl_object)(cl_symbols+1343), (cl_object)(cl_symbols+1344)};
c/list.c:	cl_object test;
c/list.c:	cl_object test_not;
c/list.c:	cl_object KEY_VARS[4];
c/list.c:	cl_object __value0 = output;
c/list.c:cl_object
c/list.c:cl_endp(cl_object x)
c/list.c:  cl_object output = ECL_NIL;
c/list.c:	cl_object __value0 = output;
c/list.c:ecl_endp(cl_object x)
c/list.c:cl_object
c/list.c:cl_list_length(cl_object x)
c/list.c:  cl_object fast, slow;
c/list.c:	cl_object __value0 = ECL_NIL;
c/list.c:	cl_object __value0 = ecl_make_fixnum(n);
c/list.c:cl_object
c/list.c:si_proper_list_p(cl_object x)
c/list.c:  cl_object fast, slow, test = ECL_T;
c/list.c:	cl_object __value0 = test;
c/list.c:cl_object
c/list.c:cl_nth(cl_object n, cl_object x)
c/list.c:	cl_object __value0 = ecl_nth(ecl_to_size(n), x);
c/list.c:cl_object
c/list.c:ecl_nth(cl_fixnum n, cl_object x)
c/list.c:cl_object
c/list.c:cl_nthcdr(cl_object n, cl_object x)
c/list.c:	cl_object __value0 = ecl_nthcdr(ecl_to_size(n), x);
c/list.c:cl_object
c/list.c:ecl_nthcdr(cl_fixnum n, cl_object x)
c/list.c:cl_object
c/list.c:ecl_last(cl_object l, cl_index n)
c/list.c:  cl_object r;
c/list.c:cl_object cl_last(cl_narg narg, cl_object l, ...)
c/list.c:	cl_object k;
c/list.c:		k = va_arg(ARGS,cl_object);
c/list.c:	cl_object __value0 = l;
c/list.c:	cl_object __value0 = ecl_last(l, ecl_to_size(k));
c/list.c:cl_object cl_make_list(cl_narg narg, cl_object size, ...)
c/list.c:	static cl_object KEYS[1] = {(cl_object)(cl_symbols+1277)};
c/list.c:	cl_object initial_element;
c/list.c:	cl_object x;
c/list.c:	cl_object KEY_VARS[2];
c/list.c:	cl_object __value0 = x;
c/list.c:cl_object
c/list.c:cl_copy_list(cl_object x)
c/list.c:  cl_object copy;
c/list.c:    cl_object tail = copy = ecl_list1(CAR(x));
c/list.c:      cl_object cons = ecl_list1(ECL_CONS_CAR(x));
c/list.c:	cl_object __value0 = copy;
c/list.c:static cl_object
c/list.c:duplicate_pairs(cl_object x)
c/list.c:  cl_object p = ECL_CONS_CAR(x);
c/list.c:cl_object
c/list.c:cl_copy_alist(cl_object x)
c/list.c:  cl_object copy;
c/list.c:    cl_object tail = copy = duplicate_pairs(x);
c/list.c:        cl_object cons = duplicate_pairs(x);
c/list.c:	cl_object __value0 = copy;
c/list.c:static cl_object
c/list.c:do_copy_tree(cl_object x)
c/list.c:cl_object
c/list.c:cl_copy_tree(cl_object x)
c/list.c:	cl_object __value0 = do_copy_tree(x);
c/list.c:cl_object
c/list.c:cl_revappend(cl_object x, cl_object y)
c/list.c:	cl_object __value0 = y;
c/list.c:cl_object cl_nconc(cl_narg narg, ...)
c/list.c:  cl_object head = ECL_NIL, tail = ECL_NIL;
c/list.c:    cl_object new_tail, other = ecl_va_arg(lists);
c/list.c:	cl_object __value0 = head;
c/list.c:cl_object
c/list.c:ecl_nconc(cl_object l, cl_object y)
c/list.c:cl_object
c/list.c:cl_nreconc(cl_object l, cl_object y)
c/list.c:  cl_object x, z;
c/list.c:	cl_object __value0 = y;
c/list.c:cl_object
c/list.c:ecl_butlast(cl_object l, cl_index n)
c/list.c:  cl_object r;
c/list.c:    cl_object head, tail;
c/list.c:      cl_object cons = ecl_list1(ECL_CONS_CAR(l));
c/list.c:cl_object cl_butlast(cl_narg narg, cl_object lis, ...)
c/list.c:	cl_object nn;
c/list.c:		nn = va_arg(ARGS,cl_object);
c/list.c:	cl_object __value0 = ECL_NIL;
c/list.c:	cl_object __value0 = ecl_butlast(lis, ecl_to_size(nn));
c/list.c:cl_object
c/list.c:ecl_nbutlast(cl_object l, cl_index n)
c/list.c:  cl_object r;
c/list.c:    cl_object tail = l;
c/list.c:cl_object cl_nbutlast(cl_narg narg, cl_object lis, ...)
c/list.c:	cl_object nn;
c/list.c:		nn = va_arg(ARGS,cl_object);
c/list.c:	cl_object __value0 = ECL_NIL;
c/list.c:	cl_object __value0 = ecl_nbutlast(lis, ecl_to_size(nn));
c/list.c:cl_object
c/list.c:cl_ldiff(cl_object x, cl_object y)
c/list.c:  cl_object head = ECL_NIL;
c/list.c:    cl_object tail = head = ecl_list1(ECL_CONS_CAR(x));
c/list.c:        cl_object cons = ecl_list1(ECL_CONS_CAR(x));
c/list.c:	cl_object __value0 = head;
c/list.c:cl_object
c/list.c:cl_rplaca(cl_object x, cl_object v)
c/list.c:	cl_object __value0 = x;
c/list.c:cl_object
c/list.c:cl_rplacd(cl_object x, cl_object v)
c/list.c:	cl_object __value0 = x;
c/list.c:cl_object
c/list.c:mp_compare_and_swap_car(cl_object x, cl_object old, cl_object new)
c/list.c:cl_object
c/list.c:mp_atomic_incf_car(cl_object x, cl_object increment)
c/list.c:cl_object
c/list.c:mp_compare_and_swap_cdr(cl_object x, cl_object old, cl_object new)
c/list.c:cl_object
c/list.c:mp_atomic_incf_cdr(cl_object x, cl_object increment)
c/list.c:cl_object cl_subst(cl_narg narg, cl_object new_obj, cl_object old_obj, cl_object tree, ...)
c/list.c:  cl_object output;
c/list.c:	static cl_object KEYS[3] = {(cl_object)(cl_symbols+1343), (cl_object)(cl_symbols+1344), (cl_object)(cl_symbols+1288)};
c/list.c:	cl_object test;
c/list.c:	cl_object test_not;
c/list.c:	cl_object key;
c/list.c:	cl_object KEY_VARS[6];
c/list.c:	cl_object __value0 = output;
c/list.c:static cl_object
c/list.c:subst(struct cl_test *t, cl_object new_obj, cl_object tree)
c/list.c:    cl_object head, tail = ECL_NIL;
c/list.c:      cl_object cons = subst(t, new_obj, ECL_CONS_CAR(tree));
c/list.c:cl_object cl_nsubst(cl_narg narg, cl_object new_obj, cl_object old_obj, cl_object tree, ...)
c/list.c:	static cl_object KEYS[3] = {(cl_object)(cl_symbols+1343), (cl_object)(cl_symbols+1344), (cl_object)(cl_symbols+1288)};
c/list.c:	cl_object test;
c/list.c:	cl_object test_not;
c/list.c:	cl_object key;
c/list.c:	cl_object KEY_VARS[6];
c/list.c:	cl_object __value0 = tree;
c/list.c:static cl_object
c/list.c:nsubst_cons(struct cl_test *t, cl_object new_obj, cl_object tree)
c/list.c:  cl_object l = tree;
c/list.c:    cl_object o = ECL_CONS_CAR(l);
c/list.c:static cl_object
c/list.c:nsubst(struct cl_test *t, cl_object new_obj, cl_object tree)
c/list.c:cl_object cl_sublis(cl_narg narg, cl_object alist, cl_object tree, ...)
c/list.c:	static cl_object KEYS[3] = {(cl_object)(cl_symbols+1343), (cl_object)(cl_symbols+1344), (cl_object)(cl_symbols+1288)};
c/list.c:	cl_object test;
c/list.c:	cl_object test_not;
c/list.c:	cl_object key;
c/list.c:	cl_object KEY_VARS[6];
c/list.c:	cl_object __value0 = tree;
c/list.c:static cl_object
c/list.c:sublis(struct cl_test *t, cl_object alist, cl_object tree)
c/list.c:  cl_object node;
c/list.c:cl_object cl_nsublis(cl_narg narg, cl_object alist, cl_object tree, ...)
c/list.c:	static cl_object KEYS[3] = {(cl_object)(cl_symbols+1343), (cl_object)(cl_symbols+1344), (cl_object)(cl_symbols+1288)};
c/list.c:	cl_object test;
c/list.c:	cl_object test_not;
c/list.c:	cl_object key;
c/list.c:	cl_object KEY_VARS[6];
c/list.c:	cl_object __value0 = tree;
c/list.c:static cl_object
c/list.c:nsublis(struct cl_test *t, cl_object alist, cl_object tree)
c/list.c:  cl_object node;
c/list.c:cl_object cl_member(cl_narg narg, cl_object item, cl_object list, ...)
c/list.c:	static cl_object KEYS[3] = {(cl_object)(cl_symbols+1343), (cl_object)(cl_symbols+1344), (cl_object)(cl_symbols+1288)};
c/list.c:	cl_object test;
c/list.c:	cl_object test_not;
c/list.c:	cl_object key;
c/list.c:	cl_object KEY_VARS[6];
c/list.c:	cl_object __value0 = list;
c/list.c:ecl_member_eq(cl_object x, cl_object l)
c/list.c:cl_object
c/list.c:si_memq(cl_object x, cl_object l)
c/list.c:	cl_object __value0 = l;
c/list.c:	cl_object __value0 = ECL_NIL;
c/list.c:cl_object
c/list.c:ecl_memql(cl_object x, cl_object l)
c/list.c:cl_object
c/list.c:ecl_member(cl_object x, cl_object l)
c/list.c:cl_object
c/list.c:si_member1(cl_object item, cl_object list, cl_object test, cl_object test_not, cl_object key)
c/list.c:	cl_object __value0 = list;
c/list.c:cl_object
c/list.c:cl_tailp(cl_object y, cl_object x)
c/list.c:	cl_object __value0 = ECL_T;
c/list.c:cl_object cl_adjoin(cl_narg narg, cl_object item, cl_object list, ...)
c/list.c:  cl_object output;
c/list.c:	static cl_object KEYS[3] = {(cl_object)(cl_symbols+1343), (cl_object)(cl_symbols+1344), (cl_object)(cl_symbols+1288)};
c/list.c:	cl_object test;
c/list.c:	cl_object test_not;
c/list.c:	cl_object key;
c/list.c:	cl_object KEY_VARS[6];
c/list.c:	cl_object __value0 = output;
c/list.c:cl_object
c/list.c:cl_cons(cl_object x, cl_object y)
c/list.c:	cl_object __value0 = CONS(x, y);
c/list.c:cl_object
c/list.c:cl_acons(cl_object x, cl_object y, cl_object z)
c/list.c:	cl_object __value0 = CONS(CONS(x, y), z);
c/list.c:cl_object cl_pairlis(cl_narg narg, cl_object keys, cl_object data, ...)
c/list.c:  cl_object k, d;
c/list.c:	cl_object a_list;
c/list.c:		a_list = va_arg(ARGS,cl_object);
c/list.c:	cl_object __value0 = a_list;
c/list.c:cl_object cl_assoc(cl_narg narg, cl_object item, cl_object a_list, ...)
c/list.c:	static cl_object KEYS[3] = {(cl_object)(cl_symbols+1343), (cl_object)(cl_symbols+1344), (cl_object)(cl_symbols+1288)};
c/list.c:	cl_object test;
c/list.c:	cl_object test_not;
c/list.c:	cl_object key;
c/list.c:	cl_object KEY_VARS[6];
c/list.c:	cl_object __value0 = a_list;
c/list.c:static cl_object
c/list.c:do_assoc(struct cl_test *t, cl_object a_list)
c/list.c:    cl_object pair = ECL_CONS_CAR(a_list);
c/list.c:cl_object cl_rassoc(cl_narg narg, cl_object item, cl_object a_list, ...)
c/list.c:	static cl_object KEYS[3] = {(cl_object)(cl_symbols+1343), (cl_object)(cl_symbols+1344), (cl_object)(cl_symbols+1288)};
c/list.c:	cl_object test;
c/list.c:	cl_object test_not;
c/list.c:	cl_object key;
c/list.c:	cl_object KEY_VARS[6];
c/list.c:    cl_object pair = ECL_CONS_CAR(a_list);
c/list.c:	cl_object __value0 = a_list;
c/list.c:cl_object
c/list.c:ecl_remove_eq(cl_object x, cl_object l)
c/list.c:  cl_object head = ECL_NIL, tail = ECL_NIL;
c/list.c:      cl_object cons = ecl_list1(ECL_CONS_CAR(l));
c/list.c:cl_object
c/list.c:ecl_delete_eq(cl_object x, cl_object l)
c/list.c:  cl_object head = l;
c/list.c:  cl_object *p = &head;
c/list.c:cl_object
c/list.c:ecl_assq(cl_object x, cl_object l)
c/list.c:    cl_object pair = ECL_CONS_CAR(l);
c/list.c:cl_object
c/list.c:ecl_assql(cl_object x, cl_object l)
c/list.c:    cl_object pair = ECL_CONS_CAR(l);
c/list.c:cl_object
c/list.c:ecl_assoc(cl_object x, cl_object l)
c/list.c:    cl_object pair = ECL_CONS_CAR(l);
c/list.c:cl_object
c/list.c:ecl_assqlp(cl_object x, cl_object l)
c/list.c:    cl_object pair = ECL_CONS_CAR(l);
c/load.c:cl_object
c/load.c:si_load_binary(cl_object filename, cl_object verbose,
c/load.c:               cl_object print, cl_object external_format)
c/load.c:  cl_object block;
c/load.c:  cl_object basename;
c/load.c:  cl_object init_prefix, prefix;
c/load.c:  cl_object output;
c/load.c:  ecl_init_module(block, (void (*)(cl_object))(block->cblock.entry));
c/load.c:cl_object
c/load.c:si_load_source(cl_object source, cl_object verbose, cl_object print, cl_object external_format)
c/load.c:  cl_object x, strm;
c/load.c:	cl_object __value0 = ECL_NIL;
c/load.c:    cl_object form_index = ecl_make_fixnum(0);
c/load.c:    cl_object pathname = ECL_SYM_VAL(the_env, ECL_SYM("*LOAD-PATHNAME*",38));
c/load.c:    cl_object location = CONS(pathname, form_index);
c/load.c:	cl_object __value0 = ECL_NIL;
c/load.c:cl_object
c/load.c:si_load_bytecodes(cl_object source, cl_object verbose, cl_object print, cl_object external_format)
c/load.c:  cl_object forms, strm;
c/load.c:  cl_object old_eptbc = env->packages_to_be_created;
c/load.c:	cl_object __value0 = ECL_NIL;
c/load.c:      cl_object progv_list = ECL_SYM_VAL(env, ECL_SYM("SI::+ECL-SYNTAX-PROGV-LIST+",1778));
c/load.c:        cl_object x = ECL_CONS_CAR(forms);
c/load.c:      cl_object x;
c/load.c:	cl_object __value0 = ECL_NIL;
c/load.c:cl_object cl_load(cl_narg narg, cl_object source, ...)
c/load.c:	static cl_object KEYS[5] = {(cl_object)(cl_symbols+1353), (cl_object)(cl_symbols+1317), (cl_object)(cl_symbols+1268), (cl_object)(cl_symbols+1258), (cl_object)(cl_symbols+1332)};
c/load.c:	cl_object verbose;
c/load.c:	cl_object print;
c/load.c:	cl_object if_does_not_exist;
c/load.c:	cl_object external_format;
c/load.c:	cl_object search_list;
c/load.c:	cl_object pathname;
c/load.c:	cl_object pntype;
c/load.c:	cl_object hooks;
c/load.c:	cl_object filename;
c/load.c:	cl_object function;
c/load.c:	cl_object ok;
c/load.c:	cl_object KEY_VARS[10];
c/load.c:        cl_object d = CAR(search_list);
c/load.c:        cl_object f = cl_merge_pathnames(2, pathname, d);
c/load.c:        cl_object ok = cl_load(11, f, ECL_SYM(":VERBOSE",1353), verbose,
c/load.c:	cl_object __value0 = ok;
c/load.c:    cl_object kind;
c/load.c:      cl_object kind;
c/load.c:	cl_object __value0 = ECL_NIL;
c/load.c:	cl_object __value0 = filename;
c/log.c:static cl_object
c/log.c:ecl_log1_complex_inner(cl_object r, cl_object i)
c/log.c:  cl_object a = ecl_abs(r);
c/log.c:  cl_object p = ecl_abs(i);
c/log.c:    cl_object aux = p;
c/log.c:static cl_object
c/log.c:ecl_log1_bignum(cl_object x)
c/log.c:    cl_object result = ecl_alloc_object(t_csfloat);
c/log.c:    cl_object r = ecl_make_ratio(x, ecl_ash(ecl_make_fixnum(1), l));
c/log.c:static cl_object
c/log.c:ecl_log1_simple(cl_object x)
c/log.c:    cl_object result = ecl_alloc_object(t_csfloat);
c/log.c:static cl_object
c/log.c:ecl_log1_single_float(cl_object x)
c/log.c:    cl_object result = ecl_alloc_object(t_csfloat);
c/log.c:static cl_object
c/log.c:ecl_log1_double_float(cl_object x)
c/log.c:    cl_object result = ecl_alloc_object(t_cdfloat);
c/log.c:static cl_object
c/log.c:ecl_log1_long_float(cl_object x)
c/log.c:    cl_object result = ecl_alloc_object(t_clfloat);
c/log.c:static cl_object
c/log.c:ecl_log1_complex(cl_object x)
c/log.c:  cl_object result = ecl_alloc_object(t_csfloat);
c/log.c:static cl_object
c/log.c:ecl_log1_csfloat(cl_object x)
c/log.c:  cl_object result = ecl_alloc_object(t_csfloat);
c/log.c:static cl_object
c/log.c:ecl_log1_cdfloat(cl_object x)
c/log.c:  cl_object result = ecl_alloc_object(t_cdfloat);
c/log.c:static cl_object
c/log.c:ecl_log1_clfloat(cl_object x)
c/log.c:  cl_object result = ecl_alloc_object(t_clfloat);
c/log.c:cl_object
c/log.c:ecl_log2(cl_object x, cl_object y)
c/log.c:cl_object cl_log(cl_narg narg, cl_object x, ...)
c/log.c:	cl_object y;
c/log.c:		y = va_arg(ARGS,cl_object);
c/log.c:	cl_object __value0 = ecl_log1(x);
c/log.c:	cl_object __value0 = ecl_log2(y, x);
c/log.c:cl_object
c/log.c:si_log1p(cl_object x)
c/log.c:	cl_object __value0 = ecl_log1p(x);
c/log.c:static cl_object
c/log.c:ecl_log1p_simple(cl_object x)
c/log.c:    cl_object result = ecl_alloc_object(t_csfloat);
c/log.c:static cl_object
c/log.c:ecl_log1p_single_float(cl_object x)
c/log.c:    cl_object result = ecl_alloc_object(t_csfloat);
c/log.c:static cl_object
c/log.c:ecl_log1p_double_float(cl_object x)
c/log.c:    cl_object result = ecl_alloc_object(t_cdfloat);
c/log.c:static cl_object
c/log.c:ecl_log1p_long_float(cl_object x)
c/log.c:    cl_object result = ecl_alloc_object(t_clfloat);
c/log.c:static cl_object
c/log.c:ecl_log1p_complex(cl_object x)
c/log.c:  cl_object result = ecl_alloc_object(t_csfloat);
c/log.c:static cl_object
c/log.c:ecl_log1p_csfloat(cl_object x)
c/log.c:  cl_object result = ecl_alloc_object(t_csfloat);
c/log.c:static cl_object
c/log.c:ecl_log1p_cdfloat(cl_object x)
c/log.c:  cl_object result = ecl_alloc_object(t_cdfloat);
c/log.c:static cl_object
c/log.c:ecl_log1p_clfloat(cl_object x)
c/log.c:  cl_object result = ecl_alloc_object(t_clfloat);
c/macros.c:static cl_object
c/macros.c:search_symbol_macro(cl_object name, cl_object env)
c/macros.c:    cl_object record = CAR(env);
c/macros.c:static cl_object
c/macros.c:search_macro_function(cl_object name, cl_object env)
c/macros.c:      cl_object record = CAR(env);
c/macros.c:        cl_object tag = CADR(record);
c/macros.c:cl_object cl_macro_function(cl_narg narg, cl_object sym, ...)
c/macros.c:	cl_object env;
c/macros.c:		env = va_arg(ARGS,cl_object);
c/macros.c:	cl_object __value0 = (search_macro_function(sym, env));
c/macros.c:cl_object cl_macroexpand_1(cl_narg narg, cl_object form, ...)
c/macros.c:  cl_object exp_fun = ECL_NIL;
c/macros.c:	cl_object env;
c/macros.c:		env = va_arg(ARGS,cl_object);
c/macros.c:    cl_object head = CAR(form);
c/macros.c:    cl_object hook = ecl_symbol_value(ECL_SYM("*MACROEXPAND-HOOK*",42));
c/macros.c:	cl_object __value0 = form;
c/macros.c:	cl_object __value1 = exp_fun;
c/macros.c:cl_object cl_macroexpand(cl_narg narg, cl_object form, ...)
c/macros.c:  cl_object done, old_form;
c/macros.c:	cl_object env;
c/macros.c:		env = va_arg(ARGS,cl_object);
c/macros.c:	cl_object __value0 = form;
c/macros.c:	cl_object __value1 = done;
c/macros.c:static cl_object
c/macros.c:or_macro(cl_object whole, cl_object env)
c/macros.c:  cl_object output = ECL_NIL;
c/macros.c:	cl_object __value0 = ECL_NIL;
c/macros.c:	cl_object __value0 = CAR(whole);
c/macros.c:	cl_object __value0 = CONS(ECL_SYM("COND",249), cl_nreverse(output));
c/macros.c:static cl_object
c/macros.c:expand_and(cl_object whole)
c/macros.c:static cl_object
c/macros.c:and_macro(cl_object whole, cl_object env)
c/macros.c:	cl_object __value0 = expand_and(CDR(whole));
c/macros.c:static cl_object
c/macros.c:when_macro(cl_object whole, cl_object env)
c/macros.c:  cl_object args = CDR(whole);
c/mailbox.c:FEerror_not_a_mailbox(cl_object mailbox)
c/mailbox.c:cl_object
c/mailbox.c:ecl_make_mailbox(cl_object name, cl_fixnum count)
c/mailbox.c:  cl_object output = ecl_alloc_object(t_mailbox);
c/mailbox.c:cl_object mp_make_mailbox(cl_narg narg, ...)
c/mailbox.c:	static cl_object KEYS[2] = {(cl_object)(cl_symbols+1300), (cl_object)(cl_symbols+1487)};
c/mailbox.c:	cl_object name;
c/mailbox.c:	cl_object count;
c/mailbox.c:	cl_object KEY_VARS[4];
c/mailbox.c:	cl_object __value0 = ecl_make_mailbox(name, fixnnint(count));
c/mailbox.c:cl_object
c/mailbox.c:mp_mailbox_name(cl_object mailbox)
c/mailbox.c:cl_object
c/mailbox.c:mp_mailbox_count(cl_object mailbox)
c/mailbox.c:cl_object
c/mailbox.c:mp_mailbox_empty_p(cl_object mailbox)
c/mailbox.c:cl_object
c/mailbox.c:mp_mailbox_read(cl_object mailbox)
c/mailbox.c:  cl_object output;
c/mailbox.c:cl_object
c/mailbox.c:mp_mailbox_try_read(cl_object mailbox)
c/mailbox.c:  cl_object output;
c/mailbox.c:cl_object
c/mailbox.c:mp_mailbox_send(cl_object mailbox, cl_object msg)
c/mailbox.c:cl_object
c/mailbox.c:mp_mailbox_try_send(cl_object mailbox, cl_object msg)
c/mailbox.c:  cl_object output;
c/main.c:    cl_object x = ecl_alloc_object(t_bignum);
c/main.c:    cl_object l = ecl_symbol_value(ECL_SYM("SI::*EXIT-HOOKS*",1533));
c/main.c:    cl_object form = cl_list(2, ECL_SYM("FUNCALL",396), ECL_NIL);
c/main.c:  (cl_object)&str_empty_data, /* null_string */
c/main.c:  (cl_object)&plus_half_data, /* plus_half */
c/main.c:  (cl_object)&minus_half_data, /* minus_half */
c/main.c:  (cl_object)&flt_imag_unit_data, /* imag_unit */
c/main.c:  (cl_object)&flt_imag_unit_neg_data, /* minus_imag_unit */
c/main.c:  (cl_object)&flt_imag_two_data, /* imag_two */
c/main.c:  (cl_object)&flt_zero_data, /* singlefloat_zero */
c/main.c:  (cl_object)&dbl_zero_data, /* doublefloat_zero */
c/main.c:  (cl_object)&flt_zero_neg_data, /* singlefloat_minus_zero */
c/main.c:  (cl_object)&dbl_zero_neg_data, /* doublefloat_minus_zero */
c/main.c:  (cl_object)&ldbl_zero_data, /* longfloat_zero */
c/main.c:  (cl_object)&ldbl_zero_neg_data, /* longfloat_minus_zero */
c/main.c:  (cl_object)&str_G_data, /* gensym_prefix */
c/main.c:  (cl_object)&str_T_data, /* gentemp_prefix */
c/main.c:  (cl_object)&str_slash_data, /* slash */
c/main.c:  (cl_object)&default_rehash_size_data, /* rehash_size */
c/main.c:  (cl_object)&default_rehash_threshold_data, /* rehash_threshold */
c/main.c:maybe_fix_console_stream(cl_object stream)
c/main.c:  cl_object external_format;
c/main.c:  cl_object aux;
c/main.c:  cl_object features;
c/main.c:    cl_object name = (cl_object)(char_names + i);
c/main.c:    cl_object code = ecl_make_fixnum(i);
c/main.c:    cl_object name = (cl_object)(extra_char_names + i);
c/main.c:    cl_object code = ecl_make_fixnum(extra_char_codes[i]);
c/main.c:    cl_object name = (cl_object)(feature_names + i);
c/main.c:    cl_object key = ecl_intern(name, cl_core.keyword_package, &flag);
c/main.c:cl_object si_quit(cl_narg narg, ...)
c/main.c:	cl_object code;
c/main.c:	cl_object kill_all_threads;
c/main.c:		code = va_arg(ARGS,cl_object);
c/main.c:		kill_all_threads = va_arg(ARGS,cl_object);
c/main.c:      cl_object this_process = the_env->own_process;
c/main.c:      cl_object p, all_threads = mp_all_processes();
c/main.c:        cl_object process = ECL_CONS_CAR(p);
c/main.c:        cl_object process = ECL_CONS_CAR(p);
c/main.c:cl_object si_exit(cl_narg narg, ...)
c/main.c:	cl_object code;
c/main.c:		code = va_arg(ARGS,cl_object);
c/main.c:cl_object
c/main.c:	cl_object __value0 = ecl_make_fixnum(ARGC);
c/main.c:cl_object
c/main.c:si_argv(cl_object index)
c/main.c:	cl_object __value0 = ecl_make_simple_base_string(ARGV[i],-1);
c/main.c:cl_object
c/main.c:si_getenv(cl_object var)
c/main.c:	cl_object __value0 = ((value == NULL)? ECL_NIL : ecl_make_simple_base_string(value,-1));
c/main.c:cl_object
c/main.c:si_setenv(cl_object var, cl_object value)
c/main.c:cl_object
c/main.c:  cl_object output = ECL_NIL;
c/main.c:	cl_object __value0 = output;
c/main.c:cl_object
c/main.c:si_pointer(cl_object x)
c/mapfun.c:  const cl_object cdrs_frame = (cl_object)frames_aux;           \
c/mapfun.c:  const cl_object cars_frame = (cl_object)(frames_aux+1);       \
c/mapfun.c:cl_object cl_mapcar(cl_narg narg, cl_object fun, ...)
c/mapfun.c:  cl_object res, *val = &res;
c/mapfun.c:      cl_object cdr = ECL_STACK_FRAME_REF(cdrs_frame, i);
c/mapfun.c:	cl_object __value0 = res;
c/mapfun.c:cl_object cl_maplist(cl_narg narg, cl_object fun, ...)
c/mapfun.c:  cl_object res, *val = &res;
c/mapfun.c:      cl_object cdr = ECL_STACK_FRAME_REF(cdrs_frame, i);
c/mapfun.c:	cl_object __value0 = res;
c/mapfun.c:cl_object cl_mapc(cl_narg narg, cl_object fun, ...)
c/mapfun.c:  cl_object onelist;
c/mapfun.c:      cl_object cdr = ECL_STACK_FRAME_REF(cdrs_frame, i);
c/mapfun.c:	cl_object __value0 = onelist;
c/mapfun.c:cl_object cl_mapl(cl_narg narg, cl_object fun, ...)
c/mapfun.c:  cl_object onelist;
c/mapfun.c:      cl_object cdr = ECL_STACK_FRAME_REF(cdrs_frame, i);
c/mapfun.c:	cl_object __value0 = onelist;
c/mapfun.c:cl_object cl_mapcan(cl_narg narg, cl_object fun, ...)
c/mapfun.c:  cl_object res, *val = &res;
c/mapfun.c:      cl_object cdr = ECL_STACK_FRAME_REF(cdrs_frame, i);
c/mapfun.c:	cl_object __value0 = res;
c/mapfun.c:cl_object cl_mapcon(cl_narg narg, cl_object fun, ...)
c/mapfun.c:  cl_object res, *val = &res;
c/mapfun.c:      cl_object cdr = ECL_STACK_FRAME_REF(cdrs_frame, i);
c/mapfun.c:	cl_object __value0 = res;
c/minmax.c:cl_object cl_max(cl_narg narg, cl_object max, ...)
c/minmax.c:      cl_object numi = ecl_va_arg(nums);
c/minmax.c:	cl_object __value0 = max;
c/minmax.c:cl_object cl_min(cl_narg narg, cl_object min, ...)
c/minmax.c:      cl_object numi = ecl_va_arg(nums);
c/minmax.c:	cl_object __value0 = min;
c/minus.c:cl_object cl_M(cl_narg narg, cl_object num, ...)
c/minus.c:  cl_object diff;
c/minus.c:	cl_object __value0 = ecl_negate(num);
c/minus.c:	cl_object __value0 = diff;
c/minus.c:cl_object
c/minus.c:ecl_minus(cl_object x, cl_object y)
c/minus.c:  cl_object ret;
c/minus.c:        cl_object z = ecl_times(x, y->ratio.den);
c/minus.c:        cl_object z = ecl_times(x->ratio.den, y);
c/minus.c:        cl_object z1 = ecl_times(x->ratio.num,y->ratio.den);
c/minus.c:        cl_object z = ecl_times(x->ratio.den,y->ratio.num);
c/minus.c:        cl_object z = ecl_minus(x->gencomplex.real, y->gencomplex.real);
c/minus.c:        cl_object z1 = ecl_minus(x->gencomplex.imag, y->gencomplex.imag);
c/minusp.c:cl_object
c/minusp.c:cl_minusp(cl_object x)
c/minusp.c:	cl_object __value0 = (ecl_minusp(x) ? ECL_T : ECL_NIL);
c/minusp.c:ecl_minusp_fixnum(cl_object x)
c/minusp.c:ecl_minusp_big(cl_object x)
c/minusp.c:ecl_minusp_ratio(cl_object x)
c/minusp.c:ecl_minusp_single_float(cl_object x)
c/minusp.c:ecl_minusp_double_float(cl_object x)
c/minusp.c:static int ecl_minusp_long_float(cl_object x)
c/mmap.c:cl_object si_mmap(cl_narg narg, cl_object filename, ...)
c/mmap.c:	static cl_object KEYS[7] = {(cl_object)(cl_symbols+1289), (cl_object)(cl_symbols+1306), (cl_object)(cl_symbols+1240), (cl_object)(cl_symbols+1246), (cl_object)(cl_symbols+1270), (cl_object)(cl_symbols+1268), (cl_object)(cl_symbols+1258)};
c/mmap.c:	cl_object length;
c/mmap.c:	cl_object offset;
c/mmap.c:	cl_object direction;
c/mmap.c:	cl_object element_type;
c/mmap.c:	cl_object if_exists;
c/mmap.c:	cl_object if_does_not_exist;
c/mmap.c:	cl_object external_format;
c/mmap.c:	cl_object KEY_VARS[14];
c/mmap.c:    cl_object output, stream;
c/mmap.c:	cl_object __value0 = CONS(output, stream);
c/mmap.c:    cl_object output, vector;
c/mmap.c:      cl_object stream = cl_open(13, filename,
c/mmap.c:	cl_object __value0 = output;
c/mmap.c:cl_object
c/mmap.c:si_mmap_array(cl_object map)
c/mmap.c:	cl_object __value0 = cl_car(map);
c/mmap.c:	cl_object __value0 = map;
c/mmap.c:cl_object
c/mmap.c:si_munmap(cl_object map)
c/mmap.c:  cl_object array = cl_car(map);
c/mmap.c:  cl_object stream = cl_cdr(map);
c/mmap.c:	cl_object __value0 = ECL_NIL;
c/multival.c:cl_object cl_values(cl_narg narg, ...)
c/multival.c:  cl_object output;
c/multival.c:cl_object
c/multival.c:cl_values_list(cl_object list)
c/mutex.c:FEerror_not_a_lock(cl_object lock)
c/mutex.c:FEerror_not_a_recursive_lock(cl_object lock)
c/mutex.c:FEerror_not_owned(cl_object lock)
c/mutex.c:cl_object
c/mutex.c:ecl_make_lock(cl_object name, bool recursive)
c/mutex.c:  cl_object output = ecl_alloc_object(t_lock);
c/mutex.c:cl_object mp_make_lock(cl_narg narg, ...)
c/mutex.c:	static cl_object KEYS[2] = {(cl_object)(cl_symbols+1300), (cl_object)(cl_symbols+1446)};
c/mutex.c:	cl_object name;
c/mutex.c:	cl_object recursive;
c/mutex.c:	cl_object KEY_VARS[4];
c/mutex.c:	cl_object __value0 = ecl_make_lock(name, !Null(recursive));
c/mutex.c:cl_object
c/mutex.c:mp_recursive_lock_p(cl_object lock)
c/mutex.c:cl_object
c/mutex.c:mp_holding_lock_p(cl_object lock)
c/mutex.c:  cl_object own_process = env->own_process;
c/mutex.c:cl_object
c/mutex.c:mp_lock_name(cl_object lock)
c/mutex.c:cl_object
c/mutex.c:mp_lock_owner(cl_object lock)
c/mutex.c:cl_object
c/mutex.c:mp_lock_count(cl_object lock)
c/mutex.c:cl_object
c/mutex.c:mp_giveup_lock(cl_object lock)
c/mutex.c:  cl_object own_process = env->own_process;
c/mutex.c:    cl_object first = ecl_waiter_pop(env, lock);;
c/mutex.c:static cl_object
c/mutex.c:get_lock_inner(cl_env_ptr env, cl_object lock)
c/mutex.c:  cl_object output;
c/mutex.c:  cl_object own_process = env->own_process;
c/mutex.c:cl_object
c/mutex.c:mp_get_lock_nowait(cl_object lock)
c/mutex.c:static cl_object
c/mutex.c:own_or_get_lock(cl_env_ptr env, cl_object lock)
c/mutex.c:  cl_object output;
c/mutex.c:  cl_object own_process = env->own_process;
c/mutex.c:cl_object
c/mutex.c:mp_get_lock_wait(cl_object lock)
c/mutex.c:	cl_object __value0 = ECL_T;
c/mutex.c:cl_object mp_get_lock(cl_narg narg, cl_object lock, ...)
c/mutex.c:	cl_object wait;
c/mutex.c:		wait = va_arg(ARGS,cl_object);
c/negate.c:static cl_object
c/negate.c:ecl_negate_fix(cl_object x)
c/negate.c:static cl_object
c/negate.c:ecl_negate_big(cl_object x)
c/negate.c:static cl_object
c/negate.c:ecl_negate_ratio(cl_object x)
c/negate.c:static cl_object
c/negate.c:ecl_negate_single_float(cl_object x)
c/negate.c:static cl_object
c/negate.c:ecl_negate_double_float(cl_object x)
c/negate.c:static cl_object
c/negate.c:ecl_negate_long_float(cl_object x)
c/negate.c:static cl_object
c/negate.c:ecl_negate_complex(cl_object x)
c/negate.c:static cl_object
c/negate.c:ecl_negate_csfloat(cl_object x)
c/negate.c:static cl_object
c/negate.c:ecl_negate_cdfloat(cl_object x)
c/negate.c:static cl_object
c/negate.c:ecl_negate_clfloat(cl_object x)
c/number.c:ecl_to_fix(cl_object f)
c/number.c:ecl_to_size(cl_object f)
c/number.c:cl_object
c/number.c:    cl_object z = _ecl_big_register0();
c/number.c:cl_object
c/number.c:    cl_object z = _ecl_big_register0();
c/number.c:ecl_to_bit(cl_object x) {
c/number.c:ecl_to_uint8_t(cl_object x) {
c/number.c:ecl_to_int8_t(cl_object x) {
c/number.c:ecl_to_ushort(cl_object x) {
c/number.c:ecl_to_short(cl_object x) {
c/number.c:ecl_to_uint16_t(cl_object x) {
c/number.c:ecl_to_int16_t(cl_object x) {
c/number.c:ecl_to_uint32_t(cl_object x) {
c/number.c:ecl_to_int32_t(cl_object x) {
c/number.c:ecl_to_uint64_t(cl_object x) {
c/number.c:      cl_object copy = _ecl_big_register0();
c/number.c:ecl_to_int64_t(cl_object x) {
c/number.c:    cl_object copy = _ecl_big_register0();
c/number.c:cl_object
c/number.c:    cl_object aux = ecl_make_uint32_t(i >> 32);
c/number.c:cl_object
c/number.c:    cl_object aux = ecl_make_int32_t(i >> 32);
c/number.c:ecl_to_ulong_long(cl_object x) {
c/number.c:ecl_to_long_long(cl_object x) {
c/number.c:cl_object
c/number.c:cl_object
c/number.c:ecl_to_ulong_long(cl_object x) {
c/number.c:ecl_to_long_long(cl_object x) {
c/number.c:cl_object
c/number.c:cl_object
c/number.c:ecl_to_ulong_long(cl_object x) {
c/number.c:      cl_object copy = _ecl_big_register0();
c/number.c:ecl_to_long_long(cl_object x)
c/number.c:    cl_object copy = _ecl_big_register0();
c/number.c:cl_object
c/number.c:    cl_object aux = ecl_make_uint32_t(i >> 32);
c/number.c:cl_object
c/number.c:    cl_object aux = ecl_make_int32_t(i >> 32);
c/number.c:cl_object
c/number.c:ecl_make_ratio(cl_object num, cl_object den)
c/number.c:  cl_object g, r;
c/number.c:    cl_object condition;
c/number.c:cl_object
c/number.c:  cl_object x;
c/number.c:cl_object
c/number.c:  cl_object x;
c/number.c:cl_object
c/number.c:  cl_object x;
c/number.c:cl_object
c/number.c:ecl_make_complex(cl_object r, cl_object i)
c/number.c:  cl_object c = ECL_NIL;
c/number.c:cl_object si_complex_float_p(cl_object f) {
c/number.c:cl_object
c/number.c:si_complex_float(cl_object r, cl_object i)
c/number.c:  cl_object result = OBJNULL;
c/number.c:cl_object ecl_make_csfloat(float _Complex x) {
c/number.c:  cl_object c = ecl_alloc_object(t_csfloat);
c/number.c:cl_object ecl_make_cdfloat(double _Complex x) {
c/number.c:  cl_object c = ecl_alloc_object(t_cdfloat);
c/number.c:cl_object ecl_make_clfloat(long double _Complex x) {
c/number.c:  cl_object c = ecl_alloc_object(t_clfloat);
c/number.c:static cl_object
c/number.c:mantissa_and_exponent_from_ratio(cl_object num, cl_object den, int digits, cl_fixnum *exponent)
c/number.c:  cl_object quotient = ecl_integer_divide(num, den);
c/number.c:ratio_to_float(cl_object num, cl_object den)
c/number.c:  cl_object mantissa = mantissa_and_exponent_from_ratio(num, den, FLT_MANT_DIG, &exponent);
c/number.c:ratio_to_double(cl_object num, cl_object den)
c/number.c:  cl_object mantissa = mantissa_and_exponent_from_ratio(num, den, DBL_MANT_DIG, &exponent);
c/number.c:ratio_to_long_double(cl_object num, cl_object den)
c/number.c:  cl_object mantissa = mantissa_and_exponent_from_ratio(num, den, LDBL_MANT_DIG, &exponent);
c/number.c:ecl_to_float(cl_object x)
c/number.c:ecl_to_double(cl_object x)
c/number.c:ecl_to_long_double(cl_object x)
c/number.c:float _Complex ecl_to_csfloat(cl_object x) {
c/number.c:double _Complex  ecl_to_cdfloat(cl_object x) {
c/number.c:long double _Complex ecl_to_clfloat(cl_object x) {
c/number.c:cl_object
c/number.c:cl_rational(cl_object x)
c/number.c:	cl_object __value0 = x;
c/number.c:cl_object
c/number.c:    cl_object o = ecl_ash(_ecl_long_double_to_integer(d1), newe);
c/number.c:cl_object
c/number.c:    cl_object z = _ecl_big_register0();
c/number.c:cl_object
c/number.c:    cl_object z = _ecl_big_register0();
c/number.c:cl_object
c/number.c:  cl_object x = ecl_alloc_object(t_doublefloat);
c/number_compare.c:ecl_number_compare(cl_object x, cl_object y)
c/number_compare.c:static cl_object
c/number_compare.c:  cl_object c, d;
c/number_compare.c:    cl_object result = monotonic(i, j, narg, nums);             \
c/number_compare.c:cl_object cl_LE MONOTONIC( 1, 0)
c/number_compare.c:cl_object cl_GE MONOTONIC(-1, 0)
c/number_compare.c:cl_object cl_L  MONOTONIC( 1, 1)
c/number_compare.c:cl_object cl_G  MONOTONIC(-1, 1)
c/number_equalp.c:cl_object cl_E(cl_narg narg, cl_object num, ...)
c/number_equalp.c:	cl_object __value0 = ECL_NIL;
c/number_equalp.c:	cl_object __value0 = ECL_T;
c/number_equalp.c:ecl_number_equalp(cl_object x, cl_object y)
c/number_equalp.c:      cl_object aux = ecl_alloc_object(t_csfloat);
c/number_equalp.c:      cl_object aux = ecl_alloc_object(t_csfloat);
c/number_equalp.c:cl_object cl_NE(cl_narg narg, ...)
c/number_equalp.c:	cl_object numi;
c/number_equalp.c:	cl_object __value0 = ECL_NIL;
c/number_equalp.c:	cl_object __value0 = ECL_T;
c/num_arith.c:cl_object
c/num_arith.c:ecl_integer_divide(cl_object x, cl_object y)
c/num_arith.c:cl_object cl_gcd(cl_narg narg, ...)
c/num_arith.c:  cl_object gcd;
c/num_arith.c:	cl_object __value0 = ecl_make_fixnum(0);
c/num_arith.c:	cl_object __value0 = (ecl_minusp(gcd) ? ecl_negate(gcd) : gcd);
c/num_arith.c:	cl_object __value0 = gcd;
c/num_arith.c:cl_object
c/num_arith.c:ecl_gcd(cl_object x, cl_object y)
c/num_arith.c:cl_object cl_lcm(cl_narg narg, ...)
c/num_arith.c:  cl_object lcm;
c/num_arith.c:	cl_object __value0 = ecl_make_fixnum(1);
c/num_arith.c:    cl_object numi = ecl_va_arg(nums);
c/num_arith.c:    cl_object t = ecl_times(lcm, numi);
c/num_arith.c:    cl_object g = ecl_gcd(numi, lcm);
c/num_arith.c:	cl_object __value0 = (ecl_minusp(lcm) ? ecl_negate(lcm) : lcm);
c/num_co.c:cl_object cl_float(cl_narg narg, cl_object x, ...)
c/num_co.c:	cl_object y;
c/num_co.c:		y = va_arg(ARGS,cl_object);
c/num_co.c:	cl_object __value0 = x;
c/num_co.c:cl_object
c/num_co.c:cl_numerator(cl_object x)
c/num_co.c:	cl_object __value0 = x;
c/num_co.c:cl_object
c/num_co.c:cl_denominator(cl_object x)
c/num_co.c:	cl_object __value0 = x;
c/num_co.c:cl_object
c/num_co.c:cl_mod(cl_object x, cl_object y)
c/num_co.c:cl_object
c/num_co.c:cl_rem(cl_object x, cl_object y)
c/num_co.c:cl_object
c/num_co.c:cl_decode_float(cl_object x)
c/num_co.c:cl_object
c/num_co.c:cl_scale_float(cl_object x, cl_object y)
c/num_co.c:cl_object
c/num_co.c:cl_float_radix(cl_object x)
c/num_co.c:ecl_signbit(cl_object x)
c/num_co.c:cl_object cl_float_sign(cl_narg narg, cl_object x, ...)
c/num_co.c:	cl_object y;
c/num_co.c:		y = va_arg(ARGS,cl_object);
c/num_co.c:	cl_object __value0 = y;
c/num_co.c:cl_object
c/num_co.c:cl_float_digits(cl_object x)
c/num_co.c:cl_object
c/num_co.c:cl_float_precision(cl_object x)
c/num_co.c:cl_object
c/num_co.c:cl_integer_decode_float(cl_object x)
c/num_co.c:cl_object cl_complex(cl_narg narg, cl_object r, ...)
c/num_co.c:	cl_object i;
c/num_co.c:		i = va_arg(ARGS,cl_object);
c/num_co.c:	cl_object __value0 = ecl_make_complex(r, i);
c/num_co.c:cl_object
c/num_co.c:cl_realpart(cl_object x)
c/num_co.c:	cl_object __value0 = x;
c/num_co.c:cl_object
c/num_co.c:cl_imagpart(cl_object x)
c/num_co.c:	cl_object __value0 = x;
c/num_log.c:static cl_object
c/num_log.c:  cl_object x, y;
c/num_log.c:cl_object
c/num_log.c:ecl_boole(int op, cl_object x, cl_object y)
c/num_log.c:      cl_object x_copy = _ecl_big_register0();
c/num_log.c:    cl_object x_copy = _ecl_big_register0();
c/num_log.c:      cl_object z = _ecl_big_register1();
c/num_log.c:cl_object
c/num_log.c:cl_lognot(cl_object x)
c/num_log.c:count_bits(cl_object x)
c/num_log.c:      cl_object z = _ecl_big_register0();
c/num_log.c:cl_object
c/num_log.c:ecl_ash(cl_object x, cl_fixnum w)
c/num_log.c:  cl_object y;
c/num_log.c:cl_object cl_logior(cl_narg narg, ...)
c/num_log.c:	cl_object __value0 = ecl_make_fixnum(0);
c/num_log.c:	cl_object __value0 = log_op(narg, ECL_BOOLIOR, nums);
c/num_log.c:cl_object cl_logxor(cl_narg narg, ...)
c/num_log.c:	cl_object __value0 = ecl_make_fixnum(0);
c/num_log.c:	cl_object __value0 = log_op(narg, ECL_BOOLXOR, nums);
c/num_log.c:cl_object cl_logand(cl_narg narg, ...)
c/num_log.c:	cl_object __value0 = ecl_make_fixnum(-1);
c/num_log.c:	cl_object __value0 = log_op(narg, ECL_BOOLAND, nums);
c/num_log.c:cl_object cl_logeqv(cl_narg narg, ...)
c/num_log.c:	cl_object __value0 = ecl_make_fixnum(-1);
c/num_log.c:	cl_object __value0 = log_op(narg, ECL_BOOLEQV, nums);
c/num_log.c:cl_object
c/num_log.c:cl_lognand(cl_object x, cl_object y)
c/num_log.c:	cl_object __value0 = ecl_boole(ECL_BOOLNAND, x, y);
c/num_log.c:cl_object
c/num_log.c:cl_lognor(cl_object x, cl_object y)
c/num_log.c:	cl_object __value0 = ecl_boole(ECL_BOOLNOR, x, y);
c/num_log.c:cl_object
c/num_log.c:cl_logandc1(cl_object x, cl_object y)
c/num_log.c:	cl_object __value0 = ecl_boole(ECL_BOOLANDC1, x, y);
c/num_log.c:cl_object
c/num_log.c:cl_logandc2(cl_object x, cl_object y)
c/num_log.c:	cl_object __value0 = ecl_boole(ECL_BOOLANDC2, x, y);
c/num_log.c:cl_object
c/num_log.c:cl_logorc1(cl_object x, cl_object y)
c/num_log.c:	cl_object __value0 = ecl_boole(ECL_BOOLORC1, x, y);
c/num_log.c:cl_object
c/num_log.c:cl_logorc2(cl_object x, cl_object y)
c/num_log.c:	cl_object __value0 = ecl_boole(ECL_BOOLORC2, x, y);
c/num_log.c:coerce_to_logical_operator(cl_object o)
c/num_log.c:cl_object
c/num_log.c:cl_boole(cl_object o, cl_object x, cl_object y)
c/num_log.c:	cl_object __value0 = ecl_boole(coerce_to_logical_operator(o), x, y);
c/num_log.c:cl_object
c/num_log.c:cl_logbitp(cl_object p, cl_object x)
c/num_log.c:	cl_object __value0 = (i ? ECL_T : ECL_NIL);
c/num_log.c:cl_object
c/num_log.c:cl_ash(cl_object x, cl_object y)
c/num_log.c:  cl_object r;
c/num_log.c:	cl_object __value0 = r;
c/num_log.c:cl_object
c/num_log.c:cl_logcount(cl_object x)
c/num_log.c:	cl_object __value0 = ecl_make_fixnum(count_bits(x));
c/num_log.c:ecl_integer_length(cl_object x)
c/num_log.c:cl_object
c/num_log.c:cl_integer_length(cl_object x)
c/num_log.c:	cl_object __value0 = ecl_make_fixnum(ecl_integer_length(x));
c/num_log.c:cl_object
c/num_log.c:si_bit_array_op(cl_object o, cl_object x, cl_object y, cl_object r)
c/num_log.c:  cl_object r0;
c/num_log.c:	cl_object __value0 = r;
c/num_log.c:	cl_object __value0 = r;
c/num_log.c:	cl_object __value0 = r0;
c/num_pred.c:ecl_oddp(cl_object x)
c/num_pred.c:ecl_evenp(cl_object x)
c/num_pred.c:cl_object
c/num_pred.c:cl_oddp(cl_object x)
c/num_pred.c:	cl_object __value0 = (ecl_oddp(x) ? ECL_T : ECL_NIL);
c/num_pred.c:cl_object
c/num_pred.c:cl_evenp(cl_object x)
c/num_pred.c:	cl_object __value0 = (ecl_evenp(x) ? ECL_T : ECL_NIL);
c/num_pred.c:cl_object
c/num_pred.c:si_float_nan_p(cl_object x)
c/num_pred.c:	cl_object __value0 = (ecl_float_nan_p(x)? ECL_T : ECL_NIL);
c/num_pred.c:cl_object
c/num_pred.c:si_float_infinity_p(cl_object x)
c/num_pred.c:	cl_object __value0 = (ecl_float_infinity_p(x)? ECL_T : ECL_NIL);
c/num_pred.c:ecl_float_nan_p(cl_object x)
c/num_pred.c:ecl_float_infinity_p(cl_object x)
c/num_rand.c:cl_object
c/num_rand.c:  cl_object array = ecl_alloc_simple_vector((MT_N + 1), ecl_aet_b64);
c/num_rand.c:generate_int64(cl_object state)
c/num_rand.c:generate_double(cl_object state)
c/num_rand.c:generate_limb(cl_object state)
c/num_rand.c:cl_object
c/num_rand.c:  cl_object array = ecl_alloc_simple_vector((MT_N + 1), ecl_aet_b32);
c/num_rand.c:generate_int32(cl_object state)
c/num_rand.c:generate_double(cl_object state)
c/num_rand.c:generate_limb(cl_object state)
c/num_rand.c:cl_object
c/num_rand.c:static cl_object
c/num_rand.c:random_integer(cl_object limit, cl_object state)
c/num_rand.c:  cl_object buffer;
c/num_rand.c:static cl_object
c/num_rand.c:rando(cl_object x, cl_object rs)
c/num_rand.c:  cl_object z;
c/num_rand.c:cl_object
c/num_rand.c:ecl_make_random_state(cl_object rs)
c/num_rand.c:  cl_object z = ecl_alloc_object(t_random);
c/num_rand.c:cl_object cl_random(cl_narg narg, cl_object x, ...)
c/num_rand.c:	cl_object rs;
c/num_rand.c:		rs = va_arg(ARGS,cl_object);
c/num_rand.c:	cl_object __value0 = rando(x, rs);
c/num_rand.c:cl_object cl_make_random_state(cl_narg narg, ...)
c/num_rand.c:	cl_object rs;
c/num_rand.c:		rs = va_arg(ARGS,cl_object);
c/num_rand.c:	cl_object __value0 = ecl_make_random_state(rs);
c/num_rand.c:cl_object
c/num_rand.c:cl_random_state_p(cl_object x)
c/num_rand.c:	cl_object __value0 = (ECL_RANDOM_STATE_P(x) ? ECL_T : ECL_NIL);
c/num_rand.c:cl_object
c/num_rand.c:si_random_state_array(cl_object rs) {
c/one_minus.c:static cl_object
c/one_minus.c:ecl_one_minus_fix(cl_object x)
c/one_minus.c:  return (cl_object)((cl_fixnum)x - ((cl_fixnum)ecl_make_fixnum(1) - ECL_FIXNUM_TAG));
c/one_minus.c:static cl_object
c/one_minus.c:ecl_one_minus_big(cl_object x)
c/one_minus.c:static cl_object
c/one_minus.c:ecl_one_minus_ratio(cl_object x)
c/one_minus.c:static cl_object
c/one_minus.c:ecl_one_minus_single_float(cl_object x)
c/one_minus.c:static cl_object
c/one_minus.c:ecl_one_minus_double_float(cl_object x)
c/one_minus.c:static cl_object
c/one_minus.c:ecl_one_minus_long_float(cl_object x)
c/one_minus.c:static cl_object
c/one_minus.c:ecl_one_minus_complex(cl_object x)
c/one_minus.c:static cl_object
c/one_minus.c:ecl_one_minus_csfloat(cl_object x)
c/one_minus.c:static cl_object
c/one_minus.c:ecl_one_minus_cdfloat(cl_object x)
c/one_minus.c:static cl_object
c/one_minus.c:ecl_one_minus_clfloat(cl_object x)
c/one_minus.c:cl_object
c/one_minus.c:cl_1M(cl_object x)
c/one_minus.c:	cl_object __value0 = ecl_one_minus(x);
c/one_plus.c:static cl_object
c/one_plus.c:ecl_one_plus_fix(cl_object x)
c/one_plus.c:  return (cl_object)((cl_fixnum)x + ((cl_fixnum)ecl_make_fixnum(1) - ECL_FIXNUM_TAG));
c/one_plus.c:static cl_object
c/one_plus.c:ecl_one_plus_big(cl_object x)
c/one_plus.c:static cl_object
c/one_plus.c:ecl_one_plus_ratio(cl_object x)
c/one_plus.c:static cl_object
c/one_plus.c:ecl_one_plus_single_float(cl_object x)
c/one_plus.c:static cl_object
c/one_plus.c:ecl_one_plus_double_float(cl_object x)
c/one_plus.c:static cl_object
c/one_plus.c:ecl_one_plus_long_float(cl_object x)
c/one_plus.c:static cl_object
c/one_plus.c:ecl_one_plus_complex(cl_object x)
c/one_plus.c:static cl_object
c/one_plus.c:ecl_one_plus_csfloat(cl_object x)
c/one_plus.c:static cl_object
c/one_plus.c:ecl_one_plus_cdfloat(cl_object x)
c/one_plus.c:static cl_object
c/one_plus.c:ecl_one_plus_clfloat(cl_object x)
c/one_plus.c:cl_object
c/one_plus.c:cl_1P(cl_object x)
c/one_plus.c:	cl_object __value0 = ecl_one_plus(x);
c/package.c:static cl_object find_symbol_inner(cl_object name, cl_object p, int *intern_flag);
c/package.c:FEpackage_error(const char *message, cl_object package, int narg, ...)
c/package.c:  cl_object rest;
c/package.c:CEpackage_error(const char *message, const char *continue_message, cl_object package, int narg, ...)
c/package.c:  cl_object arg;
c/package.c:member_string_eq(cl_object x, cl_object l)
c/package.c:symbol_remove_package(cl_object s, cl_object p)
c/package.c:symbol_add_package(cl_object s, cl_object p)
c/package.c:static cl_object
c/package.c:static cl_object
c/package.c:alloc_package(cl_object name)
c/package.c:  cl_object p = ecl_alloc_object(t_package);
c/package.c:cl_object
c/package.c:_ecl_package_to_be_created(const cl_env_ptr env, cl_object name)
c/package.c:  cl_object package = ecl_assoc(name, env->packages_to_be_created);
c/package.c:static cl_object
c/package.c:find_pending_package(cl_env_ptr env, cl_object name, cl_object nicknames)
c/package.c:  cl_object l = env->packages_to_be_created;
c/package.c:    cl_object pair = ECL_CONS_CAR(l);
c/package.c:    cl_object other_name = ECL_CONS_CAR(pair);
c/package.c:        cl_object x = ECL_CONS_CDR(pair);
c/package.c:static cl_object
c/package.c:find_local_nickname_package(cl_object name) {
c/package.c:  cl_object p = ecl_symbol_value(ECL_SYM("*PACKAGE*",45));
c/package.c:static cl_object
c/package.c:process_nicknames(cl_object nicknames)
c/package.c:  cl_object l;
c/package.c:static cl_object
c/package.c:process_package_list(cl_object packages)
c/package.c:  cl_object l;
c/package.c:static cl_object
c/package.c:process_local_nicknames_list(cl_object local_nicknames)
c/package.c:  cl_object l, nl;
c/package.c:cl_object
c/package.c:ecl_make_package(cl_object name, cl_object nicknames,
c/package.c:                 cl_object use_list, cl_object local_nicknames)
c/package.c:  cl_object x, other = ECL_NIL;
c/package.c:        cl_object nick = ECL_CONS_CAR(nicknames);
c/package.c:      cl_object y = ECL_CONS_CAR(use_list);
c/package.c:      cl_object y = ECL_CONS_CAR(local_nicknames);
c/package.c:      cl_object nicknamed = ECL_CONS_CDR(y);
c/package.c:cl_object
c/package.c:ecl_rename_package(cl_object x, cl_object name, cl_object nicknames)
c/package.c:    cl_object l;
c/package.c:      cl_object nick = ECL_CONS_CAR(l);
c/package.c:      cl_object p = ecl_find_package_nolock(nick);
c/package.c:cl_object
c/package.c:ecl_find_package_nolock(cl_object name)
c/package.c:  cl_object l, p;
c/package.c:cl_object
c/package.c:cl_object
c/package.c:si_coerce_to_package(cl_object p)
c/package.c:  cl_object pp = ecl_find_package_nolock(p);
c/package.c:	cl_object __value0 = pp;
c/package.c:cl_object
c/package.c:  cl_object x = ecl_symbol_value(ECL_SYM("*PACKAGE*",45));
c/package.c:cl_object
c/package.c:_ecl_intern(const char *s, cl_object p)
c/package.c:  cl_object str = ecl_make_constant_base_string(s,-1);
c/package.c:cl_object
c/package.c:ecl_intern(cl_object name, cl_object p, int *intern_flag)
c/package.c:  cl_object s;
c/package.c:static cl_object
c/package.c:find_symbol_inner(cl_object name, cl_object p, int *intern_flag)
c/package.c:  cl_object s, ul;
c/package.c:cl_object
c/package.c:ecl_find_symbol(cl_object n, cl_object p, int *intern_flag)
c/package.c:  cl_object s;
c/package.c:static cl_object
c/package.c:potential_unintern_conflict(cl_object name, cl_object s, cl_object p)
c/package.c:  cl_object x = OBJNULL;
c/package.c:  cl_object l = p->pack.uses;
c/package.c:    cl_object other_p = ECL_CONS_CAR(l);
c/package.c:    cl_object y = ecl_gethash_safe(name, other_p->pack.external, OBJNULL);
c/package.c:ecl_unintern(cl_object s, cl_object p)
c/package.c:  cl_object conflict;
c/package.c:  cl_object name = ecl_symbol_name(s);
c/package.c:    cl_object hash = p->pack.internal;
c/package.c:    cl_object x = ecl_gethash_safe(name, hash, OBJNULL);
c/package.c:static cl_object
c/package.c:potential_export_conflict(cl_object name, cl_object s, cl_object p)
c/package.c:  cl_object l = p->pack.usedby;
c/package.c:    cl_object other_p = ECL_CONS_CAR(l);
c/package.c:    cl_object x = find_symbol_inner(name, other_p, &intern_flag);
c/package.c:cl_export2(cl_object s, cl_object p)
c/package.c:  cl_object other_p = ECL_NIL, name = ecl_symbol_name(s);
c/package.c:    cl_object x = find_symbol_inner(name, p, &intern_flag);
c/package.c:cl_object
c/package.c:cl_delete_package(cl_object p)
c/package.c:  cl_object hash, l;
c/package.c:	cl_object __value0 = ECL_NIL;
c/package.c:	cl_object __value0 = ECL_NIL;
c/package.c:    cl_object nickname = ECL_CONS_CAR(l);
c/package.c:    cl_object nicknaming = ECL_CONS_CAR(l);
c/package.c:    cl_object nicklist = nicknaming->pack.local_nicknames;
c/package.c:      cl_object nickname = ECL_CONS_CAR(nicklist);
c/package.c:        cl_object s = hash->hash.data[i].value;
c/package.c:        cl_object s = hash->hash.data[i].value;
c/package.c:	cl_object __value0 = ECL_T;
c/package.c:cl_unexport2(cl_object s, cl_object p)
c/package.c:  cl_object name = ecl_symbol_name(s);
c/package.c:    cl_object x = find_symbol_inner(name, p, &intern_flag);
c/package.c:cl_import2(cl_object s, cl_object p)
c/package.c:  cl_object name = ecl_symbol_name(s);
c/package.c:    cl_object x = find_symbol_inner(name, p, &intern_flag);
c/package.c:ecl_shadowing_import(cl_object s, cl_object p)
c/package.c:  cl_object x;
c/package.c:  cl_object name = ecl_symbol_name(s);
c/package.c:ecl_shadow(cl_object s, cl_object p)
c/package.c:  cl_object x;
c/package.c:ecl_use_package(cl_object x, cl_object p)
c/package.c:  cl_object here, there, name;
c/package.c:ecl_unuse_package(cl_object x, cl_object p)
c/package.c:cl_object cl_make_package(cl_narg narg, cl_object pack_name, ...)
c/package.c:	static cl_object KEYS[3] = {(cl_object)(cl_symbols+1304), (cl_object)(cl_symbols+1351), (cl_object)(cl_symbols+1295)};
c/package.c:	cl_object nicknames;
c/package.c:	cl_object use;
c/package.c:	cl_object local_nicknames;
c/package.c:	cl_object KEY_VARS[6];
c/package.c:	cl_object __value0 = ecl_make_package(pack_name, nicknames, use, local_nicknames);
c/package.c:cl_object
c/package.c:si_select_package(cl_object pack_name)
c/package.c:  cl_object p = si_coerce_to_package(pack_name);
c/package.c:cl_object
c/package.c:cl_find_package(cl_object p)
c/package.c:	cl_object __value0 = ecl_find_package_nolock(p);
c/package.c:cl_object
c/package.c:cl_package_name(cl_object p)
c/package.c:cl_object
c/package.c:cl_package_nicknames(cl_object p)
c/package.c:cl_object cl_rename_package(cl_narg narg, cl_object pack, cl_object new_name, ...)
c/package.c:	cl_object new_nicknames;
c/package.c:		new_nicknames = va_arg(ARGS,cl_object);
c/package.c:	cl_object __value0 = ecl_rename_package(pack, new_name, new_nicknames);
c/package.c:cl_object
c/package.c:cl_package_use_list(cl_object p)
c/package.c:cl_object
c/package.c:cl_package_used_by_list(cl_object p)
c/package.c:cl_object
c/package.c:cl_package_shadowing_symbols(cl_object p)
c/package.c:cl_object
c/package.c:si_package_lock(cl_object p, cl_object t)
c/package.c:	cl_object __value0 = (previous? ECL_T : ECL_NIL);
c/package.c:cl_object
c/package.c:si_package_locked_p (cl_object p)
c/package.c:cl_object
c/package.c:si_package_local_nicknames(cl_object p)
c/package.c:cl_object
c/package.c:si_package_locally_nicknamed_by_list(cl_object p)
c/package.c:cl_object
c/package.c:si_add_package_local_nickname(cl_object local_nickname,
c/package.c:                              cl_object actual_package,
c/package.c:                              cl_object target_package) {
c/package.c:  cl_object existing = target_package->pack.local_nicknames;
c/package.c:  cl_object cell = ecl_assoc(local_nickname, existing);
c/package.c:    cl_object old_package = ECL_CONS_CDR(cell);
c/package.c:    cl_object nickname_cons = CONS(local_nickname, actual_package);
c/package.c:cl_object
c/package.c:si_remove_package_local_nickname(cl_object old_nickname,
c/package.c:                                 cl_object target_package) {
c/package.c:  cl_object actual_package = ECL_NIL;
c/package.c:    cl_object cell = ecl_assoc(old_nickname, target_package->pack.local_nicknames);
c/package.c:cl_object
c/package.c:cl_object cl_intern(cl_narg narg, cl_object strng, ...)
c/package.c:	cl_object p;
c/package.c:	cl_object sym;
c/package.c:		p = va_arg(ARGS,cl_object);
c/package.c:	cl_object __value0 = sym;
c/package.c:	cl_object __value1 = ECL_SYM(":INTERNAL",1284);
c/package.c:	cl_object __value0 = sym;
c/package.c:	cl_object __value1 = ECL_SYM(":EXTERNAL",1257);
c/package.c:	cl_object __value0 = sym;
c/package.c:	cl_object __value1 = ECL_SYM(":INHERITED",1276);
c/package.c:	cl_object __value0 = sym;
c/package.c:	cl_object __value1 = ECL_NIL;
c/package.c:cl_object cl_find_symbol(cl_narg narg, cl_object strng, ...)
c/package.c:  cl_object x;
c/package.c:	cl_object p;
c/package.c:		p = va_arg(ARGS,cl_object);
c/package.c:	cl_object __value0 = x;
c/package.c:	cl_object __value1 = ECL_SYM(":INTERNAL",1284);
c/package.c:	cl_object __value0 = x;
c/package.c:	cl_object __value1 = ECL_SYM(":EXTERNAL",1257);
c/package.c:	cl_object __value0 = x;
c/package.c:	cl_object __value1 = ECL_SYM(":INHERITED",1276);
c/package.c:	cl_object __value0 = ECL_NIL;
c/package.c:	cl_object __value1 = ECL_NIL;
c/package.c:cl_object cl_unintern(cl_narg narg, cl_object symbl, ...)
c/package.c:	cl_object p;
c/package.c:		p = va_arg(ARGS,cl_object);
c/package.c:	cl_object __value0 = (ecl_unintern(symbl, p) ? ECL_T : ECL_NIL);
c/package.c:cl_object cl_export(cl_narg narg, cl_object symbols, ...)
c/package.c:	cl_object pack;
c/package.c:		pack = va_arg(ARGS,cl_object);
c/package.c:	cl_object __value0 = ECL_T;
c/package.c:cl_object cl_unexport(cl_narg narg, cl_object symbols, ...)
c/package.c:	cl_object pack;
c/package.c:		pack = va_arg(ARGS,cl_object);
c/package.c:	cl_object __value0 = ECL_T;
c/package.c:cl_object cl_import(cl_narg narg, cl_object symbols, ...)
c/package.c:	cl_object pack;
c/package.c:		pack = va_arg(ARGS,cl_object);
c/package.c:	cl_object __value0 = ECL_T;
c/package.c:cl_object cl_shadowing_import(cl_narg narg, cl_object symbols, ...)
c/package.c:	cl_object pack;
c/package.c:		pack = va_arg(ARGS,cl_object);
c/package.c:	cl_object __value0 = ECL_T;
c/package.c:cl_object cl_shadow(cl_narg narg, cl_object symbols, ...)
c/package.c:	cl_object pack;
c/package.c:		pack = va_arg(ARGS,cl_object);
c/package.c:	cl_object __value0 = ECL_T;
c/package.c:cl_object cl_use_package(cl_narg narg, cl_object pack, ...)
c/package.c:	cl_object pa;
c/package.c:		pa = va_arg(ARGS,cl_object);
c/package.c:	cl_object __value0 = ECL_T;
c/package.c:cl_object cl_unuse_package(cl_narg narg, cl_object pack, ...)
c/package.c:	cl_object pa;
c/package.c:		pa = va_arg(ARGS,cl_object);
c/package.c:	cl_object __value0 = ECL_T;
c/package.c:cl_object
c/package.c:si_package_hash_tables(cl_object p)
c/package.c:  cl_object he, hi, u;
c/package.c:	cl_object __value0 = he;
c/package.c:	cl_object __value1 = hi;
c/package.c:	cl_object __value2 = u;
c/parse_integer.c:cl_object
c/parse_integer.c:ecl_parse_integer(cl_object str, cl_index start, cl_index end,
c/parse_integer.c:  cl_object integer_part, output;
c/parse_integer.c:cl_object cl_parse_integer(cl_narg narg, cl_object strng, ...)
c/parse_integer.c:  cl_object rtbl = ecl_current_readtable();
c/parse_integer.c:	static cl_object KEYS[4] = {(cl_object)(cl_symbols+1337), (cl_object)(cl_symbols+1247), (cl_object)(cl_symbols+1322), (cl_object)(cl_symbols+1287)};
c/parse_integer.c:	cl_object start;
c/parse_integer.c:	cl_object end;
c/parse_integer.c:	cl_object radix;
c/parse_integer.c:	cl_object junk_allowed;
c/parse_integer.c:	cl_object x;
c/parse_integer.c:	cl_object KEY_VARS[8];
c/parse_integer.c:	cl_object __value0 = ECL_NIL;
c/parse_integer.c:	cl_object __value1 = ecl_make_fixnum(s);
c/parse_integer.c:	cl_object __value0 = ECL_NIL;
c/parse_integer.c:	cl_object __value1 = ecl_make_fixnum(ep);
c/parse_integer.c:	cl_object __value0 = x;
c/parse_integer.c:	cl_object __value1 = ecl_make_fixnum(ep);
c/parse_integer.c:	cl_object __value0 = x;
c/parse_integer.c:	cl_object __value1 = ecl_make_fixnum(e);
c/parse_number.c:static cl_object
c/parse_number.c:  cl_object accum = _ecl_big_register0();
c/parse_number.c:  cl_object factor = _ecl_big_register1();
c/parse_number.c:static cl_object
c/parse_number.c:  cl_object var;
c/parse_number.c:static cl_object
c/parse_number.c:make_float(cl_object num, cl_object exp, cl_index exp_char, int sign)
c/parse_number.c:cl_object
c/parse_number.c:ecl_parse_number(cl_object str, cl_index start, cl_index end,
c/parse_number.c:  cl_object num = _ecl_big_register0();
c/parse_number.c:      cl_object den;
c/parse_number.c:      cl_object exp, decimals;
c/pathname.c:static cl_object
c/pathname.c:normalize_case(cl_object path, cl_object cas)
c/pathname.c:in_local_case_p(cl_object str, cl_object cas)
c/pathname.c:in_antilocal_case_p(cl_object str, cl_object cas)
c/pathname.c:static cl_object
c/pathname.c:to_local_case(cl_object str, cl_object cas)
c/pathname.c:static cl_object
c/pathname.c:host_case(cl_object host)
c/pathname.c:static cl_object
c/pathname.c:to_antilocal_case(cl_object str, cl_object cas)
c/pathname.c:static cl_object
c/pathname.c:translate_from_common(cl_object str, cl_object tocase)
c/pathname.c:static cl_object
c/pathname.c:translate_to_common(cl_object str, cl_object fromcase)
c/pathname.c:static cl_object
c/pathname.c:translate_component_case(cl_object str, cl_object fromcase, cl_object tocase)
c/pathname.c:static cl_object
c/pathname.c:translate_list_case(cl_object list, cl_object fromcase, cl_object tocase)
c/pathname.c:    cl_object l;
c/pathname.c:      cl_object name = ECL_CONS_CAR(l);
c/pathname.c:push_substring(cl_object buffer, cl_object string, cl_index start, cl_index end)
c/pathname.c:push_string(cl_object buffer, cl_object string)
c/pathname.c:static cl_object
c/pathname.c:destructively_check_directory(cl_object directory, bool logical, bool delete_back)
c/pathname.c:  cl_object ptr;
c/pathname.c:    cl_object item = ECL_CONS_CAR(ptr);
c/pathname.c:        cl_object next = ECL_CONS_CDR(ptr);
c/pathname.c:cl_object
c/pathname.c:ecl_make_pathname(cl_object host, cl_object device, cl_object directory,
c/pathname.c:                  cl_object name, cl_object type, cl_object version,
c/pathname.c:                  cl_object fromcase)
c/pathname.c:  cl_object x, p, component;
c/pathname.c:    cl_object tocase = normalize_case(p, ECL_SYM(":LOCAL",1294));
c/pathname.c:static cl_object
c/pathname.c:tilde_expand(cl_object pathname)
c/pathname.c:  cl_object directory, head;
c/pathname.c:static cl_object
c/pathname.c:make_one(cl_object s, cl_index start, cl_index end)
c/pathname.c:static cl_object
c/pathname.c:parse_word(cl_object s, delim_fn delim, int flags, cl_index start,
c/pathname.c:static cl_object
c/pathname.c:parse_directories(cl_object s, int flags, cl_index start, cl_index end,
c/pathname.c:  cl_object path = ECL_NIL;
c/pathname.c:    cl_object part = parse_word(s, delim, flags, j, end, &i);
c/pathname.c:ecl_logical_hostname_p(cl_object host)
c/pathname.c:cl_object
c/pathname.c:ecl_parse_namestring(cl_object s, cl_index start, cl_index end, cl_index *ep,
c/pathname.c:                     cl_object default_host)
c/pathname.c:  cl_object host, device, path, name, type, aux, version;
c/pathname.c:    cl_object parsed_length;
c/pathname.c:cl_object
c/pathname.c:  cl_object path = ecl_symbol_value(ECL_SYM("*DEFAULT-PATHNAME-DEFAULTS*",34));
c/pathname.c:	cl_object __value0 = path;
c/pathname.c:cl_object
c/pathname.c:cl_pathname(cl_object x)
c/pathname.c:	cl_object __value0 = x;
c/pathname.c:cl_object
c/pathname.c:cl_logical_pathname(cl_object x)
c/pathname.c:	cl_object __value0 = x;
c/pathname.c:cl_object cl_wild_pathname_p(cl_narg narg, cl_object pathname, ...)
c/pathname.c:	cl_object component;
c/pathname.c:		component = va_arg(ARGS,cl_object);
c/pathname.c:	cl_object __value0 = ECL_T;
c/pathname.c:	cl_object __value0 = ECL_T;
c/pathname.c:	cl_object __value0 = ECL_T;
c/pathname.c:    cl_object name = pathname->pathname.name;
c/pathname.c:	cl_object __value0 = ECL_T;
c/pathname.c:    cl_object name = pathname->pathname.type;
c/pathname.c:	cl_object __value0 = ECL_T;
c/pathname.c:    cl_object list = pathname->pathname.directory;
c/pathname.c:      cl_object name = ECL_CONS_CAR(list);
c/pathname.c:	cl_object __value0 = ECL_T;
c/pathname.c:	cl_object __value0 = ECL_NIL;
c/pathname.c:cl_object
c/pathname.c:coerce_to_file_pathname(cl_object pathname)
c/pathname.c:cl_object
c/pathname.c:coerce_to_physical_pathname(cl_object x)
c/pathname.c:cl_object
c/pathname.c:si_coerce_to_filename(cl_object pathname_orig)
c/pathname.c:  cl_object namestring, pathname;
c/pathname.c:cl_object
c/pathname.c:ecl_merge_pathnames(cl_object path, cl_object defaults, cl_object default_version)
c/pathname.c:  cl_object host, device, directory, name, type, version;
c/pathname.c:  cl_object tocase;
c/pathname.c:cl_object
c/pathname.c:ecl_namestring(cl_object x, int flags)
c/pathname.c:  cl_object l, y;
c/pathname.c:  cl_object buffer, host;
c/pathname.c:cl_object
c/pathname.c:cl_namestring(cl_object x)
c/pathname.c:	cl_object __value0 = ecl_namestring(x, ECL_NAMESTRING_TRUNCATE_IF_ERROR);
c/pathname.c:cl_object cl_parse_namestring(cl_narg narg, cl_object thing, ...)
c/pathname.c:	cl_object host;
c/pathname.c:	cl_object defaults;
c/pathname.c:	static cl_object KEYS[3] = {(cl_object)(cl_symbols+1337), (cl_object)(cl_symbols+1247), (cl_object)(cl_symbols+1287)};
c/pathname.c:	cl_object start;
c/pathname.c:	cl_object end;
c/pathname.c:	cl_object junk_allowed;
c/pathname.c:	cl_object output;
c/pathname.c:	cl_object KEY_VARS[6];
c/pathname.c:    cl_object default_host = host;
c/pathname.c:	cl_object __value0 = output;
c/pathname.c:	cl_object __value1 = start;
c/pathname.c:cl_object cl_merge_pathnames(cl_narg narg, cl_object path, ...)
c/pathname.c:	cl_object defaults;
c/pathname.c:	cl_object default_version;
c/pathname.c:		defaults = va_arg(ARGS,cl_object);
c/pathname.c:		default_version = va_arg(ARGS,cl_object);
c/pathname.c:	cl_object __value0 = ecl_merge_pathnames(path, defaults, default_version);
c/pathname.c:cl_object cl_make_pathname(cl_narg narg, ...)
c/pathname.c:	static cl_object KEYS[8] = {(cl_object)(cl_symbols+1267), (cl_object)(cl_symbols+1239), (cl_object)(cl_symbols+1241), (cl_object)(cl_symbols+1300), (cl_object)(cl_symbols+1346), (cl_object)(cl_symbols+1354), (cl_object)(cl_symbols+1227), (cl_object)(cl_symbols+1238)};
c/pathname.c:	cl_object host;
c/pathname.c:	cl_object device;
c/pathname.c:	cl_object directory;
c/pathname.c:	cl_object name;
c/pathname.c:	cl_object type;
c/pathname.c:	cl_object version;
c/pathname.c:	cl_object scase;
c/pathname.c:	cl_object defaults;
c/pathname.c:	cl_object x;
c/pathname.c:	cl_object KEY_VARS[16];
c/pathname.c:	cl_object __value0 = x;
c/pathname.c:cl_object
c/pathname.c:cl_pathnamep(cl_object pname)
c/pathname.c:	cl_object __value0 = (ECL_PATHNAMEP(pname) ? ECL_T : ECL_NIL);
c/pathname.c:cl_object
c/pathname.c:si_logical_pathname_p(cl_object pname)
c/pathname.c:	cl_object __value0 = ((ECL_PATHNAMEP(pname) && pname->pathname.logical)?
c/pathname.c:cl_object cl_pathname_host(cl_narg narg, cl_object pname, ...)
c/pathname.c:	static cl_object KEYS[1] = {(cl_object)(cl_symbols+1227)};
c/pathname.c:	cl_object scase;
c/pathname.c:	cl_object KEY_VARS[2];
c/pathname.c:	cl_object __value0 = translate_component_case(pname->pathname.host,
c/pathname.c:cl_object cl_pathname_device(cl_narg narg, cl_object pname, ...)
c/pathname.c:	static cl_object KEYS[1] = {(cl_object)(cl_symbols+1227)};
c/pathname.c:	cl_object scase;
c/pathname.c:	cl_object KEY_VARS[2];
c/pathname.c:	cl_object __value0 = translate_component_case(pname->pathname.device,
c/pathname.c:cl_object cl_pathname_directory(cl_narg narg, cl_object pname, ...)
c/pathname.c:	static cl_object KEYS[1] = {(cl_object)(cl_symbols+1227)};
c/pathname.c:	cl_object scase;
c/pathname.c:	cl_object KEY_VARS[2];
c/pathname.c:	cl_object __value0 = translate_list_case(pname->pathname.directory,
c/pathname.c:cl_object cl_pathname_name(cl_narg narg, cl_object pname, ...)
c/pathname.c:	static cl_object KEYS[1] = {(cl_object)(cl_symbols+1227)};
c/pathname.c:	cl_object scase;
c/pathname.c:	cl_object KEY_VARS[2];
c/pathname.c:	cl_object __value0 = translate_component_case(pname->pathname.name,
c/pathname.c:cl_object cl_pathname_type(cl_narg narg, cl_object pname, ...)
c/pathname.c:	static cl_object KEYS[1] = {(cl_object)(cl_symbols+1227)};
c/pathname.c:	cl_object scase;
c/pathname.c:	cl_object KEY_VARS[2];
c/pathname.c:	cl_object __value0 = translate_component_case(pname->pathname.type,
c/pathname.c:cl_object
c/pathname.c:cl_pathname_version(cl_object pname)
c/pathname.c:	cl_object __value0 = pname->pathname.version;
c/pathname.c:cl_object
c/pathname.c:cl_file_namestring(cl_object pname)
c/pathname.c:	cl_object __value0 = ecl_namestring(ecl_make_pathname(ECL_NIL, ECL_NIL, ECL_NIL,
c/pathname.c:cl_object
c/pathname.c:cl_directory_namestring(cl_object pname)
c/pathname.c:	cl_object __value0 = ecl_namestring(ecl_make_pathname(ECL_NIL, ECL_NIL,
c/pathname.c:cl_object
c/pathname.c:cl_host_namestring(cl_object pname)
c/pathname.c:	cl_object __value0 = pname;
c/pathname.c:cl_object cl_enough_namestring(cl_narg narg, cl_object path, ...)
c/pathname.c:  cl_object newpath, pathdir, defaultdir, fname;
c/pathname.c:	cl_object defaults;
c/pathname.c:		defaults = va_arg(ARGS,cl_object);
c/pathname.c:    cl_object dir_begin = funcall(5, ECL_SYM("MISMATCH",561), pathdir, defaultdir,
c/pathname.c:	cl_object __value0 = ecl_namestring(newpath, ECL_NAMESTRING_TRUNCATE_IF_ERROR);
c/pathname.c:ecl_wild_string_p(cl_object item)
c/pathname.c:ecl_string_match(cl_object s, cl_index j, cl_index ls,
c/pathname.c:                 cl_object p, cl_index i, cl_index lp)
c/pathname.c:path_item_match(cl_object a, cl_object mask) {
c/pathname.c:path_list_match(cl_object a, cl_object mask) {
c/pathname.c:  cl_object item_mask;
c/pathname.c:cl_object
c/pathname.c:cl_pathname_match_p(cl_object path, cl_object mask)
c/pathname.c:  cl_object output = ECL_NIL;
c/pathname.c:	cl_object __value0 = output;
c/pathname.c:static cl_object
c/pathname.c:coerce_to_from_pathname(cl_object x, cl_object host)
c/pathname.c:cl_object si_pathname_translations(cl_narg narg, cl_object host, ...)
c/pathname.c:  cl_object pair, l;
c/pathname.c:	cl_object set;
c/pathname.c:		set = va_arg(ARGS,cl_object);
c/pathname.c:	cl_object __value0 = ((pair == ECL_NIL)? ECL_NIL : CADR(pair));
c/pathname.c:    cl_object item = CAR(l);
c/pathname.c:    cl_object from = coerce_to_from_pathname(cl_car(item), host);
c/pathname.c:    cl_object to = cl_pathname(cl_cadr(item));
c/pathname.c:	cl_object __value0 = set;
c/pathname.c:static cl_object
c/pathname.c:find_wilds(cl_object l, cl_object source, cl_object match)
c/pathname.c:static cl_object
c/pathname.c:find_list_wilds(cl_object a, cl_object mask)
c/pathname.c:  cl_object l = ECL_NIL, l2;
c/pathname.c:    cl_object item_mask = CAR(mask);
c/pathname.c:static cl_object
c/pathname.c:copy_wildcards(cl_object *wilds_list, cl_object pattern)
c/pathname.c:  cl_object wilds = *wilds_list, token;
c/pathname.c:static cl_object
c/pathname.c:copy_list_wildcards(cl_object *wilds, cl_object to)
c/pathname.c:  cl_object l = ECL_NIL;
c/pathname.c:    cl_object d, mask = CAR(to);
c/pathname.c:      cl_object list = *wilds;
c/pathname.c:        cl_object dirlist = CAR(list);
c/pathname.c:cl_object cl_translate_pathname(cl_narg narg, cl_object source, cl_object from, cl_object to, ...)
c/pathname.c:  cl_object wilds, d;
c/pathname.c:  cl_object host, device, directory, name, type, version;
c/pathname.c:  cl_object fromcase, tocase;
c/pathname.c:	cl_object *KEYS = NULL;
c/pathname.c:	cl_object *KEY_VARS = NULL;
c/pathname.c:	cl_object __value0 = ecl_make_pathname(host, device, directory, name, type,
c/pathname.c:cl_object cl_translate_logical_pathname(cl_narg narg, cl_object source, ...)
c/pathname.c:  cl_object l, pair;
c/pathname.c:  cl_object pathname;
c/pathname.c:	cl_object *KEYS = NULL;
c/pathname.c:	cl_object *KEY_VARS = NULL;
c/pathname.c:	cl_object __value0 = pathname;
c/plus.c:cl_object cl_P(cl_narg narg, ...)
c/plus.c:  cl_object sum = ecl_make_fixnum(0);
c/plus.c:	cl_object __value0 = sum;
c/plus.c:cl_object
c/plus.c:ecl_plus(cl_object x, cl_object y) {
c/plus.c:  cl_object ret;
c/plus.c:        cl_object z = ecl_times(x, y->ratio.den);
c/plus.c:        cl_object z = ecl_times(x->ratio.den, y);
c/plus.c:        cl_object z1 = ecl_times(x->ratio.num,y->ratio.den);
c/plus.c:        cl_object z = ecl_times(x->ratio.den,y->ratio.num);
c/plus.c:        cl_object aux;
c/plus.c:        cl_object z = ecl_plus(x->gencomplex.real, y->gencomplex.real);
c/plus.c:        cl_object z1 = ecl_plus(x->gencomplex.imag, y->gencomplex.imag);
c/plusp.c:cl_object
c/plusp.c:cl_plusp(cl_object x)
c/plusp.c:	cl_object __value0 = (ecl_plusp(x) ? ECL_T : ECL_NIL);
c/plusp.c:ecl_plusp_fixnum(cl_object x)
c/plusp.c:ecl_plusp_big(cl_object x)
c/plusp.c:ecl_plusp_ratio(cl_object x)
c/plusp.c:ecl_plusp_single_float(cl_object x)
c/plusp.c:ecl_plusp_double_float(cl_object x)
c/plusp.c:static int ecl_plusp_long_float(cl_object x)
c/predicate.c:cl_object
c/predicate.c:cl_identity(cl_object x)
c/predicate.c:	cl_object __value0 = x;
c/predicate.c:cl_object
c/predicate.c:cl_null(cl_object x)
c/predicate.c:	cl_object __value0 = (Null(x) ? ECL_T : ECL_NIL);
c/predicate.c:cl_object
c/predicate.c:cl_symbolp(cl_object x)
c/predicate.c:	cl_object __value0 = (ECL_SYMBOLP(x) ? ECL_T : ECL_NIL);
c/predicate.c:cl_object
c/predicate.c:cl_atom(cl_object x)
c/predicate.c:	cl_object __value0 = (ECL_ATOM(x) ? ECL_T : ECL_NIL);
c/predicate.c:cl_object
c/predicate.c:cl_consp(cl_object x)
c/predicate.c:	cl_object __value0 = (CONSP(x) ? ECL_T : ECL_NIL);
c/predicate.c:cl_object
c/predicate.c:cl_listp(cl_object x)
c/predicate.c:	cl_object __value0 = ((Null(x) || CONSP(x)) ? ECL_T : ECL_NIL);
c/predicate.c:cl_object
c/predicate.c:cl_numberp(cl_object x)
c/predicate.c:	cl_object __value0 = (ECL_NUMBER_TYPE_P(t) ? ECL_T : ECL_NIL);
c/predicate.c:bool ecl_numberp(cl_object x)
c/predicate.c:cl_object
c/predicate.c:cl_integerp(cl_object x)
c/predicate.c:	cl_object __value0 = ((t == t_fixnum || t == t_bignum) ? ECL_T : ECL_NIL);
c/predicate.c:cl_object
c/predicate.c:cl_rationalp(cl_object x)
c/predicate.c:	cl_object __value0 = ((t == t_fixnum || t == t_bignum || t == t_ratio) ? ECL_T : ECL_NIL);
c/predicate.c:cl_object
c/predicate.c:cl_floatp(cl_object x)
c/predicate.c:	cl_object __value0 = (floatp(x)? ECL_T : ECL_NIL);
c/predicate.c:floatp(cl_object x)
c/predicate.c:cl_object
c/predicate.c:cl_realp(cl_object x)
c/predicate.c:	cl_object __value0 = (ECL_REAL_TYPE_P(t) ? ECL_T : ECL_NIL);
c/predicate.c:ecl_realp(cl_object x)
c/predicate.c:cl_object
c/predicate.c:cl_complexp(cl_object x)
c/predicate.c:	cl_object __value0 = (ECL_COMPLEXP(x) ? ECL_T : ECL_NIL);
c/predicate.c:cl_object
c/predicate.c:cl_characterp(cl_object x)
c/predicate.c:	cl_object __value0 = (ECL_CHARACTERP(x) ? ECL_T : ECL_NIL);
c/predicate.c:cl_object
c/predicate.c:si_base_char_p(cl_object c)
c/predicate.c:	cl_object __value0 = ((ECL_CHARACTERP(c) && ECL_BASE_CHAR_P(c))? ECL_T : ECL_NIL);
c/predicate.c:ecl_stringp(cl_object x)
c/predicate.c:cl_object
c/predicate.c:cl_stringp(cl_object x)
c/predicate.c:	cl_object __value0 = (ECL_STRINGP(x)? ECL_T : ECL_NIL);
c/predicate.c:cl_object
c/predicate.c:cl_bit_vector_p(cl_object x)
c/predicate.c:	cl_object __value0 = (ECL_BIT_VECTOR_P(x) ? ECL_T : ECL_NIL);
c/predicate.c:cl_object
c/predicate.c:cl_vectorp(cl_object x)
c/predicate.c:	cl_object __value0 = (ECL_VECTORP(x) ? ECL_T : ECL_NIL);
c/predicate.c:cl_object
c/predicate.c:cl_simple_string_p(cl_object x)
c/predicate.c:	cl_object __value0 = ((ECL_STRINGP(x) &&
c/predicate.c:cl_object
c/predicate.c:si_base_string_p(cl_object x)
c/predicate.c:	cl_object __value0 = (ECL_BASE_STRING_P(x) ? ECL_T : ECL_NIL);
c/predicate.c:cl_object
c/predicate.c:cl_simple_bit_vector_p(cl_object x)
c/predicate.c:	cl_object __value0 = ((ECL_BIT_VECTOR_P(x) &&
c/predicate.c:cl_object
c/predicate.c:cl_simple_vector_p(cl_object x)
c/predicate.c:	cl_object __value0 = ((t == t_vector &&
c/predicate.c:cl_object
c/predicate.c:cl_arrayp(cl_object x)
c/predicate.c:	cl_object __value0 = (ECL_ARRAYP(x) ? ECL_T : ECL_NIL);
c/predicate.c:cl_object
c/predicate.c:cl_packagep(cl_object x)
c/predicate.c:	cl_object __value0 = (ECL_PACKAGEP(x) ? ECL_T : ECL_NIL);
c/predicate.c:cl_object
c/predicate.c:cl_functionp(cl_object x)
c/predicate.c:  cl_object output;
c/predicate.c:	cl_object __value0 = output;
c/predicate.c:cl_object
c/predicate.c:cl_compiled_function_p(cl_object x)
c/predicate.c:	cl_object __value0 = ((t == t_bytecodes || t == t_bclosure || t == t_cfun
c/predicate.c:cl_object
c/predicate.c:cl_eq(cl_object x, cl_object y)
c/predicate.c:	cl_object __value0 = ((x == y) ? ECL_T : ECL_NIL);
c/predicate.c:ecl_eql(cl_object x, cl_object y)
c/predicate.c:cl_object
c/predicate.c:cl_eql(cl_object x, cl_object y)
c/predicate.c:	cl_object __value0 = (ecl_eql(x, y) ? ECL_T : ECL_NIL);
c/predicate.c:ecl_equal(register cl_object x, cl_object y)
c/predicate.c:cl_object
c/predicate.c:cl_equal(cl_object x, cl_object y)
c/predicate.c:	cl_object __value0 = (ecl_equal(x, y) ? ECL_T : ECL_NIL);
c/predicate.c:ecl_equalp(cl_object x, cl_object y)
c/predicate.c:      cl_object iterator = si_hash_table_iterator(x);
c/predicate.c:        cl_object ndx = _ecl_funcall1(iterator);
c/predicate.c:          cl_object key = env->values[1];
c/predicate.c:          cl_object x_value = env->values[2];
c/predicate.c:          cl_object y_value = ecl_gethash_safe(key, y, OBJNULL);
c/predicate.c:cl_object
c/predicate.c:cl_equalp(cl_object x, cl_object y)
c/predicate.c:	cl_object __value0 = (ecl_equalp(x, y) ? ECL_T : ECL_NIL);
c/predicate.c:cl_object
c/predicate.c:si_fixnump(cl_object x)
c/predicate.c:	cl_object __value0 = (ECL_FIXNUMP(x) ? ECL_T : ECL_NIL);
c/print.c:cl_object
c/print.c:_ecl_stream_or_default_output(cl_object stream)
c/print.c:  cl_object object = ecl_symbol_value(ECL_SYM("*PRINT-BASE*",47));
c/print.c:  cl_object object = ecl_symbol_value(ECL_SYM("*PRINT-LEVEL*",53));
c/print.c:  cl_object object = ecl_symbol_value(ECL_SYM("*PRINT-LENGTH*",52));
c/print.c:cl_object
c/print.c:  cl_object output = ecl_symbol_value(ECL_SYM("*PRINT-CASE*",48));
c/print.c:cl_object cl_write(cl_narg narg, cl_object x, ...)
c/print.c:	static cl_object KEYS[16] = {(cl_object)(cl_symbols+1340), (cl_object)(cl_symbols+1221), (cl_object)(cl_symbols+1223), (cl_object)(cl_symbols+1227), (cl_object)(cl_symbols+1228), (cl_object)(cl_symbols+1252), (cl_object)(cl_symbols+1265), (cl_object)(cl_symbols+1289), (cl_object)(cl_symbols+1290), (cl_object)(cl_symbols+1291), (cl_object)(cl_symbols+1299), (cl_object)(cl_symbols+1313), (cl_object)(cl_symbols+1316), (cl_object)(cl_symbols+1322), (cl_object)(cl_symbols+1323), (cl_object)(cl_symbols+1330)};
c/print.c:	cl_object strm;
c/print.c:	cl_object array;
c/print.c:	cl_object base;
c/print.c:	cl_object cas;
c/print.c:	cl_object circle;
c/print.c:	cl_object escape;
c/print.c:	cl_object gensym;
c/print.c:	cl_object length;
c/print.c:	cl_object level;
c/print.c:	cl_object lines;
c/print.c:	cl_object miser_width;
c/print.c:	cl_object pprint_dispatch;
c/print.c:	cl_object pretty;
c/print.c:	cl_object radix;
c/print.c:	cl_object readably;
c/print.c:	cl_object right_margin;
c/print.c:	cl_object KEY_VARS[32];
c/print.c:	cl_object __value0 = x;
c/print.c:cl_object cl_prin1(cl_narg narg, cl_object obj, ...)
c/print.c:	cl_object strm;
c/print.c:		strm = va_arg(ARGS,cl_object);
c/print.c:	cl_object __value0 = obj;
c/print.c:cl_object cl_print(cl_narg narg, cl_object obj, ...)
c/print.c:	cl_object strm;
c/print.c:		strm = va_arg(ARGS,cl_object);
c/print.c:	cl_object __value0 = obj;
c/print.c:cl_object cl_pprint(cl_narg narg, cl_object obj, ...)
c/print.c:	cl_object strm;
c/print.c:		strm = va_arg(ARGS,cl_object);
c/print.c:cl_object cl_princ(cl_narg narg, cl_object obj, ...)
c/print.c:	cl_object strm;
c/print.c:		strm = va_arg(ARGS,cl_object);
c/print.c:	cl_object __value0 = obj;
c/print.c:cl_object cl_write_char(cl_narg narg, cl_object c, ...)
c/print.c:	cl_object strm;
c/print.c:		strm = va_arg(ARGS,cl_object);
c/print.c:	cl_object __value0 = c;
c/print.c:cl_object cl_write_string(cl_narg narg, cl_object strng, ...)
c/print.c:	cl_object strm;
c/print.c:	static cl_object KEYS[2] = {(cl_object)(cl_symbols+1337), (cl_object)(cl_symbols+1247)};
c/print.c:	cl_object start;
c/print.c:	cl_object end;
c/print.c:	cl_object KEY_VARS[4];
c/print.c:	cl_object __value0 = strng;
c/print.c:cl_object cl_write_line(cl_narg narg, cl_object strng, ...)
c/print.c:	cl_object strm;
c/print.c:	static cl_object KEYS[2] = {(cl_object)(cl_symbols+1337), (cl_object)(cl_symbols+1247)};
c/print.c:	cl_object start;
c/print.c:	cl_object end;
c/print.c:	cl_object KEY_VARS[4];
c/print.c:	cl_object __value0 = strng;
c/print.c:cl_object cl_terpri(cl_narg narg, ...)
c/print.c:	cl_object strm;
c/print.c:		strm = va_arg(ARGS,cl_object);
c/print.c:	cl_object __value0 = ECL_NIL;
c/print.c:cl_object cl_fresh_line(cl_narg narg, ...)
c/print.c:	cl_object strm;
c/print.c:		strm = va_arg(ARGS,cl_object);
c/print.c:	cl_object __value0 = ECL_NIL;
c/print.c:	cl_object __value0 = ECL_T;
c/print.c:cl_object cl_finish_output(cl_narg narg, ...)
c/print.c:	cl_object strm;
c/print.c:		strm = va_arg(ARGS,cl_object);
c/print.c:	cl_object __value0 = ECL_NIL;
c/print.c:cl_object cl_force_output(cl_narg narg, ...)
c/print.c:	cl_object strm;
c/print.c:		strm = va_arg(ARGS,cl_object);
c/print.c:	cl_object __value0 = ECL_NIL;
c/print.c:cl_object cl_clear_output(cl_narg narg, ...)
c/print.c:	cl_object strm;
c/print.c:		strm = va_arg(ARGS,cl_object);
c/print.c:	cl_object __value0 = ECL_NIL;
c/print.c:cl_object
c/print.c:cl_write_byte(cl_object integer, cl_object binary_output_stream)
c/print.c:	cl_object __value0 = integer;
c/print.c:cl_object cl_write_sequence(cl_narg narg, cl_object sequence, cl_object stream, ...)
c/print.c:	static cl_object KEYS[2] = {(cl_object)(cl_symbols+1337), (cl_object)(cl_symbols+1247)};
c/print.c:	cl_object start;
c/print.c:	cl_object end;
c/print.c:	cl_object KEY_VARS[4];
c/print.c:cl_object
c/print.c:ecl_princ(cl_object obj, cl_object strm)
c/print.c:cl_object
c/print.c:ecl_prin1(cl_object obj, cl_object strm)
c/print.c:cl_object
c/print.c:ecl_print(cl_object obj, cl_object strm)
c/print.c:cl_object
c/print.c:ecl_terpri(cl_object strm)
c/print.c:ecl_write_string(cl_object strng, cl_object strm)
c/print.c:ecl_princ_str(const char *s, cl_object strm)
c/print.c:ecl_princ_char(int c, cl_object strm)
c/print_unreadable.c:_ecl_write_addr(void *x, cl_object stream)
c/print_unreadable.c:  cl_object buffer = si_get_buffer_string();
c/print_unreadable.c:_ecl_write_unreadable(cl_object x, const char *prefix, cl_object name, cl_object stream)
c/print_unreadable.c:cl_object
c/print_unreadable.c:si_print_unreadable_object_function(cl_object o, cl_object stream, cl_object type, cl_object id, cl_object function)
c/print_unreadable.c:	cl_object __value0 = ECL_NIL;
c/process.c:cl_object
c/process.c:  cl_object v = cl_core.processes;
c/process.c:    cl_object other = cl_core.processes;
c/process.c:      cl_object new = si_make_vector(ECL_T,
c/process.c:ecl_list_process(cl_object process)
c/process.c:      cl_object vector = cl_core.processes;
c/process.c:ecl_unlist_process(cl_object process)
c/process.c:  cl_object vector = cl_core.processes;
c/process.c:static cl_object
c/process.c:  cl_object output = ECL_NIL;
c/process.c:    cl_object vector = cl_core.processes;
c/process.c:    cl_object *data = vector->vector.self.t;
c/process.c:      cl_object p = data[i];
c/process.c:assert_type_process(cl_object o)
c/process.c:  cl_object process = (cl_object)aux;
c/process.c:  cl_object process = (cl_object)arg;
c/process.c:        cl_object output = ECL_NIL;
c/process.c:static cl_object
c/process.c:alloc_process(cl_object name, cl_object initial_bindings)
c/process.c:  cl_object process = ecl_alloc_object(t_process), array;
c/process.c:ecl_import_current_thread(cl_object name, cl_object bindings)
c/process.c:  cl_object process;
c/process.c:    cl_object processes = cl_core.processes;
c/process.c:      cl_object p = processes->vector.self.t[i];
c/process.c:  cl_object own_process = env->own_process;
c/process.c:cl_object mp_make_process(cl_narg narg, ...)
c/process.c:  cl_object process;
c/process.c:	static cl_object KEYS[2] = {(cl_object)(cl_symbols+1300), (cl_object)(cl_symbols+1459)};
c/process.c:	cl_object name;
c/process.c:	cl_object initial_bindings;
c/process.c:	cl_object KEY_VARS[4];
c/process.c:	cl_object __value0 = process;
c/process.c:cl_object
c/process.c:mp_process_preset(cl_narg narg, cl_object process, cl_object function, ...)
c/process.c:	cl_object __value0 = process;
c/process.c:cl_object
c/process.c:mp_interrupt_process(cl_object process, cl_object function)
c/process.c:	cl_object __value0 = ECL_T;
c/process.c:cl_object
c/process.c:cl_object
c/process.c:cl_object
c/process.c:mp_process_suspend(cl_object process)
c/process.c:cl_object
c/process.c:mp_process_resume(cl_object process)
c/process.c:cl_object
c/process.c:mp_process_kill(cl_object process)
c/process.c:cl_object
c/process.c:cl_object
c/process.c:mp_process_enable(cl_object process)
c/process.c:	cl_object __value0 = (ok? process : ECL_NIL);
c/process.c:cl_object
c/process.c:cl_object
c/process.c:	cl_object __value0 = ecl_process_list();
c/process.c:cl_object
c/process.c:mp_process_name(cl_object process)
c/process.c:	cl_object __value0 = process->process.name;
c/process.c:cl_object
c/process.c:mp_process_active_p(cl_object process)
c/process.c:	cl_object __value0 = (process->process.phase? ECL_T : ECL_NIL);
c/process.c:cl_object
c/process.c:mp_process_whostate(cl_object process)
c/process.c:	cl_object __value0 = (cl_core.null_string);
c/process.c:cl_object
c/process.c:mp_process_join(cl_object process)
c/process.c:cl_object
c/process.c:mp_process_run_function(cl_narg narg, cl_object name, cl_object function, ...)
c/process.c:  cl_object process;
c/process.c:  cl_object rest;
c/process.c:cl_object
c/process.c:  cl_object process;
c/process.c:	cl_object __value0 = process;
c/process.c:static cl_object
c/process.c:  cl_object data = ecl_alloc_simple_vector(sizeof(sigset_t), ecl_aet_b8);
c/process.c:	cl_object __value0 = data;
c/process.c:static cl_object
c/process.c:mp_set_sigmask(cl_object data)
c/process.c:	cl_object __value0 = data;
c/process.c:cl_object
c/process.c:  cl_object previous = ecl_symbol_value(ECL_SYM("EXT::*INTERRUPTS-ENABLED*",7));
c/process.c:	cl_object __value0 = previous;
c/process.c:  cl_object previous = mp_get_sigmask();
c/process.c:	cl_object __value0 = previous;
c/process.c:cl_object
c/process.c:mp_restore_signals(cl_object sigmask)
c/process.c:	cl_object __value0 = sigmask;
c/process.c:  cl_object process;
c/process.c:    cl_object v = si_make_vector(ECL_T, /* Element type */
c/queue.c:ecl_get_spinlock(cl_env_ptr the_env, cl_object *lock)
c/queue.c:  cl_object own_process = the_env->own_process;
c/queue.c:ecl_giveup_spinlock(cl_object *lock)
c/queue.c:wait_queue_nconc(cl_env_ptr the_env, cl_object q, cl_object new_tail)
c/queue.c:static ECL_INLINE cl_object
c/queue.c:wait_queue_pop_all(cl_env_ptr the_env, cl_object q)
c/queue.c:  cl_object output;
c/queue.c:wait_queue_delete(cl_env_ptr the_env, cl_object q, cl_object item)
c/queue.c:static cl_object
c/queue.c:bignum_set_time(cl_object bignum, struct ecl_timeval *time)
c/queue.c:static cl_object
c/queue.c:  cl_object delta_big = _ecl_big_register0();
c/queue.c:  cl_object aux_big = _ecl_big_register1();
c/queue.c:  cl_object top = ecl_make_fixnum(10 * 1000);
c/queue.c:  cl_object delta_big = elapsed_time(start);
c/queue.c:static cl_object
c/queue.c:ecl_wait_on_timed(cl_env_ptr env, mp_wait_test condition, cl_object mp_object)
c/queue.c:  volatile cl_object own_process = the_env->own_process;
c/queue.c:  volatile cl_object record;
c/queue.c:  volatile cl_object output;
c/queue.c:cl_object
c/queue.c:ecl_wait_on(cl_env_ptr env, mp_wait_test condition, cl_object mp_object)
c/queue.c:  volatile cl_object own_process = the_env->own_process;
c/queue.c:  volatile cl_object record;
c/queue.c:  volatile cl_object output;
c/queue.c:cl_object
c/queue.c:ecl_waiter_pop(cl_env_ptr the_env, cl_object q)
c/queue.c:  cl_object output;
c/queue.c:    cl_object l;
c/queue.c:      cl_object p = ECL_CONS_CAR(l);
c/queue.c:ecl_wakeup_waiters(cl_env_ptr the_env, cl_object q, int flags)
c/queue.c:    cl_object *tail, l;
c/queue.c:      cl_object p = ECL_CONS_CAR(l);
c/queue.c:print_lock(char *prefix, cl_object l, ...)
c/queue.c:  static cl_object lock = ECL_NIL;
c/queue.c:      cl_object p = l->lock.queue_list;
c/read.c:static cl_object dispatch_macro_character(cl_object table, cl_object strm, int c, bool signal_error);
c/read.c:cl_object
c/read.c:  cl_object pool = env->string_pool;
c/read.c:  cl_object output;
c/read.c:	cl_object __value0 = output;
c/read.c:cl_object
c/read.c:si_put_buffer_string(cl_object string)
c/read.c:    cl_object pool = env->string_pool;
c/read.c:static void extra_argument (int c, cl_object stream, cl_object d);
c/read.c:static cl_object patch_sharp(const cl_env_ptr env, cl_object x);
c/read.c:static cl_object do_read_delimited_list(int d, cl_object strm, bool proper_list);
c/read.c:cl_object
c/read.c:ecl_read_object_non_recursive(cl_object in)
c/read.c:  cl_object x;
c/read.c:invert_buffer_case(cl_object x, cl_object escape_list, int sign)
c/read.c:      cl_object escape_interval = CAR(escape_list);
c/read.c:static cl_object
c/read.c:ecl_read_object_with_delimiter(cl_object in, int delimiter, int flags,
c/read.c:  cl_object x, token;
c/read.c:  cl_object p;
c/read.c:  cl_object rtbl = ecl_current_readtable();
c/read.c:  cl_object escape_list; /* intervals of escaped characters */
c/read.c:    cl_object o;
c/read.c:        cl_object name = cl_copy_seq(token);
c/read.c:cl_object
c/read.c:ecl_read_object(cl_object in)
c/read.c:cl_object
c/read.c:si_read_object_or_ignore(cl_object in, cl_object eof)
c/read.c:  cl_object x;
c/read.c:static cl_object
c/read.c:right_parenthesis_reader(cl_object in, cl_object character)
c/read.c:static cl_object
c/read.c:left_parenthesis_reader(cl_object in, cl_object character)
c/read.c:	cl_object __value0 = do_read_delimited_list(c, in, 0);
c/read.c:cl_object comma_reader(cl_object in, cl_object c)
c/read.c:  cl_object x, y;
c/read.c:cl_object backquote_reader(cl_object in, cl_object c)
c/read.c:	cl_object __value0 = ECL_NIL;
c/read.c:	cl_object __value0 = cl_macroexpand_1(2, cl_list(2, ECL_SYM("SI::QUASIQUOTE",1532), in), ECL_NIL);
c/read.c:	cl_object __value0 = cl_list(2,ECL_SYM("SI::QUASIQUOTE",1532),c);
c/read.c:static cl_object
c/read.c:read_constituent(cl_object in)
c/read.c:  cl_object rtbl = ecl_current_readtable();
c/read.c:  cl_object token = si_get_buffer_string();
c/read.c:static cl_object
c/read.c:double_quote_reader(cl_object in, cl_object c)
c/read.c:  cl_object rtbl = ecl_current_readtable();
c/read.c:  cl_object token = si_get_buffer_string();
c/read.c:  cl_object output;
c/read.c:	cl_object __value0 = output;
c/read.c:static cl_object
c/read.c:dispatch_reader_fun(cl_object in, cl_object dc)
c/read.c:  cl_object readtable = ecl_current_readtable();
c/read.c:  cl_object dispatch_table;
c/read.c:static cl_object
c/read.c:dispatch_macro_character(cl_object table, cl_object in, int c, bool signal_error)
c/read.c:  cl_object arg;
c/read.c:    cl_object dc = ECL_CODE_CHAR(c);
c/read.c:    cl_object fun = ecl_gethash_safe(dc, table, ECL_NIL);
c/read.c:static cl_object
c/read.c:single_quote_reader(cl_object in, cl_object c)
c/read.c:	cl_object __value0 = cl_list(2, ECL_SYM("QUOTE",681), c);
c/read.c:static cl_object
c/read.c:void_reader(cl_object in, cl_object c)
c/read.c:static cl_object
c/read.c:semicolon_reader(cl_object in, cl_object c)
c/read.c:static cl_object
c/read.c:sharp_generic_error(cl_object in, cl_object c, cl_object n)
c/read.c:static cl_object
c/read.c:sharp_C_reader(cl_object in, cl_object c, cl_object d)
c/read.c:  cl_object x, real, imag;
c/read.c:	cl_object __value0 = ECL_NIL;
c/read.c:	cl_object __value0 = x;
c/read.c:static cl_object
c/read.c:sharp_backslash_reader(cl_object in, cl_object c, cl_object d)
c/read.c:  cl_object token;
c/read.c:    cl_object nc = cl_name_char(token);
c/read.c:static cl_object
c/read.c:sharp_single_quote_reader(cl_object in, cl_object c, cl_object d)
c/read.c:	cl_object __value0 = c;
c/read.c:static cl_object
c/read.c:sharp_Y_reader(cl_object in, cl_object c, cl_object d)
c/read.c:  cl_object x, rv, nth, lex;
c/read.c:	cl_object __value0 = ECL_NIL;
c/read.c:    cl_object x = ecl_alloc_object(t_bclosure);
c/read.c:	cl_object __value0 = rv;
c/read.c:cl_object
c/read.c:si_make_backq_vector(cl_object d, cl_object data, cl_object in)
c/read.c:  cl_object v, last;
c/read.c:static cl_object
c/read.c:sharp_left_parenthesis_reader(cl_object in, cl_object c, cl_object d)
c/read.c:  extern int _cl_backq_car(cl_object *);
c/read.c:  cl_object v;
c/read.c:    cl_object x = do_read_delimited_list(')', in, 1);
c/read.c:    cl_object last;
c/read.c:      cl_object aux = ecl_read_object_with_delimiter(in, ')', 0,
c/read.c:	cl_object __value0 = v;
c/read.c:static cl_object
c/read.c:sharp_asterisk_reader(cl_object in, cl_object c, cl_object d)
c/read.c:  cl_object last, elt, x;
c/read.c:  cl_object rtbl = ecl_current_readtable();
c/read.c:	cl_object __value0 = ECL_NIL;
c/read.c:	cl_object __value0 = x;
c/read.c:static cl_object
c/read.c:sharp_colon_reader(cl_object in, cl_object ch, cl_object d)
c/read.c:  cl_object rtbl = ecl_current_readtable();
c/read.c:  cl_object output, token;
c/read.c:	cl_object __value0 = output;
c/read.c:static cl_object
c/read.c:sharp_dot_reader(cl_object in, cl_object c, cl_object d)
c/read.c:	cl_object __value0 = ECL_NIL;
c/read.c:	cl_object __value0 = c;
c/read.c:static cl_object
c/read.c:read_number(cl_object in, int radix, cl_object macro_char)
c/read.c:  cl_object x;
c/read.c:  cl_object token = read_constituent(in);
c/read.c:static cl_object
c/read.c:sharp_B_reader(cl_object in, cl_object c, cl_object d)
c/read.c:	cl_object __value0 = (read_number(in, 2, ECL_CODE_CHAR('B')));
c/read.c:static cl_object
c/read.c:sharp_O_reader(cl_object in, cl_object c, cl_object d)
c/read.c:	cl_object __value0 = (read_number(in, 8, ECL_CODE_CHAR('O')));
c/read.c:static cl_object
c/read.c:sharp_X_reader(cl_object in, cl_object c, cl_object d)
c/read.c:	cl_object __value0 = (read_number(in, 16, ECL_CODE_CHAR('X')));
c/read.c:static cl_object
c/read.c:sharp_R_reader(cl_object in, cl_object c, cl_object d)
c/read.c:	cl_object __value0 = (read_number(in, radix, ECL_CODE_CHAR('R')));
c/read.c:static cl_object
c/read.c:sharp_eq_reader(cl_object in, cl_object c, cl_object d)
c/read.c:  cl_object pair, value;
c/read.c:  cl_object sharp_eq_context = ECL_SYM_VAL(the_env, ECL_SYM("SI::*SHARP-EQ-CONTEXT*",1032));
c/read.c:static cl_object
c/read.c:sharp_sharp_reader(cl_object in, cl_object c, cl_object d)
c/read.c:  cl_object pair;
c/read.c:    cl_object value = ECL_CONS_CDR(pair);
c/read.c:static cl_object
c/read.c:do_patch_sharp(cl_object x, cl_object table)
c/read.c:  cl_object first_cons = OBJNULL;
c/read.c:  cl_object current_cons = OBJNULL;
c/read.c:    cl_object y;
c/read.c:    cl_object y = ecl_gethash_safe(x, table, table);
c/read.c:    cl_object rest = ECL_CONS_CDR(x);
c/read.c:    cl_object r = do_patch_sharp(x->gencomplex.real, table);
c/read.c:    cl_object i = do_patch_sharp(x->gencomplex.imag, table);
c/read.c:      cl_object c = ecl_make_complex(r, i);
c/read.c:static cl_object
c/read.c:patch_sharp(const cl_env_ptr the_env, cl_object x)
c/read.c:  cl_object pairs = ECL_SYM_VAL(the_env, ECL_SYM("SI::*SHARP-EQ-CONTEXT*",1032));
c/read.c:    cl_object table = 
c/read.c:      cl_object pair = ECL_CONS_CAR(pairs);
c/read.c:static cl_object
c/read.c:sharp_vertical_bar_reader(cl_object in, cl_object ch, cl_object d)
c/read.c:static cl_object
c/read.c:default_dispatch_macro_fun(cl_object in, cl_object c, cl_object d)
c/read.c:static cl_object
c/read.c:sharp_P_reader(cl_object in, cl_object c, cl_object d)
c/read.c:	cl_object __value0 = d;
c/read.c:static cl_object
c/read.c:sharp_dollar_reader(cl_object in, cl_object c, cl_object d)
c/read.c:  cl_object rs;
c/read.c:	cl_object __value0 = rs;
c/read.c:assert_type_readtable(cl_object function, cl_narg narg, cl_object p)
c/read.c:cl_object
c/read.c:ecl_copy_readtable(cl_object from, cl_object to)
c/read.c:  cl_object output;
c/read.c:    cl_object d = from_rtab[i].dispatch;
c/read.c:cl_object
c/read.c:  cl_object r;
c/read.c:  cl_object x = ECL_SYM_VAL(the_env, ECL_SYM("*READ-BASE*",63));
c/read.c:  cl_object x;
c/read.c:static cl_object
c/read.c:stream_or_default_input(cl_object stream)
c/read.c:cl_object cl_read(cl_narg narg, ...)
c/read.c:  cl_object x;
c/read.c:	cl_object strm;
c/read.c:	cl_object eof_errorp;
c/read.c:	cl_object eof_value;
c/read.c:	cl_object recursivep;
c/read.c:		strm = va_arg(ARGS,cl_object);
c/read.c:		eof_errorp = va_arg(ARGS,cl_object);
c/read.c:		eof_value = va_arg(ARGS,cl_object);
c/read.c:		recursivep = va_arg(ARGS,cl_object);
c/read.c:	cl_object __value0 = eof_value;
c/read.c:    cl_object rtbl = ecl_current_readtable();
c/read.c:	cl_object __value0 = x;
c/read.c:cl_object cl_read_preserving_whitespace(cl_narg narg, ...)
c/read.c:  cl_object x;
c/read.c:	cl_object strm;
c/read.c:	cl_object eof_errorp;
c/read.c:	cl_object eof_value;
c/read.c:	cl_object recursivep;
c/read.c:		strm = va_arg(ARGS,cl_object);
c/read.c:		eof_errorp = va_arg(ARGS,cl_object);
c/read.c:		eof_value = va_arg(ARGS,cl_object);
c/read.c:		recursivep = va_arg(ARGS,cl_object);
c/read.c:	cl_object __value0 = eof_value;
c/read.c:	cl_object __value0 = x;
c/read.c:static cl_object
c/read.c:do_read_delimited_list(int d, cl_object in, bool proper_list)
c/read.c:  cl_object x, y = ECL_NIL;
c/read.c:  cl_object *p = &y;
c/read.c:cl_object cl_read_delimited_list(cl_narg narg, cl_object d, ...)
c/read.c:  cl_object l;
c/read.c:	cl_object strm;
c/read.c:	cl_object recursivep;
c/read.c:		strm = va_arg(ARGS,cl_object);
c/read.c:		recursivep = va_arg(ARGS,cl_object);
c/read.c:	cl_object __value0 = l;
c/read.c:cl_object cl_read_line(cl_narg narg, ...)
c/read.c:  cl_object token, value0, value1;
c/read.c:	cl_object strm;
c/read.c:	cl_object eof_errorp;
c/read.c:	cl_object eof_value;
c/read.c:	cl_object recursivep;
c/read.c:		strm = va_arg(ARGS,cl_object);
c/read.c:		eof_errorp = va_arg(ARGS,cl_object);
c/read.c:		eof_value = va_arg(ARGS,cl_object);
c/read.c:		recursivep = va_arg(ARGS,cl_object);
c/read.c:	cl_object __value0 = value0;
c/read.c:	cl_object __value1 = value1;
c/read.c:cl_object cl_read_char(cl_narg narg, ...)
c/read.c:  cl_object output;
c/read.c:	cl_object strm;
c/read.c:	cl_object eof_errorp;
c/read.c:	cl_object eof_value;
c/read.c:	cl_object recursivep;
c/read.c:		strm = va_arg(ARGS,cl_object);
c/read.c:		eof_errorp = va_arg(ARGS,cl_object);
c/read.c:		eof_value = va_arg(ARGS,cl_object);
c/read.c:		recursivep = va_arg(ARGS,cl_object);
c/read.c:	cl_object __value0 = output;
c/read.c:cl_object cl_unread_char(cl_narg narg, cl_object c, ...)
c/read.c:	cl_object strm;
c/read.c:		strm = va_arg(ARGS,cl_object);
c/read.c:	cl_object __value0 = ECL_NIL;
c/read.c:cl_object cl_peek_char(cl_narg narg, ...)
c/read.c:  cl_object rtbl = ecl_current_readtable();
c/read.c:	cl_object peek_type;
c/read.c:	cl_object strm;
c/read.c:	cl_object eof_errorp;
c/read.c:	cl_object eof_value;
c/read.c:	cl_object recursivep;
c/read.c:		peek_type = va_arg(ARGS,cl_object);
c/read.c:		strm = va_arg(ARGS,cl_object);
c/read.c:		eof_errorp = va_arg(ARGS,cl_object);
c/read.c:		eof_value = va_arg(ARGS,cl_object);
c/read.c:		recursivep = va_arg(ARGS,cl_object);
c/read.c:	cl_object __value0 = eof_value;
c/read.c:cl_object cl_listen(cl_narg narg, ...)
c/read.c:	cl_object strm;
c/read.c:		strm = va_arg(ARGS,cl_object);
c/read.c:	cl_object __value0 = ((ecl_listen_stream(strm) == ECL_LISTEN_AVAILABLE)? ECL_T : ECL_NIL);
c/read.c:cl_object cl_read_char_no_hang(cl_narg narg, ...)
c/read.c:	cl_object strm;
c/read.c:	cl_object eof_errorp;
c/read.c:	cl_object eof_value;
c/read.c:	cl_object recursivep;
c/read.c:		strm = va_arg(ARGS,cl_object);
c/read.c:		eof_errorp = va_arg(ARGS,cl_object);
c/read.c:		eof_value = va_arg(ARGS,cl_object);
c/read.c:		recursivep = va_arg(ARGS,cl_object);
c/read.c:    cl_object output =
c/read.c:	cl_object __value0 = output;
c/read.c:	cl_object __value0 = ECL_CODE_CHAR(c);
c/read.c:	cl_object __value0 = ECL_NIL;
c/read.c:	cl_object __value0 = eof_value;
c/read.c:cl_object cl_clear_input(cl_narg narg, ...)
c/read.c:	cl_object strm;
c/read.c:		strm = va_arg(ARGS,cl_object);
c/read.c:	cl_object __value0 = ECL_NIL;
c/read.c:cl_object cl_read_byte(cl_narg narg, cl_object binary_input_stream, ...)
c/read.c:  cl_object c;
c/read.c:	cl_object eof_errorp;
c/read.c:	cl_object eof_value;
c/read.c:		eof_errorp = va_arg(ARGS,cl_object);
c/read.c:		eof_value = va_arg(ARGS,cl_object);
c/read.c:	cl_object __value0 = eof_value;
c/read.c:	cl_object __value0 = c;
c/read.c:cl_object cl_read_sequence(cl_narg narg, cl_object sequence, cl_object stream, ...)
c/read.c:	static cl_object KEYS[2] = {(cl_object)(cl_symbols+1337), (cl_object)(cl_symbols+1247)};
c/read.c:	cl_object start;
c/read.c:	cl_object end;
c/read.c:	cl_object KEY_VARS[4];
c/read.c:		cl_object __value0 = si_do_read_sequence(sequence, stream, start, end);
c/read.c:cl_object cl_copy_readtable(cl_narg narg, ...)
c/read.c:	cl_object from;
c/read.c:	cl_object to;
c/read.c:		from = va_arg(ARGS,cl_object);
c/read.c:		to = va_arg(ARGS,cl_object);
c/read.c:	cl_object __value0 = to;
c/read.c:cl_object
c/read.c:cl_readtable_case(cl_object r)
c/read.c:	cl_object __value0 = r;
c/read.c:error_locked_readtable(cl_object r)
c/read.c:cl_object
c/read.c:si_readtable_case_set(cl_object r, cl_object mode)
c/read.c:	cl_object __value0 = mode;
c/read.c:cl_object
c/read.c:cl_readtablep(cl_object readtable)
c/read.c:	cl_object __value0 = (ECL_READTABLEP(readtable) ? ECL_T : ECL_NIL);
c/read.c:ecl_readtable_get(cl_object readtable, int c, cl_object *macro_or_table)
c/read.c:  cl_object m;
c/read.c:    cl_object hash = readtable->readtable.hash;
c/read.c:      cl_object pair = ecl_gethash_safe(ECL_CODE_CHAR(c), hash, ECL_NIL);
c/read.c:ecl_readtable_set(cl_object readtable, int c, enum ecl_chattrib cat,
c/read.c:                  cl_object macro_or_table)
c/read.c:    cl_object hash = readtable->readtable.hash;
c/read.c:cl_object cl_set_syntax_from_char(cl_narg narg, cl_object tochr, cl_object fromchr, ...)
c/read.c:  cl_object dispatch;
c/read.c:	cl_object tordtbl;
c/read.c:	cl_object fromrdtbl;
c/read.c:		tordtbl = va_arg(ARGS,cl_object);
c/read.c:		fromrdtbl = va_arg(ARGS,cl_object);
c/read.c:	cl_object __value0 = ECL_T;
c/read.c:cl_object cl_set_macro_character(cl_narg narg, cl_object c, cl_object function, ...)
c/read.c:	cl_object non_terminating_p;
c/read.c:	cl_object readtable;
c/read.c:		non_terminating_p = va_arg(ARGS,cl_object);
c/read.c:		readtable = va_arg(ARGS,cl_object);
c/read.c:	cl_object __value0 = ECL_T;
c/read.c:cl_object cl_get_macro_character(cl_narg narg, cl_object c, ...)
c/read.c:  cl_object dispatch;
c/read.c:	cl_object readtable;
c/read.c:		readtable = va_arg(ARGS,cl_object);
c/read.c:	cl_object __value0 = dispatch;
c/read.c:	cl_object __value1 = ((cat == cat_non_terminating)? ECL_T : ECL_NIL);
c/read.c:cl_object cl_make_dispatch_macro_character(cl_narg narg, cl_object chr, ...)
c/read.c:  cl_object table;
c/read.c:	cl_object non_terminating_p;
c/read.c:	cl_object readtable;
c/read.c:		non_terminating_p = va_arg(ARGS,cl_object);
c/read.c:		readtable = va_arg(ARGS,cl_object);
c/read.c:	cl_object __value0 = ECL_T;
c/read.c:cl_object cl_set_dispatch_macro_character(cl_narg narg, cl_object dspchr, cl_object subchr, cl_object fnc, ...)
c/read.c:  cl_object table;
c/read.c:	cl_object readtable;
c/read.c:		readtable = va_arg(ARGS,cl_object);
c/read.c:	cl_object __value0 = ECL_T;
c/read.c:cl_object cl_get_dispatch_macro_character(cl_narg narg, cl_object dspchr, cl_object subchr, ...)
c/read.c:  cl_object table;
c/read.c:	cl_object readtable;
c/read.c:		readtable = va_arg(ARGS,cl_object);
c/read.c:	cl_object __value0 = ECL_NIL;
c/read.c:	cl_object __value0 = ecl_gethash_safe(subchr, table, ECL_NIL);
c/read.c:cl_object
c/read.c:	cl_object __value0 = cl_core.standard_readtable;
c/read.c:cl_object si_readtable_lock(cl_narg narg, cl_object r, ...)
c/read.c:  cl_object output;
c/read.c:	cl_object yesno;
c/read.c:		yesno = va_arg(ARGS,cl_object);
c/read.c:	cl_object __value0 = output;
c/read.c:extra_argument(int c, cl_object stream, cl_object d)
c/read.c:  cl_object r;
c/read.c:    cl_object var, val;
c/read.c:static cl_object
c/read.c:make_one_data_stream(const cl_object string)
c/read.c:static cl_object
c/read.c:make_data_stream(const cl_object *data)
c/read.c:    cl_object stream_list = ECL_NIL;
c/read.c:      cl_object s = make_one_data_stream(data[i]);
c/read.c:cl_object
c/read.c:ecl_init_module(cl_object block, void (*entry_point)(cl_object))
c/read.c:  volatile cl_object old_eptbc = env->packages_to_be_created;
c/read.c:  volatile cl_object x;
c/read.c:  cl_object in;
c/read.c:  cl_object *VV = NULL, *VVtemp = NULL;
c/read.c:    cl_object progv_list;
c/read.c:        cl_object v = ECL_SYM_VAL(env,ECL_SYM("SI::*COMPILER-CONSTANTS*",1019));
c/read.c:    VV = block->cblock.data = perm_len? (cl_object *)ecl_alloc(perm_len * sizeof(cl_object)) : NULL;
c/read.c:    VVtemp = block->cblock.temp_data = temp_len? (cl_object *)ecl_alloc(temp_len * sizeof(cl_object)) : NULL;
c/read.c:        cl_object v = si_deserialize(*(block->cblock.data_text));
c/read.c:        memcpy(VV, v->vector.self.t, perm_len * sizeof(cl_object));
c/read.c:        memcpy(VVtemp, v->vector.self.t + perm_len, temp_len * sizeof(cl_object));
c/read.c:      cl_object fname = VV[fname_location];
c/read.c:      cl_object position = prototype->file_position;
c/read.c:        ecl_make_cfun_va((cl_objectfn)prototype->entry,
c/read.c:        ecl_make_cfun((cl_objectfn_fixed)prototype->entry,
c/reference.c:cl_object
c/reference.c:cl_symbol_function(cl_object sym)
c/reference.c:  cl_object output;
c/reference.c:	cl_object __value0 = output;
c/reference.c:cl_object
c/reference.c:cl_fdefinition(cl_object fname)
c/reference.c:	cl_object __value0 = ((ECL_SYMBOLP(fname))? cl_symbol_function(fname) : ecl_fdefinition(fname));
c/reference.c:cl_object
c/reference.c:cl_fboundp(cl_object fname)
c/reference.c:	cl_object __value0 = ECL_NIL;
c/reference.c:	cl_object __value0 = (((fname->symbol.stype & ecl_stp_special_form)
c/reference.c:      cl_object sym = CDR(fname);
c/reference.c:        cl_object pair;
c/reference.c:	cl_object __value0 = ecl_cdr(pair);
c/reference.c:cl_object
c/reference.c:ecl_fdefinition(cl_object fun)
c/reference.c:  cl_object output;
c/reference.c:    cl_object sym = CDR(fun);
c/reference.c:cl_object
c/reference.c:si_coerce_to_function(cl_object fun)
c/reference.c:	cl_object __value0 = fun;
c/reference.c:cl_object
c/reference.c:cl_symbol_value(cl_object sym)
c/reference.c:  cl_object value;
c/reference.c:	cl_object __value0 = value;
c/reference.c:ecl_boundp(cl_env_ptr env, cl_object sym)
c/reference.c:cl_object
c/reference.c:cl_boundp(cl_object sym)
c/reference.c:cl_object
c/reference.c:cl_special_operator_p(cl_object form)
c/round.c:cl_object cl_round(cl_narg narg, cl_object x, ...)
c/round.c:	cl_object y;
c/round.c:		y = va_arg(ARGS,cl_object);
c/round.c:static cl_object
c/round.c:number_remainder(cl_object x, cl_object y, cl_object q)
c/round.c:  cl_object z;
c/round.c:static cl_object
c/round.c:ecl_round2_integer(const cl_env_ptr the_env, cl_object x, cl_object y, cl_object q)
c/round.c:  cl_object q1 = ecl_integer_divide(q->ratio.num, q->ratio.den);
c/round.c:  cl_object r = ecl_minus(q, q1);
c/round.c:cl_object
c/round.c:ecl_round1(cl_object x)
c/round.c:  cl_object v0, v1;
c/round.c:cl_object
c/round.c:ecl_round2(cl_object x, cl_object y)
c/round.c:  cl_object v0, v1;
c/round.c:  cl_object q;
c/rwlock.c:FEerror_not_a_rwlock(cl_object lock)
c/rwlock.c:FEunknown_rwlock_error(cl_object lock, int rc)
c/rwlock.c:cl_object
c/rwlock.c:ecl_make_rwlock(cl_object name)
c/rwlock.c:  cl_object output = ecl_alloc_object(t_rwlock);
c/rwlock.c:cl_object mp_make_rwlock(cl_narg narg, ...)
c/rwlock.c:	static cl_object KEYS[1] = {(cl_object)(cl_symbols+1300)};
c/rwlock.c:	cl_object name;
c/rwlock.c:	cl_object KEY_VARS[2];
c/rwlock.c:	cl_object __value0 = ecl_make_rwlock(name);
c/rwlock.c:cl_object
c/rwlock.c:mp_rwlock_name(cl_object lock)
c/rwlock.c:cl_object
c/rwlock.c:mp_giveup_rwlock_read(cl_object lock)
c/rwlock.c:	cl_object __value0 = ECL_T;
c/rwlock.c:cl_object
c/rwlock.c:mp_giveup_rwlock_write(cl_object lock)
c/rwlock.c:cl_object
c/rwlock.c:mp_get_rwlock_read_nowait(cl_object lock)
c/rwlock.c:    cl_object output = ECL_T;
c/rwlock.c:cl_object
c/rwlock.c:mp_get_rwlock_read_wait(cl_object lock)
c/rwlock.c:cl_object mp_get_rwlock_read(cl_narg narg, cl_object lock, ...)
c/rwlock.c:	cl_object wait;
c/rwlock.c:		wait = va_arg(ARGS,cl_object);
c/rwlock.c:cl_object
c/rwlock.c:mp_get_rwlock_write_nowait(cl_object lock)
c/rwlock.c:    cl_object output = ECL_T;
c/rwlock.c:cl_object
c/rwlock.c:mp_get_rwlock_write_wait(cl_object lock)
c/rwlock.c:	cl_object __value0 = ECL_T;
c/rwlock.c:cl_object mp_get_rwlock_write(cl_narg narg, cl_object lock, ...)
c/rwlock.c:	cl_object wait;
c/rwlock.c:		wait = va_arg(ARGS,cl_object);
c/semaphore.c:FEerror_not_a_semaphore(cl_object semaphore)
c/semaphore.c:cl_object
c/semaphore.c:ecl_make_semaphore(cl_object name, cl_fixnum count)
c/semaphore.c:  cl_object output = ecl_alloc_object(t_semaphore);
c/semaphore.c:cl_object mp_make_semaphore(cl_narg narg, ...)
c/semaphore.c:	static cl_object KEYS[2] = {(cl_object)(cl_symbols+1300), (cl_object)(cl_symbols+1487)};
c/semaphore.c:	cl_object name;
c/semaphore.c:	cl_object count;
c/semaphore.c:	cl_object KEY_VARS[4];
c/semaphore.c:	cl_object __value0 = ecl_make_semaphore(name, fixnnint(count));
c/semaphore.c:cl_object
c/semaphore.c:mp_semaphore_name(cl_object semaphore)
c/semaphore.c:cl_object
c/semaphore.c:mp_semaphore_count(cl_object semaphore)
c/semaphore.c:cl_object
c/semaphore.c:mp_semaphore_wait_count(cl_object semaphore)
c/semaphore.c:cl_object mp_signal_semaphore(cl_narg narg, cl_object semaphore, ...)
c/semaphore.c:	cl_object count;
c/semaphore.c:		count = va_arg(ARGS,cl_object);
c/semaphore.c:static cl_object
c/semaphore.c:get_semaphore_inner(cl_env_ptr env, cl_object semaphore)
c/semaphore.c:  cl_object output;
c/semaphore.c:cl_object
c/semaphore.c:mp_wait_on_semaphore(cl_object semaphore)
c/semaphore.c:  cl_object output;
c/semaphore.c:cl_object
c/semaphore.c:mp_try_get_semaphore(cl_object semaphore)
c/sequence.c:ecl_sequence_start_end(cl_object fun, cl_object sequence,
c/sequence.c:                       cl_object start, cl_object end)
c/sequence.c:      cl_object fillp = ecl_make_fixnum(l);
c/sequence.c:cl_object
c/sequence.c:si_sequence_start_end(cl_object fun, cl_object sequence, cl_object start, cl_object end)
c/sequence.c:	cl_object __value0 = ecl_make_fixnum(p.start);
c/sequence.c:	cl_object __value1 = ecl_make_fixnum(p.end);
c/sequence.c:	cl_object __value2 = ecl_make_fixnum(p.length);
c/sequence.c:cl_object
c/sequence.c:cl_elt(cl_object x, cl_object i)
c/sequence.c:	cl_object __value0 = ecl_elt(x, ecl_to_size(i));
c/sequence.c:cl_object
c/sequence.c:ecl_elt(cl_object seq, cl_fixnum index)
c/sequence.c:  cl_object l;
c/sequence.c:cl_object
c/sequence.c:si_elt_set(cl_object seq, cl_object index, cl_object val)
c/sequence.c:	cl_object __value0 = ecl_elt_set(seq, ecl_to_size(index), val);
c/sequence.c:cl_object
c/sequence.c:ecl_elt_set(cl_object seq, cl_fixnum index, cl_object val)
c/sequence.c:  cl_object l;
c/sequence.c:cl_object
c/sequence.c:ecl_subseq(cl_object sequence, cl_index start, cl_index limit)
c/sequence.c:      cl_object x = ECL_NIL;
c/sequence.c:      cl_object *z = &x;
c/sequence.c:    cl_object x;
c/sequence.c:cl_object
c/sequence.c:ecl_copy_seq(cl_object sequence)
c/sequence.c:cl_object cl_subseq(cl_narg narg, cl_object sequence, cl_object start, ...)
c/sequence.c:	cl_object end;
c/sequence.c:		end = va_arg(ARGS,cl_object);
c/sequence.c:	cl_object __value0 = sequence;
c/sequence.c:cl_object
c/sequence.c:cl_copy_seq(cl_object x)
c/sequence.c:	cl_object __value0 = ecl_subseq(x, 0, MOST_POSITIVE_FIXNUM);
c/sequence.c:cl_object
c/sequence.c:cl_length(cl_object x)
c/sequence.c:	cl_object __value0 = ecl_make_fixnum(ecl_length(x));
c/sequence.c:ecl_length(cl_object x)
c/sequence.c:cl_object
c/sequence.c:cl_reverse(cl_object seq)
c/sequence.c:  cl_object output, x;
c/sequence.c:	cl_object __value0 = output;
c/sequence.c:cl_object
c/sequence.c:cl_nreverse(cl_object seq)
c/sequence.c:    cl_object x, y, z;
c/sequence.c:	cl_object __value0 = seq;
c/serialize.c:  cl_object name;
c/serialize.c:  cl_object name;
c/serialize.c:  cl_object pack;
c/serialize.c:  cl_object data; /* vector of bytes containing the serialized objects */
c/serialize.c:  cl_object hash; /* hashtable mapping already serialized objects to indices in data */
c/serialize.c:  cl_object queue; /* queue of objects to be serialized */
c/serialize.c:  cl_object last; /* last cons cell of queue */
c/serialize.c:static cl_object
c/serialize.c:fix_to_ptr(cl_object ptr)
c/serialize.c:  return (cl_object)(i & ~ECL_IMMEDIATE_TAG);
c/serialize.c:static cl_object
c/serialize.c:enqueue(pool_t pool, cl_object what)
c/serialize.c:  cl_object index;
c/serialize.c:    cl_object cons;
c/serialize.c:  cl_object car, cdr;
c/serialize.c:serialize_object_ptr(pool_t pool, cl_object *ptr, cl_index dim)
c/serialize.c:  cl_index index = serialize_bits(pool, ptr, dim*sizeof(cl_object));
c/serialize.c:  for (; dim; dim--, index += sizeof(cl_object)) {
c/serialize.c:    cl_object *p = (cl_object *)(pool->data->vector.self.b8 + index);
c/serialize.c:static void serialize_vector(pool_t pool, cl_object v);
c/serialize.c:serialize_displaced_vector(pool_t pool, cl_object v)
c/serialize.c:  cl_object disp = v->vector.displaced;
c/serialize.c:  cl_object to = ECL_CONS_CAR(disp);
c/serialize.c:vector_self_size(cl_object v) {
c/serialize.c:serialize_vector(pool_t pool, cl_object v)
c/serialize.c:serialize_hashtable(pool_t pool, cl_object h)
c/serialize.c:serialize_one(pool_t pool, cl_object what)
c/serialize.c:  cl_object buffer;
c/serialize.c:  buffer = (cl_object)(pool->data->vector.self.b8 + index);
c/serialize.c:    buffer = (cl_object)(pool->data->vector.self.b8 + index);
c/serialize.c:init_pool(pool_t pool, cl_object root)
c/serialize.c:static cl_object
c/serialize.c:cl_object
c/serialize.c:si_serialize(cl_object root)
c/serialize.c:    cl_object what = ECL_CONS_CAR(pool->queue);
c/serialize.c:	cl_object __value0 = close_pool(pool);
c/serialize.c:reconstruct_bytecodes(cl_object o, uint8_t *data)
c/serialize.c:reconstruct_vector(cl_object v, uint8_t *data)
c/serialize.c:reconstruct_array(cl_object a, uint8_t *data)
c/serialize.c:reconstruct_hashtable(cl_object h, uint8_t *data)
c/serialize.c:duplicate_object(uint8_t *data, cl_object *output)
c/serialize.c:  cl_type t = ecl_t_of((cl_object)data);
c/serialize.c:  cl_object o = ecl_alloc_object(t);
c/serialize.c:reconstruct_one(uint8_t *data, cl_object *output)
c/serialize.c:  cl_object o = (cl_object)data;
c/serialize.c:    cl_object car = c->car;
c/serialize.c:    cl_object cdr = c->cdr;
c/serialize.c:    if (car == (cl_object) 0 && cdr == (cl_object) 0) {
c/serialize.c:    *output = (cl_object)data;
c/serialize.c:    *output = (cl_object)data;
c/serialize.c:static cl_object
c/serialize.c:get_object(cl_object o_or_index, cl_object *o_list)
c/serialize.c:fixup_vector(cl_object v, cl_object *o_list)
c/serialize.c:    cl_object to = get_object(v->vector.displaced, o_list);
c/serialize.c:    cl_object *p = v->vector.self.t;
c/serialize.c:fixup_hashtable(cl_object h, cl_object *o_list)
c/serialize.c:fixup(cl_object o, cl_object *o_list)
c/serialize.c:cl_object
c/serialize.c:  cl_object *output = ecl_alloc(sizeof(cl_object) * num_el);
c/serialize.c:    cl_object package = output[i];
c/serialize.c:      cl_object name = get_object(package->pack.name,
c/serialize.c:    cl_object symbol = output[i];
c/serialize.c:      cl_object name = get_object(s->name, output);
c/serialize.c:      cl_object pack = get_object(s->pack, output);
c/serialize.c:cl_object
c/serialize.c:si_deserialize(cl_object data)
c/serialize.c:	cl_object __value0 = ecl_deserialize(data->vector.self.b8);
c/sin.c:cl_object
c/sin.c:cl_sin(cl_object x)
c/sin.c:	cl_object __value0 = ecl_sin(x);
c/sin.c:static cl_object
c/sin.c:ecl_sin_rational(cl_object x)
c/sin.c:static cl_object
c/sin.c:ecl_sin_single_float(cl_object x)
c/sin.c:static cl_object
c/sin.c:ecl_sin_double_float(cl_object x)
c/sin.c:static cl_object
c/sin.c:ecl_sin_long_float(cl_object x)
c/sin.c:static cl_object
c/sin.c:ecl_sin_complex(cl_object x)
c/sin.c:  cl_object dx = x->gencomplex.real;
c/sin.c:  cl_object dy = x->gencomplex.imag;
c/sin.c:  cl_object a = ecl_times(ecl_sin(dx), ecl_cosh(dy));
c/sin.c:  cl_object b = ecl_times(ecl_cos(dx), ecl_sinh(dy));
c/sin.c:static cl_object
c/sin.c:ecl_sin_csfloat(cl_object x)
c/sin.c:  cl_object result = ecl_alloc_object(t_csfloat);
c/sin.c:static cl_object
c/sin.c:ecl_sin_cdfloat(cl_object x)
c/sin.c:  cl_object result = ecl_alloc_object(t_cdfloat);
c/sin.c:static cl_object
c/sin.c:ecl_sin_clfloat(cl_object x)
c/sin.c:  cl_object result = ecl_alloc_object(t_clfloat);
c/sinh.c:cl_object
c/sinh.c:cl_sinh(cl_object x)
c/sinh.c:	cl_object __value0 = ecl_sinh(x);
c/sinh.c:static cl_object
c/sinh.c:ecl_sinh_rational(cl_object x)
c/sinh.c:static cl_object
c/sinh.c:ecl_sinh_single_float(cl_object x)
c/sinh.c:static cl_object
c/sinh.c:ecl_sinh_double_float(cl_object x)
c/sinh.c:static cl_object
c/sinh.c:ecl_sinh_long_float(cl_object x)
c/sinh.c:static cl_object
c/sinh.c:ecl_sinh_complex(cl_object x)
c/sinh.c:  cl_object dx = x->gencomplex.real;
c/sinh.c:  cl_object dy = x->gencomplex.imag;
c/sinh.c:  cl_object a = ecl_times(ecl_sinh(dx), ecl_cos(dy));
c/sinh.c:  cl_object b = ecl_times(ecl_cosh(dx), ecl_sin(dy));
c/sinh.c:static cl_object
c/sinh.c:ecl_sinh_csfloat(cl_object x)
c/sinh.c:  cl_object result = ecl_alloc_object(t_csfloat);
c/sinh.c:static cl_object
c/sinh.c:ecl_sinh_cdfloat(cl_object x)
c/sinh.c:  cl_object result = ecl_alloc_object(t_cdfloat);
c/sinh.c:static cl_object
c/sinh.c:ecl_sinh_clfloat(cl_object x)
c/sinh.c:  cl_object result = ecl_alloc_object(t_clfloat);
c/sqrt.c:cl_object
c/sqrt.c:cl_sqrt(cl_object x)
c/sqrt.c:	cl_object __value0 = ecl_sqrt(x);
c/sqrt.c:static cl_object
c/sqrt.c:ecl_sqrt_rational(cl_object x)
c/sqrt.c:static cl_object
c/sqrt.c:ecl_sqrt_single_float(cl_object x)
c/sqrt.c:static cl_object
c/sqrt.c:ecl_sqrt_double_float(cl_object x)
c/sqrt.c:static cl_object
c/sqrt.c:ecl_sqrt_long_float(cl_object x)
c/sqrt.c:static cl_object
c/sqrt.c:ecl_sqrt_complex(cl_object x)
c/sqrt.c:static cl_object
c/sqrt.c:ecl_sqrt_csfloat(cl_object x)
c/sqrt.c:  cl_object result = ecl_alloc_object(t_csfloat);
c/sqrt.c:static cl_object
c/sqrt.c:ecl_sqrt_cdfloat(cl_object x)
c/sqrt.c:  cl_object result = ecl_alloc_object(t_cdfloat);
c/sqrt.c:static cl_object
c/sqrt.c:ecl_sqrt_clfloat(cl_object x)
c/sqrt.c:  cl_object result = ecl_alloc_object(t_clfloat);
c/stacks.c:ecl_progv(cl_env_ptr env, cl_object vars0, cl_object values0)
c/stacks.c:  cl_object vars = vars0, values = values0;
c/stacks.c:      cl_object var = ECL_CONS_CAR(vars);
c/stacks.c:get_bds_ptr(cl_object x)
c/stacks.c:cl_object
c/stacks.c:	cl_object __value0 = ecl_make_fixnum(env->bds_top - env->bds_org);
c/stacks.c:cl_object
c/stacks.c:si_bds_var(cl_object arg)
c/stacks.c:	cl_object __value0 = get_bds_ptr(arg)->symbol;
c/stacks.c:cl_object
c/stacks.c:si_bds_val(cl_object arg)
c/stacks.c:  cl_object v = get_bds_ptr(arg)->value;
c/stacks.c:	cl_object __value0 = ((v == OBJNULL || v == ECL_NO_TL_BINDING)? ECL_UNBOUND : v);
c/stacks.c:ecl_new_binding_index(cl_env_ptr env, cl_object symbol)
c/stacks.c:  cl_object pool;
c/stacks.c:static cl_object
c/stacks.c:ecl_extend_bindings_array(cl_object vector)
c/stacks.c:  cl_object new_vector = si_make_vector(ECL_T, ecl_make_fixnum(new_size), ECL_NIL,
c/stacks.c:invalid_or_too_large_binding_index(cl_env_ptr env, cl_object s)
c/stacks.c:    cl_object vector = env->bindings_array;
c/stacks.c:ecl_bds_bind(cl_env_ptr env, cl_object s, cl_object v)
c/stacks.c:  cl_object *location;
c/stacks.c:ecl_bds_push(cl_env_ptr env, cl_object s)
c/stacks.c:  cl_object *location;
c/stacks.c:  cl_object s = env->bds_top->symbol;
c/stacks.c:  cl_object *location = env->thread_local_bindings + s->symbol.binding;
c/stacks.c:cl_object
c/stacks.c:ecl_bds_read(cl_env_ptr env, cl_object s)
c/stacks.c:    cl_object x = env->thread_local_bindings[index];
c/stacks.c:cl_object *
c/stacks.c:ecl_bds_ref(cl_env_ptr env, cl_object s)
c/stacks.c:    cl_object *location = env->thread_local_bindings + index;
c/stacks.c:cl_object
c/stacks.c:ecl_bds_set(cl_env_ptr env, cl_object s, cl_object value)
c/stacks.c:cl_object
c/stacks.c:	cl_object __value0 = ecl_make_fixnum(env->ihs_top->index);
c/stacks.c:cl_object
c/stacks.c:si_ihs_prev(cl_object x)
c/stacks.c:	cl_object __value0 = cl_1M(x);
c/stacks.c:cl_object
c/stacks.c:si_ihs_next(cl_object x)
c/stacks.c:	cl_object __value0 = cl_1P(x);
c/stacks.c:cl_object
c/stacks.c:si_ihs_bds(cl_object arg)
c/stacks.c:	cl_object __value0 = ecl_make_fixnum(get_ihs_ptr(ecl_to_size(arg))->bds);
c/stacks.c:cl_object
c/stacks.c:si_ihs_fun(cl_object arg)
c/stacks.c:	cl_object __value0 = get_ihs_ptr(ecl_to_size(arg))->function;
c/stacks.c:cl_object
c/stacks.c:si_ihs_env(cl_object arg)
c/stacks.c:	cl_object __value0 = get_ihs_ptr(ecl_to_size(arg))->lex_env;
c/stacks.c:frs_sch (cl_object frame_id)
c/stacks.c:get_frame_ptr(cl_object x)
c/stacks.c:cl_object
c/stacks.c:	cl_object __value0 = ecl_make_fixnum(env->frs_top - env->frs_org);
c/stacks.c:cl_object
c/stacks.c:si_frs_bds(cl_object arg)
c/stacks.c:	cl_object __value0 = ecl_make_fixnum(get_frame_ptr(arg)->frs_bds_top_index);
c/stacks.c:cl_object
c/stacks.c:si_frs_tag(cl_object arg)
c/stacks.c:	cl_object __value0 = get_frame_ptr(arg)->frs_val;
c/stacks.c:cl_object
c/stacks.c:si_frs_ihs(cl_object arg)
c/stacks.c:	cl_object __value0 = ecl_make_fixnum(get_frame_ptr(arg)->frs_ihs->index);
c/stacks.c:cl_object
c/stacks.c:si_sch_frs_base(cl_object fr, cl_object ihs)
c/stacks.c:	cl_object __value0 = ((x > env->frs_top) ? ECL_NIL : ecl_make_fixnum(x - env->frs_org));
c/stacks.c:cl_object
c/stacks.c:si_set_limit(cl_object type, cl_object limit)
c/stacks.c:cl_object
c/stacks.c:si_get_limit(cl_object type)
c/stacks.c:	cl_object __value0 = ecl_make_unsigned_integer(cl_core.max_heap_size);
c/stacks.c:	cl_object __value0 = ecl_make_unsigned_integer(output);
c/stacks.c:cl_object
c/stacks.c:si_reset_margin(cl_object type)
c/string.c:static cl_object
c/string.c:  cl_object x = ecl_alloc_simple_base_string(s);
c/string.c:static cl_object
c/string.c:  cl_object x = ecl_alloc_simple_extended_string(s);
c/string.c:cl_object cl_make_string(cl_narg narg, cl_object size, ...)
c/string.c:  cl_object x;
c/string.c:	static cl_object KEYS[2] = {(cl_object)(cl_symbols+1277), (cl_object)(cl_symbols+1246)};
c/string.c:	cl_object initial_element;
c/string.c:	cl_object element_type;
c/string.c:	cl_object KEY_VARS[4];
c/string.c:	cl_object __value0 = x;
c/string.c:cl_object
c/string.c:  cl_object output = ecl_alloc_object(t_base_string);
c/string.c:cl_object
c/string.c:  cl_object output = ecl_alloc_object(t_string);
c/string.c:cl_object
c/string.c:  cl_object x = ecl_alloc_object(t_base_string);
c/string.c:cl_object
c/string.c:  cl_object x;
c/string.c:cl_object
c/string.c:ecl_fits_in_base_string(cl_object s)
c/string.c:cl_object
c/string.c:si_copy_to_simple_base_string(cl_object x)
c/string.c:  cl_object y;
c/string.c:	cl_object __value0 = y;
c/string.c:cl_object
c/string.c:cl_string(cl_object x)
c/string.c:    cl_object y;
c/string.c:	cl_object __value0 = x;
c/string.c:cl_object
c/string.c:si_coerce_to_base_string(cl_object x)
c/string.c:	cl_object __value0 = x;
c/string.c:cl_object
c/string.c:si_coerce_to_extended_string(cl_object x)
c/string.c:  cl_object y;
c/string.c:	cl_object __value0 = y;
c/string.c:cl_object
c/string.c:cl_char(cl_object object, cl_object index)
c/string.c:	cl_object __value0 = ECL_CODE_CHAR(ecl_char(object, position));
c/string.c:ecl_char(cl_object object, cl_index index)
c/string.c:cl_object
c/string.c:si_char_set(cl_object object, cl_object index, cl_object value)
c/string.c:	cl_object __value0 = value;
c/string.c:ecl_char_set(cl_object object, cl_index index, ecl_character value)
c/string.c:compare_strings(cl_object string1, cl_index s1, cl_index e1,
c/string.c:                cl_object string2, cl_index s2, cl_index e2,
c/string.c:cl_object cl_stringE(cl_narg narg, cl_object string1, cl_object string2, ...)
c/string.c:	static cl_object KEYS[4] = {(cl_object)(cl_symbols+1338), (cl_object)(cl_symbols+1248), (cl_object)(cl_symbols+1339), (cl_object)(cl_symbols+1249)};
c/string.c:	cl_object start1;
c/string.c:	cl_object end1;
c/string.c:	cl_object start2;
c/string.c:	cl_object end2;
c/string.c:	cl_object KEY_VARS[8];
c/string.c:	cl_object __value0 = ECL_NIL;
c/string.c:	cl_object __value0 = ECL_NIL;
c/string.c:	cl_object __value0 = ECL_T;
c/string.c:	cl_object __value0 = ECL_NIL;
c/string.c:	cl_object __value0 = ECL_T;
c/string.c:	cl_object __value0 = ECL_NIL;
c/string.c:	cl_object __value0 = ECL_T;
c/string.c:	cl_object __value0 = ECL_NIL;
c/string.c:	cl_object __value0 = ECL_T;
c/string.c:	cl_object __value0 = ECL_NIL;
c/string.c:	cl_object __value0 = ECL_T;
c/string.c:ecl_string_eq(cl_object x, cl_object y)
c/string.c:cl_object cl_string_equal(cl_narg narg, cl_object string1, cl_object string2, ...)
c/string.c:	static cl_object KEYS[4] = {(cl_object)(cl_symbols+1338), (cl_object)(cl_symbols+1248), (cl_object)(cl_symbols+1339), (cl_object)(cl_symbols+1249)};
c/string.c:	cl_object start1;
c/string.c:	cl_object end1;
c/string.c:	cl_object start2;
c/string.c:	cl_object end2;
c/string.c:	cl_object KEY_VARS[8];
c/string.c:	cl_object __value0 = ECL_NIL;
c/string.c:	cl_object __value0 = ((output == 0)? ECL_T : ECL_NIL);
c/string.c:static cl_object
c/string.c:  cl_object string1 = ecl_va_arg(ARGS);
c/string.c:  cl_object string2 = ecl_va_arg(ARGS);
c/string.c:  cl_object result;
c/string.c:  cl_object KEYS[4];
c/string.c:  cl_object KEY_VARS[8];
c/string.c:	cl_object __value0 = result;
c/string.c:cl_object cl_stringL(cl_narg narg, ...)
c/string.c:	cl_object __value0 = string_compare(narg, -1, -1, 1, args);
c/string.c:cl_object cl_stringG(cl_narg narg, ...)
c/string.c:	cl_object __value0 = string_compare(narg, +1, +1, 1, args);
c/string.c:cl_object cl_stringLE(cl_narg narg, ...)
c/string.c:	cl_object __value0 = string_compare(narg, -1, 0, 1, args);
c/string.c:cl_object cl_stringGE(cl_narg narg, ...)
c/string.c:	cl_object __value0 = string_compare(narg, 0, +1, 1, args);
c/string.c:cl_object cl_stringNE(cl_narg narg, ...)
c/string.c:	cl_object __value0 = string_compare(narg, -1, +1, 1, args);
c/string.c:cl_object cl_string_lessp(cl_narg narg, ...)
c/string.c:	cl_object __value0 = string_compare(narg, -1, -1, 0, args);
c/string.c:cl_object cl_string_greaterp(cl_narg narg, ...)
c/string.c:	cl_object __value0 = string_compare(narg, +1, +1, 0, args);
c/string.c:cl_object cl_string_not_greaterp(cl_narg narg, ...)
c/string.c:	cl_object __value0 = string_compare(narg, -1, 0, 0, args);
c/string.c:cl_object cl_string_not_lessp(cl_narg narg, ...)
c/string.c:	cl_object __value0 = string_compare(narg, 0, +1, 0, args);
c/string.c:cl_object cl_string_not_equal(cl_narg narg, ...)
c/string.c:	cl_object __value0 = string_compare(narg, -1, +1, 0, args);
c/string.c:ecl_member_char(ecl_character c, cl_object char_bag)
c/string.c:      cl_object other = CAR(char_bag);
c/string.c:      cl_object other = char_bag->vector.self.t[i];
c/string.c:static cl_object
c/string.c:string_trim0(bool left_trim, bool right_trim, cl_object char_bag, cl_object strng)
c/string.c:cl_object
c/string.c:cl_string_trim(cl_object char_bag, cl_object strng)
c/string.c:cl_object
c/string.c:cl_string_left_trim(cl_object char_bag, cl_object strng)
c/string.c:cl_object
c/string.c:cl_string_right_trim(cl_object char_bag, cl_object strng)
c/string.c:static cl_object
c/string.c:string_case(cl_narg narg, cl_object fun, ecl_casefun casefun, ecl_va_list ARGS)
c/string.c:  cl_object strng = ecl_va_arg(ARGS);
c/string.c:  cl_object KEYS[2];
c/string.c:  cl_object KEY_VARS[4];
c/string.c:	cl_object __value0 = strng;
c/string.c:cl_object cl_string_upcase(cl_narg narg, ...)
c/string.c:	cl_object __value0 = string_case(narg, ecl_make_fixnum(/*STRING-UPCASE*/820), char_upcase, args);
c/string.c:cl_object cl_string_downcase(cl_narg narg, ...)
c/string.c:	cl_object __value0 = string_case(narg, ecl_make_fixnum(/*STRING-DOWNCASE*/808), char_downcase, args);
c/string.c:cl_object cl_string_capitalize(cl_narg narg, ...)
c/string.c:	cl_object __value0 = string_case(narg, ecl_make_fixnum(/*STRING-CAPITALIZE*/809), char_capitalize, args);
c/string.c:static cl_object
c/string.c:nstring_case(cl_narg narg, cl_object fun, ecl_casefun casefun, ecl_va_list ARGS)
c/string.c:  cl_object strng = ecl_va_arg(ARGS);
c/string.c:  cl_object KEYS[2];
c/string.c:  cl_object KEY_VARS[4];
c/string.c:	cl_object __value0 = strng;
c/string.c:cl_object cl_nstring_upcase(cl_narg narg, ...)
c/string.c:	cl_object __value0 = nstring_case(narg, ECL_SYM("NSTRING-UPCASE",596), char_upcase, args);
c/string.c:cl_object cl_nstring_downcase(cl_narg narg, ...)
c/string.c:	cl_object __value0 = nstring_case(narg, ECL_SYM("NSTRING-DOWNCASE",595), char_downcase, args);
c/string.c:cl_object cl_nstring_capitalize(cl_narg narg, ...)
c/string.c:	cl_object __value0 = nstring_case(narg, ECL_SYM("NSTRING-CAPITALIZE",594), char_capitalize, args);
c/string.c:cl_object si_base_string_concatenate(cl_narg narg, ...)
c/string.c:  cl_object output;
c/string.c:    cl_object s = si_coerce_to_base_string(ecl_va_arg(args));
c/string.c:    cl_object s = ECL_STACK_POP_UNSAFE(the_env);
c/string.c:	cl_object __value0 = output;
c/structure.c:structure_subtypep(cl_object x, cl_object y)
c/structure.c:    cl_object superiors = ECL_CLASS_SUPERIORS(x);
c/structure.c:cl_object
c/structure.c:si_structure_subtype_p(cl_object x, cl_object y)
c/structure.c:	cl_object __value0 = ((ecl_t_of(x) == T_STRUCTURE
c/structure.c:cl_object si_make_structure(cl_narg narg, cl_object type, ...)
c/structure.c:  cl_object x;
c/structure.c:  ECL_STRUCT_SLOTS(x) = (cl_object *)ecl_alloc_align(sizeof(cl_object)*narg, sizeof(cl_object));
c/structure.c:	cl_object __value0 = x;
c/structure.c:cl_object
c/structure.c:cl_copy_structure(cl_object s)
c/structure.c:	cl_object __value0 = s;
c/structure.c:cl_object
c/structure.c:si_structure_name(cl_object s)
c/structure.c:	cl_object __value0 = ECL_STRUCT_NAME(s);
c/structure.c:cl_object
c/structure.c:si_structure_ref(cl_object x, cl_object type, cl_object index)
c/structure.c:	cl_object __value0 = ECL_STRUCT_SLOT(x, ecl_fixnum(index));
c/structure.c:cl_object
c/structure.c:ecl_structure_ref(cl_object x, cl_object type, cl_fixnum n)
c/structure.c:cl_object
c/structure.c:si_structure_set(cl_object x, cl_object type, cl_object index, cl_object val)
c/structure.c:	cl_object __value0 = val;
c/structure.c:cl_object
c/structure.c:ecl_structure_set(cl_object x, cl_object type, cl_fixnum n, cl_object v)
c/structure.c:cl_object
c/structure.c:mp_compare_and_swap_structure(cl_object x, cl_object type, cl_object index, cl_object old, cl_object new)
c/structure.c:cl_object
c/structure.c:si_structurep(cl_object s)
c/symbol.c:cl_object
c/symbol.c:ecl_symbol_package(cl_object s)
c/symbol.c:ecl_symbol_type(cl_object s)
c/symbol.c:ecl_symbol_type_set(cl_object s, int type)
c/symbol.c:cl_object
c/symbol.c:ecl_symbol_name(cl_object s)
c/symbol.c:static cl_object *
c/symbol.c:ecl_symbol_plist(cl_object s)
c/symbol.c:static void FEtype_error_plist(cl_object x) /*__attribute__((noreturn))*/;
c/symbol.c:cl_object
c/symbol.c:cl_make_symbol(cl_object str)
c/symbol.c:  cl_object x;
c/symbol.c:	cl_object __value0 = x;
c/symbol.c:cl_object
c/symbol.c:  cl_object x = _ecl_intern(s, cl_core.keyword_package);
c/symbol.c:cl_object
c/symbol.c:  cl_object x = _ecl_intern(s, pack_name);
c/symbol.c:cl_object
c/symbol.c:ecl_symbol_value(cl_object s)
c/symbol.c:    cl_object value = ECL_SYM_VAL(the_env, s);
c/symbol.c:FEtype_error_plist(cl_object x)
c/symbol.c:cl_object
c/symbol.c:ecl_getf(cl_object place, cl_object indicator, cl_object deflt)
c/symbol.c:  cl_object l;
c/symbol.c:    cl_object cdr_l = ECL_CONS_CDR(l);
c/symbol.c:cl_object
c/symbol.c:ecl_get(cl_object s, cl_object p, cl_object d)
c/symbol.c:cl_object
c/symbol.c:si_put_f(cl_object place, cl_object value, cl_object indicator)
c/symbol.c:  cl_object l;
c/symbol.c:    cl_object cdr_l = ECL_CONS_CDR(l);
c/symbol.c:	cl_object __value0 = place;
c/symbol.c:	cl_object __value0 = CONS(indicator, place);
c/symbol.c:  which is a pointer to an cl_object.
c/symbol.c:remf(cl_object *place, cl_object indicator)
c/symbol.c:  cl_object l = *place, tail = ECL_NIL;
c/symbol.c:    cl_object ind;
c/symbol.c:ecl_keywordp(cl_object s)
c/symbol.c:cl_object cl_get(cl_narg narg, cl_object sym, cl_object indicator, ...)
c/symbol.c:  cl_object *plist;
c/symbol.c:	cl_object deflt;
c/symbol.c:		deflt = va_arg(ARGS,cl_object);
c/symbol.c:	cl_object __value0 = ecl_getf(*plist, indicator, deflt);
c/symbol.c:cl_object
c/symbol.c:cl_remprop(cl_object sym, cl_object prop)
c/symbol.c:  cl_object *plist = ecl_symbol_plist(sym);
c/symbol.c:	cl_object __value0 = (remf(plist, prop)? ECL_T: ECL_NIL);
c/symbol.c:cl_object
c/symbol.c:cl_symbol_plist(cl_object sym)
c/symbol.c:	cl_object __value0 = *ecl_symbol_plist(sym);
c/symbol.c:cl_object cl_getf(cl_narg narg, cl_object place, cl_object indicator, ...)
c/symbol.c:	cl_object deflt;
c/symbol.c:		deflt = va_arg(ARGS,cl_object);
c/symbol.c:	cl_object __value0 = ecl_getf(place, indicator, deflt);
c/symbol.c:cl_object
c/symbol.c:cl_get_properties(cl_object place, cl_object indicator_list)
c/symbol.c:  cl_object l;
c/symbol.c:    cl_object cdr_l = ECL_CONS_CDR(l);
c/symbol.c:cl_object
c/symbol.c:cl_symbol_name(cl_object x)
c/symbol.c:cl_object cl_copy_symbol(cl_narg narg, cl_object sym, ...)
c/symbol.c:	cl_object cp;
c/symbol.c:	cl_object x;
c/symbol.c:		cp = va_arg(ARGS,cl_object);
c/symbol.c:	cl_object __value0 = x;
c/symbol.c:cl_object cl_gensym(cl_narg narg, ...)
c/symbol.c:  cl_object counter, output;
c/symbol.c:	cl_object prefix;
c/symbol.c:		prefix = va_arg(ARGS,cl_object);
c/symbol.c:	cl_object __value0 = output;
c/symbol.c:cl_object cl_gentemp(cl_narg narg, ...)
c/symbol.c:  cl_object output, s;
c/symbol.c:	cl_object prefix;
c/symbol.c:	cl_object pack;
c/symbol.c:		prefix = va_arg(ARGS,cl_object);
c/symbol.c:		pack = va_arg(ARGS,cl_object);
c/symbol.c:	cl_object __value0 = s;
c/symbol.c:cl_object
c/symbol.c:cl_symbol_package(cl_object sym)
c/symbol.c:	cl_object __value0 = ecl_symbol_package(sym);
c/symbol.c:cl_object
c/symbol.c:cl_keywordp(cl_object sym)
c/symbol.c:	cl_object __value0 = (ecl_keywordp(sym)? ECL_T: ECL_NIL);
c/symbol.c:cl_object
c/symbol.c:si_rem_f(cl_object plist, cl_object indicator)
c/symbol.c:cl_object
c/symbol.c:si_set_symbol_plist(cl_object sym, cl_object plist)
c/symbol.c:	cl_object __value0 = plist;
c/symbol.c:cl_object
c/symbol.c:mp_compare_and_swap_symbol_plist(cl_object x, cl_object old, cl_object new)
c/symbol.c:cl_object
c/symbol.c:si_putprop(cl_object sym, cl_object value, cl_object indicator)
c/symbol.c:  cl_object *plist = ecl_symbol_plist(sym);
c/symbol.c:	cl_object __value0 = value;
c/symbol.c:cl_object si_put_properties(cl_narg narg, cl_object sym, ...)
c/symbol.c:    cl_object prop = ecl_va_arg(ind_values);
c/symbol.c:	cl_object __value0 = sym;
c/symbol.c:cl_object
c/symbol.c:si_Xmake_special(cl_object sym)
c/symbol.c:	cl_object __value0 = sym;
c/symbol.c:cl_object
c/symbol.c:si_Xmake_constant(cl_object sym, cl_object val)
c/symbol.c:	cl_object __value0 = sym;
c/symbol.c:ecl_defvar(cl_object sym, cl_object val)
c/symbol.c:ecl_defparameter(cl_object sym, cl_object val)
c/tan.c:cl_object
c/tan.c:cl_tan(cl_object x)
c/tan.c:	cl_object __value0 = ecl_tan(x);
c/tan.c:static cl_object
c/tan.c:ecl_tan_rational(cl_object x)
c/tan.c:static cl_object
c/tan.c:ecl_tan_single_float(cl_object x)
c/tan.c:static cl_object
c/tan.c:ecl_tan_double_float(cl_object x)
c/tan.c:static cl_object
c/tan.c:ecl_tan_long_float(cl_object x)
c/tan.c:static cl_object
c/tan.c:ecl_tan_complex(cl_object x)
c/tan.c:  cl_object a = ecl_sin(x);
c/tan.c:  cl_object b = ecl_cos(x);
c/tan.c:static cl_object
c/tan.c:ecl_tan_csfloat(cl_object x)
c/tan.c:  cl_object result = ecl_alloc_object(t_csfloat);
c/tan.c:static cl_object
c/tan.c:ecl_tan_cdfloat(cl_object x)
c/tan.c:  cl_object result = ecl_alloc_object(t_cdfloat);
c/tan.c:static cl_object
c/tan.c:ecl_tan_clfloat(cl_object x)
c/tan.c:  cl_object result = ecl_alloc_object(t_clfloat);
c/tanh.c:cl_object
c/tanh.c:cl_tanh(cl_object x)
c/tanh.c:	cl_object __value0 = ecl_tanh(x);
c/tanh.c:static cl_object
c/tanh.c:ecl_tanh_rational(cl_object x)
c/tanh.c:static cl_object
c/tanh.c:ecl_tanh_single_float(cl_object x)
c/tanh.c:static cl_object
c/tanh.c:ecl_tanh_double_float(cl_object x)
c/tanh.c:static cl_object
c/tanh.c:ecl_tanh_long_float(cl_object x)
c/tanh.c:static cl_object
c/tanh.c:ecl_tanh_complex(cl_object x)
c/tanh.c:  cl_object a = ecl_sinh(x);
c/tanh.c:  cl_object b = ecl_cosh(x);
c/tanh.c:static cl_object
c/tanh.c:ecl_tanh_csfloat(cl_object x)
c/tanh.c:  cl_object result = ecl_alloc_object(t_csfloat);
c/tanh.c:static cl_object
c/tanh.c:ecl_tanh_cdfloat(cl_object x)
c/tanh.c:  cl_object result = ecl_alloc_object(t_cdfloat);
c/tanh.c:static cl_object
c/tanh.c:ecl_tanh_clfloat(cl_object x)
c/tanh.c:  cl_object result = ecl_alloc_object(t_clfloat);
c/tcp.c:cl_object
c/tcp.c:si_open_client_stream(cl_object host, cl_object port)
c/tcp.c:  cl_object stream;
c/tcp.c:	cl_object __value0 = ECL_NIL;
c/tcp.c:	cl_object __value0 = stream;
c/tcp.c:cl_object
c/tcp.c:si_open_server_stream(cl_object port)
c/tcp.c:	cl_object __value0 = ((fd == 0)? ECL_NIL : ecl_make_stream_from_fd(ECL_NIL, fd, ecl_smm_io, 8, 0, ECL_NIL));
c/tcp.c:cl_object
c/tcp.c:si_open_unix_socket_stream(cl_object path)
c/tcp.c:	cl_object __value0 = ECL_NIL;
c/tcp.c:	cl_object __value0 = ECL_NIL;
c/tcp.c:	cl_object __value0 = ecl_make_stream_from_fd(path, fd, ecl_smm_io, 8, 0, ECL_NIL);
c/tcp.c:cl_object
c/tcp.c:si_lookup_host_entry(cl_object host_or_address)
c/tcp.c:  cl_object name, aliases, addresses;
c/tcp.c:	cl_object __value0 = ECL_NIL;
c/tcp.c:	cl_object __value1 = ECL_NIL;
c/tcp.c:	cl_object __value2 = ECL_NIL;
c/tcp.c:	cl_object __value0 = name;
c/tcp.c:	cl_object __value1 = aliases;
c/tcp.c:	cl_object __value2 = addresses;
c/time.c:cl_object
c/time.c:cl_sleep(cl_object z)
c/time.c:	cl_object __value0 = ECL_NIL;
c/time.c:static cl_object
c/time.c:  cl_object milliseconds = ecl_plus(ecl_times(ecl_make_integer(sec),
c/time.c:	cl_object __value0 = milliseconds;
c/time.c:cl_object
c/time.c:cl_object
c/time.c:cl_object
c/time.c:  cl_object utc = ecl_make_integer(time(0));
c/time.c:	cl_object __value0 = ecl_plus(utc, cl_core.Jan1st1970UT);
c/times.c:cl_object cl_X(cl_narg narg, ...)
c/times.c:  cl_object prod = ecl_make_fixnum(1);
c/times.c:	cl_object __value0 = prod;
c/times.c:cl_object
c/times.c:ecl_times(cl_object x, cl_object y)
c/times.c:  cl_object ret;
c/times.c:        cl_object z = ecl_times(x->ratio.num, y);
c/times.c:        cl_object num = ecl_times(x->ratio.num,y->ratio.num);
c/times.c:        cl_object den = ecl_times(x->ratio.den,y->ratio.den);
c/times.c:        cl_object aux = x;
c/times.c:        cl_object z11 = ecl_times(x->gencomplex.real, y->gencomplex.real);
c/times.c:        cl_object z12 = ecl_times(x->gencomplex.imag, y->gencomplex.imag);
c/times.c:        cl_object z21 = ecl_times(x->gencomplex.imag, y->gencomplex.real);
c/times.c:        cl_object z22 = ecl_times(x->gencomplex.real, y->gencomplex.imag);
c/truncate.c:cl_object
c/truncate.c:ecl_truncate1(cl_object x)
c/truncate.c:  cl_object v0, v1;
c/truncate.c:cl_object
c/truncate.c:ecl_truncate2(cl_object x, cl_object y)
c/truncate.c:cl_object cl_truncate(cl_narg narg, cl_object x, ...)
c/truncate.c:	cl_object y;
c/truncate.c:		y = va_arg(ARGS,cl_object);
c/typespec.c:FEtype_error_fixnum(cl_object x) {
c/typespec.c:FEtype_error_size(cl_object x) {
c/typespec.c:FEtype_error_cons(cl_object x) {
c/typespec.c:FEtype_error_list(cl_object x) {
c/typespec.c:FEtype_error_proper_list(cl_object x) {
c/typespec.c:FEcircular_list(cl_object x)
c/typespec.c:FEtype_error_index(cl_object seq, cl_fixnum ndx)
c/typespec.c:  cl_object n = ecl_make_fixnum(ndx);
c/typespec.c:FEtype_error_array(cl_object v)
c/typespec.c:FEtype_error_vector(cl_object v)
c/typespec.c:FEtype_error_sequence(cl_object x) {
c/typespec.c:cl_object
c/typespec.c:ecl_type_error(cl_object function, const char *place, cl_object o,
c/typespec.c:               cl_object type)
c/typespec.c:static cl_object
c/typespec.c:cl_object
c/typespec.c:ecl_check_cl_type(cl_object fun, cl_object p, cl_type t)
c/typespec.c:assert_type_integer(cl_object p)
c/typespec.c:assert_type_non_negative_integer(cl_object p)
c/typespec.c:assert_type_proper_list(cl_object p)
c/typespec.c:cl_object
c/typespec.c:cl_type_of(cl_object x)
c/typespec.c:  cl_object t;
c/typespec.c:    cl_object cl = ECL_CLASS_OF(x);
c/typespec.c:	cl_object __value0 = t;
c/typespec.c:cl_object
c/typespec.c:ecl_make_integer_type(cl_object min, cl_object max)
c/ucd_names_char.c:cl_object
c/ucd_names_char.c:cl_object
c/ucd_names_char.c:_ecl_ucd_name_to_code(cl_object name)
c/unixfsys.c:safe_chdir(const char *path, cl_object prefix)
c/unixfsys.c:    cl_object aux = ecl_make_constant_base_string(path,-1);
c/unixfsys.c:static cl_object
c/unixfsys.c:drive_host_prefix(cl_object pathname)
c/unixfsys.c:  cl_object device = pathname->pathname.device;
c/unixfsys.c:  cl_object host = pathname->pathname.host;
c/unixfsys.c:  cl_object output = ECL_NIL;
c/unixfsys.c:    cl_object slash = cl_core.slash;
c/unixfsys.c:cl_object
c/unixfsys.c:  cl_object string = ecl_make_simple_base_string(s, -1);
c/unixfsys.c:static cl_object
c/unixfsys.c:  cl_object output;
c/unixfsys.c:static cl_object
c/unixfsys.c:  cl_object output;
c/unixfsys.c:cl_object
c/unixfsys.c:si_file_kind(cl_object filename, cl_object follow_links) {
c/unixfsys.c:	cl_object __value0 = file_kind((char*)filename->base_string.self, !Null(follow_links));
c/unixfsys.c:static cl_object
c/unixfsys.c:si_readlink(cl_object filename) {
c/unixfsys.c:  cl_object output, kind;
c/unixfsys.c:static cl_object
c/unixfsys.c:enter_directory(cl_object base_dir, cl_object subdir, bool ignore_if_failure)
c/unixfsys.c:  cl_object aux, output, kind;
c/unixfsys.c:    cl_object newdir= output->pathname.directory;
c/unixfsys.c:static cl_object
c/unixfsys.c:make_absolute_pathname(cl_object orig_pathname)
c/unixfsys.c:  cl_object base_dir = si_getcwd(0);
c/unixfsys.c:  cl_object pathname = coerce_to_file_pathname(orig_pathname);
c/unixfsys.c:static cl_object
c/unixfsys.c:make_base_pathname(cl_object pathname)
c/unixfsys.c:static cl_object
c/unixfsys.c:file_truename(cl_object pathname, cl_object filename, int flags)
c/unixfsys.c:  cl_object kind;
c/unixfsys.c:	cl_object __value0 = pathname;
c/unixfsys.c:	cl_object __value1 = kind;
c/unixfsys.c:	cl_object __value0 = pathname;
c/unixfsys.c:	cl_object __value1 = kind;
c/unixfsys.c:cl_object
c/unixfsys.c:cl_truename(cl_object orig_pathname)
c/unixfsys.c:  cl_object pathname = make_absolute_pathname(orig_pathname);
c/unixfsys.c:  cl_object base_dir = make_base_pathname(pathname);
c/unixfsys.c:  cl_object dir;
c/unixfsys.c:	cl_object __value0 = file_truename(pathname, ECL_NIL, FOLLOW_SYMLINKS);
c/unixfsys.c:cl_object
c/unixfsys.c:cl_object cl_rename_file(cl_narg narg, cl_object oldn, cl_object newn, ...)
c/unixfsys.c:  cl_object old_filename, new_filename, old_truename, new_truename;
c/unixfsys.c:	static cl_object KEYS[1] = {(cl_object)(cl_symbols+1270)};
c/unixfsys.c:	cl_object if_exists;
c/unixfsys.c:	cl_object KEY_VARS[2];
c/unixfsys.c:	cl_object __value0 = ECL_NIL;
c/unixfsys.c:	cl_object __value1 = ECL_NIL;
c/unixfsys.c:	cl_object __value2 = ECL_NIL;
c/unixfsys.c:    cl_object c_error = _ecl_strerror(errno);
c/unixfsys.c:	cl_object __value0 = newn;
c/unixfsys.c:	cl_object __value1 = old_truename;
c/unixfsys.c:	cl_object __value2 = new_truename;
c/unixfsys.c:directory_pathname_p(cl_object path)
c/unixfsys.c:cl_object
c/unixfsys.c:cl_delete_file(cl_object file)
c/unixfsys.c:  cl_object path = cl_pathname(file);
c/unixfsys.c:  cl_object filename = si_coerce_to_filename(path);
c/unixfsys.c:    cl_object c_error = _ecl_strerror(errno);
c/unixfsys.c:	cl_object __value0 = ECL_T;
c/unixfsys.c:cl_object
c/unixfsys.c:cl_probe_file(cl_object file)
c/unixfsys.c:	cl_object __value0 = (si_file_kind(file, ECL_T) != ECL_NIL? cl_truename(file) : ECL_NIL);
c/unixfsys.c:cl_object
c/unixfsys.c:cl_file_write_date(cl_object file)
c/unixfsys.c:  cl_object time, filename = si_coerce_to_filename(file);
c/unixfsys.c:	cl_object __value0 = time;
c/unixfsys.c:cl_object
c/unixfsys.c:cl_file_author(cl_object file)
c/unixfsys.c:  cl_object output, filename = si_coerce_to_filename(file);
c/unixfsys.c:    cl_object c_error = _ecl_strerror(errno);
c/unixfsys.c:	cl_object __value0 = output;
c/unixfsys.c:cl_object
c/unixfsys.c:ecl_homedir_pathname(cl_object user)
c/unixfsys.c:  cl_object namestring;
c/unixfsys.c:cl_object cl_user_homedir_pathname(cl_narg narg, ...)
c/unixfsys.c:	cl_object host;
c/unixfsys.c:		host = va_arg(ARGS,cl_object);
c/unixfsys.c:	cl_object __value0 = ecl_homedir_pathname(ECL_NIL);
c/unixfsys.c:string_match(const char *s, cl_object pattern)
c/unixfsys.c:    cl_object component, component_path, kind;                          \
c/unixfsys.c:static cl_object
c/unixfsys.c:list_directory(cl_object base_dir, cl_object text_mask, cl_object pathname_mask,
c/unixfsys.c:  cl_object out = ECL_NIL;
c/unixfsys.c:  cl_object prefix = ecl_namestring(base_dir, ECL_NAMESTRING_FORCE_BASE_STRING);
c/unixfsys.c:      cl_object aux = ecl_make_constant_base_string(".\\*",-1);
c/unixfsys.c:      cl_object mask = si_base_string_concatenate(2, prefix, aux);
c/unixfsys.c:static cl_object
c/unixfsys.c:dir_files(cl_object base_dir, cl_object pathname, int flags)
c/unixfsys.c:  cl_object all_files, output = ECL_NIL;
c/unixfsys.c:  cl_object mask;
c/unixfsys.c:  cl_object name = pathname->pathname.name;
c/unixfsys.c:  cl_object type = pathname->pathname.type;
c/unixfsys.c:      cl_object record = ECL_CONS_CAR(all_files);
c/unixfsys.c:      cl_object new = ECL_CONS_CAR(record);
c/unixfsys.c:      cl_object kind = ECL_CONS_CDR(record);
c/unixfsys.c:static cl_object
c/unixfsys.c:dir_recursive(cl_object base_dir, cl_object directory, cl_object filemask, int flags)
c/unixfsys.c:  cl_object item, output = ECL_NIL;
c/unixfsys.c:    cl_object next_dir = list_directory(base_dir, item, ECL_NIL, flags);
c/unixfsys.c:      cl_object record = ECL_CONS_CAR(next_dir);
c/unixfsys.c:      cl_object component = ECL_CONS_CAR(record);
c/unixfsys.c:      cl_object kind = ECL_CONS_CDR(record);
c/unixfsys.c:    cl_object next_dir = list_directory(base_dir, ECL_NIL, ECL_NIL, flags);
c/unixfsys.c:      cl_object record = ECL_CONS_CAR(next_dir);
c/unixfsys.c:      cl_object component = ECL_CONS_CAR(record);
c/unixfsys.c:      cl_object kind = ECL_CONS_CDR(record);
c/unixfsys.c:cl_object cl_directory(cl_narg narg, cl_object mask, ...)
c/unixfsys.c:  cl_object base_dir;
c/unixfsys.c:  cl_object output;
c/unixfsys.c:	static cl_object KEYS[1] = {(cl_object)(cl_symbols+1921)};
c/unixfsys.c:	cl_object resolve_symlinks;
c/unixfsys.c:	cl_object KEY_VARS[2];
c/unixfsys.c:	cl_object __value0 = output;
c/unixfsys.c:cl_object si_getcwd(cl_narg narg, ...)
c/unixfsys.c:  cl_object output;
c/unixfsys.c:	cl_object change_d_p_d;
c/unixfsys.c:		change_d_p_d = va_arg(ARGS,cl_object);
c/unixfsys.c:	cl_object __value0 = output;
c/unixfsys.c:cl_object
c/unixfsys.c:  cl_object s = cl_core.library_pathname;
c/unixfsys.c:    cl_object true_pathname = cl_probe_file(s);
c/unixfsys.c:	cl_object __value0 = s;
c/unixfsys.c:cl_object si_chdir(cl_narg narg, cl_object directory, ...)
c/unixfsys.c:  cl_object previous = si_getcwd(0);
c/unixfsys.c:  cl_object namestring;
c/unixfsys.c:	cl_object change_d_p_d;
c/unixfsys.c:		change_d_p_d = va_arg(ARGS,cl_object);
c/unixfsys.c:    cl_object c_error = _ecl_strerror(errno);
c/unixfsys.c:	cl_object __value0 = previous;
c/unixfsys.c:cl_object
c/unixfsys.c:si_mkdir(cl_object directory, cl_object mode)
c/unixfsys.c:  cl_object filename = si_coerce_to_base_string(directory);
c/unixfsys.c:    cl_object c_error = _ecl_strerror(errno);
c/unixfsys.c:	cl_object __value0 = filename;
c/unixfsys.c:cl_object
c/unixfsys.c:si_mkstemp(cl_object template)
c/unixfsys.c:  cl_object output;
c/unixfsys.c:  cl_object phys, dir, file;
c/unixfsys.c:	cl_object __value0 = (Null(output)? output : cl_truename(output));
c/unixfsys.c:cl_object
c/unixfsys.c:si_rmdir(cl_object directory)
c/unixfsys.c:cl_object
c/unixfsys.c:si_copy_file(cl_object orig, cl_object dest)
c/unixfsys.c:	cl_object __value0 = (ok? ECL_T : ECL_NIL);
c/unixfsys.c:cl_object
c/unixfsys.c:si_chmod(cl_object file, cl_object mode)
c/unixfsys.c:  cl_object filename = si_coerce_to_filename(file);
c/unixfsys.c:    cl_object c_error = _ecl_strerror(errno);
c/unixint.c:        cl_object handler;
c/unixint.c:                cl_object process = the_env->own_process;
c/unixint.c:static void illegal_signal_code(cl_object code) ecl_attr_noreturn;
c/unixint.c:illegal_signal_code(cl_object code)
c/unixint.c:static cl_object pop_signal(cl_env_ptr env);
c/unixint.c:handle_signal_now(cl_object signal_code)
c/unixint.c:cl_object
c/unixint.c:si_handle_signal(cl_object signal_code)
c/unixint.c:        cl_object fun = env->function;
c/unixint.c:        cl_object values[ECL_MULTIPLE_VALUES_LIMIT];
c/unixint.c:        memcpy(values, env->values, ECL_MULTIPLE_VALUES_LIMIT*sizeof(cl_object));
c/unixint.c:        cl_object stack_frame = env->stack_frame;
c/unixint.c:        cl_object packages_to_be_created = env->packages_to_be_created;
c/unixint.c:        cl_object packages_to_be_created_p = env->packages_to_be_created_p;
c/unixint.c:        cl_object big_register[ECL_BIGNUM_REGISTER_NUMBER];
c/unixint.c:        memcpy(big_register, env->big_register, ECL_BIGNUM_REGISTER_NUMBER*sizeof(cl_object));
c/unixint.c:        memcpy(env->big_register, big_register, ECL_BIGNUM_REGISTER_NUMBER*sizeof(cl_object));
c/unixint.c:        memcpy(env->values, values, ECL_MULTIPLE_VALUES_LIMIT*sizeof(cl_object));
c/unixint.c:queue_signal(cl_env_ptr env, cl_object code, int allocate)
c/unixint.c:        cl_object record;
c/unixint.c:static cl_object
c/unixint.c:        cl_object record, value;
c/unixint.c:handle_or_queue(cl_env_ptr the_env, cl_object signal_code, int code)
c/unixint.c:        cl_object signal_object;
c/unixint.c:        cl_object signal_object;
c/unixint.c:        cl_object process;
c/unixint.c:static cl_object signal_thread_process = ECL_NIL;
c/unixint.c:static cl_object signal_thread_spinlock = ECL_NIL;
c/unixint.c:static cl_object
c/unixint.c:                cl_object signal_code;
c/unixint.c:        cl_object condition;
c/unixint.c:cl_object
c/unixint.c:static cl_object
c/unixint.c:do_catch_signal(int code, cl_object action, cl_object process)
c/unixint.c:cl_object
c/unixint.c:si_get_signal_handler(cl_object code)
c/unixint.c:        cl_object handler = ecl_gethash_safe(code, cl_core.known_signals, OBJNULL);
c/unixint.c:	cl_object __value0 = handler;
c/unixint.c:cl_object
c/unixint.c:si_set_signal_handler(cl_object code, cl_object handler)
c/unixint.c:        cl_object action = ecl_gethash_safe(code, cl_core.known_signals, OBJNULL);
c/unixint.c:	cl_object __value0 = handler;
c/unixint.c:cl_object si_catch_signal(cl_narg narg, cl_object code, cl_object flag, ...)
c/unixint.c:	static cl_object KEYS[1] = {(cl_object)(cl_symbols+1321)};
c/unixint.c:	cl_object process;
c/unixint.c:	cl_object KEY_VARS[2];
c/unixint.c:	cl_object __value0 = do_catch_signal(code_int, flag, process);
c/unixint.c:do_interrupt_thread(cl_object process)
c/unixint.c:ecl_interrupt_process(cl_object process, cl_object function)
c/unixint.c:ecl_wakeup_process(cl_object process)
c/unixint.c:                        cl_object process = the_env->own_process;
c/unixint.c:static cl_object
c/unixint.c:W32_handle_in_new_thread(cl_object signal_code)
c/unixint.c:                cl_object function =
c/unixint.c:                cl_object function =
c/unixint.c:cl_object
c/unixint.c:si_trap_fpe(cl_object condition, cl_object flag)
c/unixint.c:	cl_object __value0 = ecl_make_fixnum(bits);
c/unixint.c:                cl_object fun =
c/unixint.c:                        ecl_make_cfun((cl_objectfn_fixed)
c/unixint.c:                cl_object process =
c/unixint.c:add_one_signal(cl_object hash_table, int signal, cl_object name, cl_object handler)
c/unixint.c:        cl_object code = ecl_make_fixnum(signal);
c/unixint.c:        cl_object hash =
c/unixint.c:                cl_object name;
c/unixsys.c:cl_object
c/unixsys.c:si_system(cl_object cmd_string)
c/unixsys.c:	cl_object __value0 = ECL_NIL;
c/unixsys.c:  cl_object cmd = si_copy_to_simple_base_string(cmd_string);
c/unixsys.c:	cl_object __value0 = ecl_make_fixnum(code);
c/unixsys.c:cl_object
c/unixsys.c:	cl_object __value0 = ECL_NIL;
c/unixsys.c:	cl_object __value0 = ecl_make_fixnum(getpid());
c/unixsys.c:cl_object
c/unixsys.c:	cl_object __value0 = ecl_make_fixnum(0);
c/unixsys.c:	cl_object __value0 = ecl_make_integer(getuid());
c/unixsys.c:cl_object
c/unixsys.c:	cl_object __value0 = ECL_NIL;
c/unixsys.c:  cl_object output;
c/unixsys.c:    cl_object in = ecl_make_stream_from_fd(fake_in_name, fds[0], ecl_smm_input, 8,
c/unixsys.c:    cl_object out = ecl_make_stream_from_fd(fake_out_name, fds[1], ecl_smm_output, 8,
c/unixsys.c:	cl_object __value0 = output;
c/unixsys.c:static cl_object
c/unixsys.c:from_list_to_execve_argument(cl_object l, char ***environp)
c/unixsys.c:  cl_object p;
c/unixsys.c:  cl_object buffer;
c/unixsys.c:    cl_object s = ECL_CONS_CAR(p);
c/unixsys.c:    cl_object s = ECL_CONS_CAR(p);
c/unixsys.c:cl_object
c/unixsys.c:si_waitpid(cl_object pid, cl_object wait)
c/unixsys.c:  cl_object status, code;
c/unixsys.c:	cl_object __value0 = ECL_NIL;
c/unixsys.c:	cl_object __value0 = status;
c/unixsys.c:	cl_object __value1 = code;
c/unixsys.c:	cl_object __value2 = pid;
c/unixsys.c:cl_object
c/unixsys.c:si_killpid(cl_object pid, cl_object signal) {
c/unixsys.c:cl_object
c/unixsys.c:si_close_windows_handle(cl_object h)
c/unixsys.c:static cl_object
c/unixsys.c:  cl_object foreign = ecl_allocate_foreign_data(ECL_SYM(":POINTER-VOID",1410),
c/unixsys.c:ecl_stream_to_HANDLE(cl_object s, bool output)
c/unixsys.c:create_descriptor(cl_object stream, cl_object direction,
c/unixsys.c:create_descriptor(cl_object stream, cl_object direction,
c/unixsys.c:cl_object
c/unixsys.c:si_run_program_inner(cl_object command, cl_object argv, cl_object environ, cl_object wait)
c/unixsys.c:  cl_object pid, stream_read, exit_status;
c/unixsys.c:	cl_object __value0 = stream_read;
c/unixsys.c:	cl_object __value1 = exit_status;
c/unixsys.c:	cl_object __value2 = pid;
c/unixsys.c:cl_object
c/unixsys.c:si_spawn_subprocess(cl_object command, cl_object argv, cl_object environ,
c/unixsys.c:                    cl_object input, cl_object output, cl_object error) {
c/unixsys.c:  cl_object pid;
c/unixsys.c:    cl_object env_buffer;
c/unixsys.c:        cl_object arg = argv->vector.self.t[j];
c/unixsys.c:	cl_object __value0 = ECL_NIL;
c/unixsys.c:	cl_object __value0 = pid;
c/unixsys.c:	cl_object __value1 = ecl_make_fixnum(parent_write);
c/unixsys.c:	cl_object __value2 = ecl_make_fixnum(parent_read);
c/unixsys.c:	cl_object __value3 = ecl_make_fixnum(parent_error);
c/vector_push.c:static cl_object
c/vector_push.c:extend_vector(cl_object v, cl_index amount)
c/vector_push.c:        cl_object other;
c/vector_push.c:ecl_string_push_extend(cl_object s, ecl_character c)
c/vector_push.c:cl_object
c/vector_push.c:cl_vector_push(cl_object value, cl_object v)
c/vector_push.c:	cl_object __value0 = ECL_NIL;
c/vector_push.c:	cl_object __value0 = ecl_make_fixnum(v->vector.fillp++);
c/vector_push.c:cl_object cl_vector_push_extend(cl_narg narg, cl_object value, cl_object v, ...)
c/vector_push.c:	cl_object extent;
c/vector_push.c:		extent = va_arg(ARGS,cl_object);
c/vector_push.c:	cl_object __value0 = ecl_make_fixnum(v->vector.fillp++);
c/write_array.c:write_array_inner(bool vector, cl_object x, cl_object stream)
c/write_array.c:_ecl_write_array(cl_object x, cl_object stream)
c/write_array.c:_ecl_write_vector(cl_object x, cl_object stream)
c/write_array.c:_ecl_write_string(cl_object x, cl_object stream)
c/write_array.c:_ecl_write_base_string(cl_object x, cl_object stream)
c/write_array.c:_ecl_write_bitvector(cl_object x, cl_object stream)
c/write_code.c:_ecl_write_bytecodes_readably(cl_object x, cl_object stream, cl_object lex)
c/write_code.c:  cl_object code_l = ECL_NIL;
c/write_code.c:    cl_object record = ECL_CONS_CAR(lex);
c/write_code.c:_ecl_write_bytecodes(cl_object x, cl_object stream)
c/write_code.c:_ecl_write_bclosure(cl_object x, cl_object stream)
c/write_code.c:    cl_object name = x->bytecodes.name;
c/write_list.c:_ecl_write_list(cl_object x, cl_object stream)
c/write_list.c:  cl_object y;
c/write_object.c:_ecl_will_print_as_hash(cl_object x)
c/write_object.c:  cl_object circle_counter = ecl_symbol_value(ECL_SYM("SI::*CIRCLE-COUNTER*",1016));
c/write_object.c:  cl_object circle_stack = ecl_symbol_value(ECL_SYM("SI::*CIRCLE-STACK*",1017));
c/write_object.c:  cl_object code = ecl_gethash_safe(x, circle_stack, OBJNULL);
c/write_object.c:cl_object
c/write_object.c:si_search_print_circle(cl_object x)
c/write_object.c:  cl_object circle_counter = ecl_symbol_value(ECL_SYM("SI::*CIRCLE-COUNTER*",1016));
c/write_object.c:  cl_object circle_stack = ecl_symbol_value(ECL_SYM("SI::*CIRCLE-STACK*",1017));
c/write_object.c:  cl_object code;
c/write_object.c:cl_object
c/write_object.c:si_write_object_with_circle(cl_object x, cl_object stream, cl_object print_function)
c/write_object.c:      cl_object circle_counter;
c/write_object.c:        cl_object hash =
c/write_object.c:	cl_object __value0 = x;
c/write_object.c:cl_object
c/write_object.c:si_write_object(cl_object x, cl_object stream)
c/write_object.c:    cl_object f = _ecl_funcall2(ECL_SYM("PPRINT-DISPATCH",650), x);
c/write_object.c:	cl_object __value0 = x;
c/write_sse.c:write_sse_float(float v, cl_object stream)
c/write_sse.c:write_sse_double(double v, cl_object stream)
c/write_sse.c:write_sse_pack(cl_object x, cl_object stream)
c/write_sse.c:  cl_object mode = ecl_symbol_value(ECL_SYM("EXT::*SSE-PACK-PRINT-MODE*",1884));
c/write_sse.c:    cl_object buffer = si_get_buffer_string();
c/write_sse.c:_ecl_write_sse(cl_object x, cl_object stream)
c/write_symbol.c:potential_number_p(cl_object s, int base)
c/write_symbol.c:all_dots(cl_object s)
c/write_symbol.c:needs_to_be_escaped(cl_object s, cl_object readtable, cl_object print_case)
c/write_symbol.c:buffer_write_char(ecl_character c, cl_object buffer, cl_object stream, cl_index *buffer_ndx, cl_index buffer_size) {
c/write_symbol.c:write_symbol_string(cl_object s, int action, cl_object print_case,
c/write_symbol.c:                    cl_object stream, bool escape)
c/write_symbol.c:  cl_object buffer = si_get_buffer_string();
c/write_symbol.c:forced_print_package(cl_object package)
c/write_symbol.c:  cl_object print_package = ecl_symbol_value(ECL_SYM("SI::*PRINT-PACKAGE*",1030));
c/write_symbol.c:_ecl_write_symbol(cl_object x, cl_object stream)
c/write_symbol.c:  cl_object readtable = ecl_current_readtable();
c/write_symbol.c:  cl_object print_case = ecl_print_case();
c/write_symbol.c:  cl_object package;
c/write_symbol.c:  cl_object name;
c/write_symbol.c:      cl_object name = package->pack.name;
c/write_ugly.c:write_readable_pathname(cl_object path, cl_object stream)
c/write_ugly.c:  cl_object l =
c/write_ugly.c:write_pathname(cl_object path, cl_object stream)
c/write_ugly.c:  cl_object namestring = ecl_namestring(path, 0);
c/write_ugly.c:write_integer(cl_object number, cl_object stream)
c/write_ugly.c:  cl_object s = si_get_buffer_string();
c/write_ugly.c:_ecl_write_fixnum(cl_fixnum i, cl_object stream)
c/write_ugly.c:  cl_object s = si_get_buffer_string();
c/write_ugly.c:write_ratio(cl_object r, cl_object stream)
c/write_ugly.c:  cl_object s = si_get_buffer_string();
c/write_ugly.c:write_complex(cl_object x, cl_object stream)
c/write_ugly.c:write_float(cl_object f, cl_object stream)
c/write_ugly.c:  cl_object s = si_get_buffer_string();
c/write_ugly.c:write_complex_float(cl_object f, cl_object stream)
c/write_ugly.c:  cl_object real = OBJNULL, imag = OBJNULL;
c/write_ugly.c:write_character(cl_object x, cl_object stream)
c/write_ugly.c:      cl_object name = cl_char_name(ECL_CODE_CHAR(i));
c/write_ugly.c:write_package(cl_object x, cl_object stream)
c/write_ugly.c:write_hashtable(cl_object x, cl_object stream)
c/write_ugly.c:    cl_object make =
c/write_ugly.c:    cl_object init =
c/write_ugly.c:write_random(cl_object x, cl_object stream)
c/write_ugly.c:write_stream(cl_object x, cl_object stream)
c/write_ugly.c:  cl_object tag;
c/write_ugly.c:  cl_object buffer = OBJNULL;
c/write_ugly.c:    cl_object text = x->stream.object0;
c/write_ugly.c:write_instance(cl_object x, cl_object stream)
c/write_ugly.c:write_readtable(cl_object x, cl_object stream)
c/write_ugly.c:write_cfun(cl_object x, cl_object stream)
c/write_ugly.c:write_codeblock(cl_object x, cl_object stream)
c/write_ugly.c:write_cclosure(cl_object x, cl_object stream)
c/write_ugly.c:write_foreign(cl_object x, cl_object stream)
c/write_ugly.c:write_frame(cl_object x, cl_object stream)
c/write_ugly.c:write_weak_pointer(cl_object x, cl_object stream)
c/write_ugly.c:write_process(cl_object x, cl_object stream)
c/write_ugly.c:write_lock(cl_object x, cl_object stream)
c/write_ugly.c:write_rwlock(cl_object x, cl_object stream)
c/write_ugly.c:write_condition_variable(cl_object x, cl_object stream)
c/write_ugly.c:write_semaphore(cl_object x, cl_object stream)
c/write_ugly.c:write_barrier(cl_object x, cl_object stream)
c/write_ugly.c:write_mailbox(cl_object x, cl_object stream)
c/write_ugly.c:write_illegal(cl_object x, cl_object stream)
c/write_ugly.c:typedef void (*printer)(cl_object x, cl_object stream);
c/write_ugly.c:cl_object
c/write_ugly.c:si_write_ugly_object(cl_object x, cl_object stream)
c/write_ugly.c:	cl_object __value0 = x;
c/zerop.c:cl_object
c/zerop.c:cl_zerop(cl_object x)
c/zerop.c:	cl_object __value0 = (ecl_zerop(x) ? ECL_T : ECL_NIL);
c/zerop.c:ecl_zerop_fixnum(cl_object x)
c/zerop.c:ecl_zerop_ratio(cl_object x)
c/zerop.c:ecl_zerop_single_float(cl_object x)
c/zerop.c:ecl_zerop_double_float(cl_object x)
c/zerop.c:static int ecl_zerop_long_float(cl_object x)
c/zerop.c:ecl_zerop_complex(cl_object x)
c/zerop.c:ecl_zerop_csfloat(cl_object x)
c/zerop.c:ecl_zerop_cdfloat(cl_object x)
c/zerop.c:ecl_zerop_clfloat(cl_object x)
ecl/cache.h:        cl_object keys;
ecl/cache.h:        cl_object table;
ecl/cache.h:        cl_object clear_list;
ecl/cache.h:        cl_object key; /* vector[ndx] */
ecl/cache.h:        cl_object value; /* vector[ndx+1] */
ecl/cache.h:        cl_object gen; /* vector[ndx+2] */
ecl/cache.h:extern void ecl_cache_remove_one(ecl_cache_ptr cache, cl_object first_key);
ecl/cons.h:static ECL_INLINE cl_object _ecl_car(cl_object x)
ecl/cons.h:static ECL_INLINE cl_object _ecl_cdr(cl_object x)
ecl/cons.h:static ECL_INLINE cl_object _ecl_caar(cl_object x)
ecl/cons.h:static ECL_INLINE cl_object _ecl_cdar(cl_object x)
ecl/cons.h:static ECL_INLINE cl_object _ecl_cadr(cl_object x)
ecl/cons.h:static ECL_INLINE cl_object _ecl_cddr(cl_object x)
ecl/cons.h:static ECL_INLINE cl_object _ecl_caaar(cl_object x)
ecl/cons.h:static ECL_INLINE cl_object _ecl_cdaar(cl_object x)
ecl/cons.h:static ECL_INLINE cl_object _ecl_cadar(cl_object x)
ecl/cons.h:static ECL_INLINE cl_object _ecl_cddar(cl_object x)
ecl/cons.h:static ECL_INLINE cl_object _ecl_caadr(cl_object x)
ecl/cons.h:static ECL_INLINE cl_object _ecl_cdadr(cl_object x)
ecl/cons.h:static ECL_INLINE cl_object _ecl_caddr(cl_object x)
ecl/cons.h:static ECL_INLINE cl_object _ecl_cdddr(cl_object x)
ecl/cons.h:static ECL_INLINE cl_object _ecl_caaaar(cl_object x)
ecl/cons.h:static ECL_INLINE cl_object _ecl_cdaaar(cl_object x)
ecl/cons.h:static ECL_INLINE cl_object _ecl_cadaar(cl_object x)
ecl/cons.h:static ECL_INLINE cl_object _ecl_cddaar(cl_object x)
ecl/cons.h:static ECL_INLINE cl_object _ecl_caadar(cl_object x)
ecl/cons.h:static ECL_INLINE cl_object _ecl_cdadar(cl_object x)
ecl/cons.h:static ECL_INLINE cl_object _ecl_caddar(cl_object x)
ecl/cons.h:static ECL_INLINE cl_object _ecl_cdddar(cl_object x)
ecl/cons.h:static ECL_INLINE cl_object _ecl_caaadr(cl_object x)
ecl/cons.h:static ECL_INLINE cl_object _ecl_cdaadr(cl_object x)
ecl/cons.h:static ECL_INLINE cl_object _ecl_cadadr(cl_object x)
ecl/cons.h:static ECL_INLINE cl_object _ecl_cddadr(cl_object x)
ecl/cons.h:static ECL_INLINE cl_object _ecl_caaddr(cl_object x)
ecl/cons.h:static ECL_INLINE cl_object _ecl_cdaddr(cl_object x)
ecl/cons.h:static ECL_INLINE cl_object _ecl_cadddr(cl_object x)
ecl/cons.h:static ECL_INLINE cl_object _ecl_cddddr(cl_object x)
ecl/cons.h:extern ECL_API cl_object _ecl_car(cl_object);
ecl/cons.h:extern ECL_API cl_object _ecl_cdr(cl_object);
ecl/cons.h:extern ECL_API cl_object _ecl_caar(cl_object);
ecl/cons.h:extern ECL_API cl_object _ecl_cdar(cl_object);
ecl/cons.h:extern ECL_API cl_object _ecl_cadr(cl_object);
ecl/cons.h:extern ECL_API cl_object _ecl_cddr(cl_object);
ecl/cons.h:extern ECL_API cl_object _ecl_caaar(cl_object);
ecl/cons.h:extern ECL_API cl_object _ecl_cdaar(cl_object);
ecl/cons.h:extern ECL_API cl_object _ecl_cadar(cl_object);
ecl/cons.h:extern ECL_API cl_object _ecl_cddar(cl_object);
ecl/cons.h:extern ECL_API cl_object _ecl_caadr(cl_object);
ecl/cons.h:extern ECL_API cl_object _ecl_cdadr(cl_object);
ecl/cons.h:extern ECL_API cl_object _ecl_caddr(cl_object);
ecl/cons.h:extern ECL_API cl_object _ecl_cdddr(cl_object);
ecl/cons.h:extern ECL_API cl_object _ecl_caaaar(cl_object);
ecl/cons.h:extern ECL_API cl_object _ecl_cdaaar(cl_object);
ecl/cons.h:extern ECL_API cl_object _ecl_cadaar(cl_object);
ecl/cons.h:extern ECL_API cl_object _ecl_cddaar(cl_object);
ecl/cons.h:extern ECL_API cl_object _ecl_caadar(cl_object);
ecl/cons.h:extern ECL_API cl_object _ecl_cdadar(cl_object);
ecl/cons.h:extern ECL_API cl_object _ecl_caddar(cl_object);
ecl/cons.h:extern ECL_API cl_object _ecl_cdddar(cl_object);
ecl/cons.h:extern ECL_API cl_object _ecl_caaadr(cl_object);
ecl/cons.h:extern ECL_API cl_object _ecl_cdaadr(cl_object);
ecl/cons.h:extern ECL_API cl_object _ecl_cadadr(cl_object);
ecl/cons.h:extern ECL_API cl_object _ecl_cddadr(cl_object);
ecl/cons.h:extern ECL_API cl_object _ecl_caaddr(cl_object);
ecl/cons.h:extern ECL_API cl_object _ecl_cdaddr(cl_object);
ecl/cons.h:extern ECL_API cl_object _ecl_cadddr(cl_object);
ecl/cons.h:extern ECL_API cl_object _ecl_cddddr(cl_object);
ecl/cons.h:extern ECL_API cl_object ecl_car(cl_object);
ecl/cons.h:extern ECL_API cl_object ecl_cdr(cl_object);
ecl/cons.h:extern ECL_API cl_object ecl_caar(cl_object);
ecl/cons.h:extern ECL_API cl_object ecl_cdar(cl_object);
ecl/cons.h:extern ECL_API cl_object ecl_cadr(cl_object);
ecl/cons.h:extern ECL_API cl_object ecl_cddr(cl_object);
ecl/cons.h:extern ECL_API cl_object ecl_caaar(cl_object);
ecl/cons.h:extern ECL_API cl_object ecl_cdaar(cl_object);
ecl/cons.h:extern ECL_API cl_object ecl_cadar(cl_object);
ecl/cons.h:extern ECL_API cl_object ecl_cddar(cl_object);
ecl/cons.h:extern ECL_API cl_object ecl_caadr(cl_object);
ecl/cons.h:extern ECL_API cl_object ecl_cdadr(cl_object);
ecl/cons.h:extern ECL_API cl_object ecl_caddr(cl_object);
ecl/cons.h:extern ECL_API cl_object ecl_cdddr(cl_object);
ecl/cons.h:extern ECL_API cl_object ecl_caaaar(cl_object);
ecl/cons.h:extern ECL_API cl_object ecl_cdaaar(cl_object);
ecl/cons.h:extern ECL_API cl_object ecl_cadaar(cl_object);
ecl/cons.h:extern ECL_API cl_object ecl_cddaar(cl_object);
ecl/cons.h:extern ECL_API cl_object ecl_caadar(cl_object);
ecl/cons.h:extern ECL_API cl_object ecl_cdadar(cl_object);
ecl/cons.h:extern ECL_API cl_object ecl_caddar(cl_object);
ecl/cons.h:extern ECL_API cl_object ecl_cdddar(cl_object);
ecl/cons.h:extern ECL_API cl_object ecl_caaadr(cl_object);
ecl/cons.h:extern ECL_API cl_object ecl_cdaadr(cl_object);
ecl/cons.h:extern ECL_API cl_object ecl_cadadr(cl_object);
ecl/cons.h:extern ECL_API cl_object ecl_cddadr(cl_object);
ecl/cons.h:extern ECL_API cl_object ecl_caaddr(cl_object);
ecl/cons.h:extern ECL_API cl_object ecl_cdaddr(cl_object);
ecl/cons.h:extern ECL_API cl_object ecl_cadddr(cl_object);
ecl/cons.h:extern ECL_API cl_object ecl_cddddr(cl_object);
ecl/cons.h:extern ECL_API cl_object cl_car(cl_object);
ecl/cons.h:extern ECL_API cl_object cl_cdr(cl_object);
ecl/cons.h:extern ECL_API cl_object cl_caar(cl_object);
ecl/cons.h:extern ECL_API cl_object cl_cdar(cl_object);
ecl/cons.h:extern ECL_API cl_object cl_cadr(cl_object);
ecl/cons.h:extern ECL_API cl_object cl_cddr(cl_object);
ecl/cons.h:extern ECL_API cl_object cl_caaar(cl_object);
ecl/cons.h:extern ECL_API cl_object cl_cdaar(cl_object);
ecl/cons.h:extern ECL_API cl_object cl_cadar(cl_object);
ecl/cons.h:extern ECL_API cl_object cl_cddar(cl_object);
ecl/cons.h:extern ECL_API cl_object cl_caadr(cl_object);
ecl/cons.h:extern ECL_API cl_object cl_cdadr(cl_object);
ecl/cons.h:extern ECL_API cl_object cl_caddr(cl_object);
ecl/cons.h:extern ECL_API cl_object cl_cdddr(cl_object);
ecl/cons.h:extern ECL_API cl_object cl_caaaar(cl_object);
ecl/cons.h:extern ECL_API cl_object cl_cdaaar(cl_object);
ecl/cons.h:extern ECL_API cl_object cl_cadaar(cl_object);
ecl/cons.h:extern ECL_API cl_object cl_cddaar(cl_object);
ecl/cons.h:extern ECL_API cl_object cl_caadar(cl_object);
ecl/cons.h:extern ECL_API cl_object cl_cdadar(cl_object);
ecl/cons.h:extern ECL_API cl_object cl_caddar(cl_object);
ecl/cons.h:extern ECL_API cl_object cl_cdddar(cl_object);
ecl/cons.h:extern ECL_API cl_object cl_caaadr(cl_object);
ecl/cons.h:extern ECL_API cl_object cl_cdaadr(cl_object);
ecl/cons.h:extern ECL_API cl_object cl_cadadr(cl_object);
ecl/cons.h:extern ECL_API cl_object cl_cddadr(cl_object);
ecl/cons.h:extern ECL_API cl_object cl_caaddr(cl_object);
ecl/cons.h:extern ECL_API cl_object cl_cdaddr(cl_object);
ecl/cons.h:extern ECL_API cl_object cl_cadddr(cl_object);
ecl/cons.h:extern ECL_API cl_object cl_cddddr(cl_object);
ecl/cs.h:#define cl_nextarg(arg)         va_arg((arg),cl_object)
ecl/cs.h:#define CSTACK(size)            register cl_object *_stack_top; \
ecl/cs.h:                                cl_object _stack_bot[size]; \
ecl/cs.h:#define CCALL(narg,fun)         ({register cl_object eax asm("%eax"); \
ecl/cs.h:#define ARGSTACK(size)          register cl_object *_stack_top; \
ecl/cs.h:                                cl_object _stack_bot[size+1]; \
ecl/cs.h:#define ARGSTACK(size)          register volatile cl_object *_stack_top; \
ecl/cs.h:                                cl_object _stack_bot[size+1]; \
ecl/cs.h:#define ARGCALL(narg, fun)  ({ register cl_object _res asm("%o0"); \
ecl/cs.h:#define TRANSFER_CALL(fun)      REG = (cl_object)fun; \
ecl/cs.h:#define CSTACK(size)            register cl_object REG
ecl/cs.h:#define CPUSH(val)              (REG = (cl_object)(val), \
ecl/cs.h:#define CCALL(narg, fun)                (REG = (cl_object)(narg), \
ecl/cs.h:                                 REG = (cl_object)(fun), \
ecl/ecl-cmp.h:        _ecl_object_loc = 0,
ecl/ecl-inl.h:  cl_object __slow; \
ecl/ecl-inl.h:  const cl_object __ecl_l0 = list; \
ecl/ecl-inl.h:    cl_object __slow; \
ecl/ecl-inl.h:        static const cl_object name = (cl_object)(& name ## _data)
ecl/ecl-inl.h:        static const cl_object name = (cl_object)(& name ## _data)
ecl/ecl-inl.h:        static const cl_object name = (cl_object)(& name ## _data)
ecl/ecl-inl.h:        static const cl_object name = (cl_object)(& name ## _data)
ecl/ecl-inl.h:        static const cl_object name = (cl_object)(& name ## _data)
ecl/ecl-inl.h:                (cl_object)real, (cl_object)imag };                     \
ecl/ecl-inl.h:        static const cl_object name = (cl_object)(& name ## _data)
ecl/ecl-inl.h:        static const cl_object name = (cl_object)(& name ## _data)
ecl/ecl-inl.h:        static const cl_object name = (cl_object)(& name ## _data)
ecl/ecl-inl.h:        static const cl_object name = (cl_object)(& name ## _data)
ecl/ecl-inl.h:                ecl_cast_ptr(cl_object*,raw), 0 };                      \
ecl/ecl-inl.h:        static const cl_object name = (cl_object)(& name ## _data)
ecl/ecl-inl.h:        static const cl_object name = (cl_object)(& name ## _data)
ecl/ecl.h:typedef void (*ecl_init_function_t)(cl_object block);
ecl/ecl_atomics.h:static inline cl_object
ecl/ecl_atomics.h:ecl_compare_and_swap(cl_object *slot, cl_object old_val, cl_object new_val)
ecl/ecl_atomics.h:  return (cl_object)AO_fetch_compare_and_swap((AO_t*)slot, (AO_t)old_val, (AO_t)new_val);
ecl/ecl_atomics.h:static inline cl_object
ecl/ecl_atomics.h:ecl_atomic_incf(cl_object *slot, cl_object increment)
ecl/ecl_atomics.h:  return (cl_object)AO_fetch_and_add((AO_t*)slot, (AO_t)increment & ~(AO_t)ECL_IMMEDIATE_TAG);
ecl/ecl_atomics.h:static inline cl_object
ecl/ecl_atomics.h:ecl_atomic_incf_by_fixnum(cl_object *slot, cl_fixnum increment)
ecl/ecl_atomics.h:  return (cl_object)AO_fetch_and_add((AO_t*)slot, (AO_t)increment << ECL_TAG_BITS);
ecl/external.h:        cl_object values[ECL_MULTIPLE_VALUES_LIMIT];
ecl/external.h:        cl_object function;
ecl/external.h:        cl_object stack_frame;
ecl/external.h:        cl_object *stack;
ecl/external.h:        cl_object *stack_top;
ecl/external.h:        cl_object *stack_limit;
ecl/external.h:        cl_object *thread_local_bindings;
ecl/external.h:        cl_object bindings_array;
ecl/external.h:        cl_object string_pool;
ecl/external.h:        cl_object fmt_aux_stream;
ecl/external.h:        cl_object big_register[ECL_BIGNUM_REGISTER_NUMBER];
ecl/external.h:        cl_object own_process;
ecl/external.h:        cl_object packages_to_be_created;
ecl/external.h:        cl_object packages_to_be_created_p;
ecl/external.h:        cl_object pending_interrupt;
ecl/external.h:        cl_object signal_queue;
ecl/external.h:        cl_object signal_queue_spinlock;
ecl/external.h:        cl_object packages;
ecl/external.h:        cl_object lisp_package;
ecl/external.h:        cl_object user_package;
ecl/external.h:        cl_object keyword_package;
ecl/external.h:        cl_object system_package;
ecl/external.h:        cl_object ext_package;
ecl/external.h:        cl_object clos_package;
ecl/external.h:        cl_object gray_package;
ecl/external.h:        cl_object mp_package;
ecl/external.h:        cl_object c_package;
ecl/external.h:        cl_object ffi_package;
ecl/external.h:        cl_object pathname_translations;
ecl/external.h:        cl_object library_pathname;
ecl/external.h:        cl_object terminal_io;
ecl/external.h:        cl_object null_stream;
ecl/external.h:        cl_object standard_input;
ecl/external.h:        cl_object standard_output;
ecl/external.h:        cl_object error_output;
ecl/external.h:        cl_object standard_readtable;
ecl/external.h:        cl_object dispatch_reader;
ecl/external.h:        cl_object default_dispatch_macro;
ecl/external.h:        cl_object char_names;
ecl/external.h:        cl_object null_string;
ecl/external.h:        cl_object plus_half;
ecl/external.h:        cl_object minus_half;
ecl/external.h:        cl_object imag_unit;
ecl/external.h:        cl_object minus_imag_unit;
ecl/external.h:        cl_object imag_two;
ecl/external.h:        cl_object singlefloat_zero;
ecl/external.h:        cl_object doublefloat_zero;
ecl/external.h:        cl_object singlefloat_minus_zero;
ecl/external.h:        cl_object doublefloat_minus_zero;
ecl/external.h:        cl_object longfloat_zero;
ecl/external.h:        cl_object longfloat_minus_zero;
ecl/external.h:        cl_object gensym_prefix;
ecl/external.h:        cl_object gentemp_prefix;
ecl/external.h:        cl_object gentemp_counter;
ecl/external.h:        cl_object Jan1st1970UT;
ecl/external.h:        cl_object system_properties;
ecl/external.h:        cl_object setf_definitions;
ecl/external.h:        cl_object processes;
ecl/external.h:        cl_object processes_spinlock;
ecl/external.h:        cl_object global_lock;
ecl/external.h:        cl_object error_lock;
ecl/external.h:        cl_object global_env_lock;
ecl/external.h:        cl_object libraries;
ecl/external.h:        cl_object bytes_consed;
ecl/external.h:        cl_object gc_counter;
ecl/external.h:        cl_object reused_indices;
ecl/external.h:        cl_object slash;
ecl/external.h:        cl_object compiler_dispatch;
ecl/external.h:        cl_object rehash_size;
ecl/external.h:        cl_object rehash_threshold;
ecl/external.h:        cl_object known_signals;
ecl/external.h:extern ECL_API cl_object ecl_alloc_object(cl_type t);
ecl/external.h:extern ECL_API cl_object ecl_alloc_instance(cl_index slots);
ecl/external.h:extern ECL_API cl_object ecl_cons(cl_object a, cl_object d);
ecl/external.h:extern ECL_API cl_object ecl_list1(cl_object a);
ecl/external.h:extern ECL_API cl_object si_gc(cl_narg narg, ...);
ecl/external.h:extern ECL_API cl_object si_gc_dump(void);
ecl/external.h:extern ECL_API cl_object si_gc_stats(cl_object enable);
ecl/external.h:extern ECL_API cl_object ecl_alloc_compact_object(cl_type t, cl_index extra_space);
ecl/external.h:extern ECL_API cl_object si_make_weak_pointer(cl_object o);
ecl/external.h:extern ECL_API cl_object si_weak_pointer_value(cl_object o);
ecl/external.h:extern ECL_API cl_object si_allocate _ECL_ARGS((cl_narg narg, cl_object type, cl_object qty, ...));
ecl/external.h:extern ECL_API cl_object si_maximum_allocatable_pages _ECL_ARGS((cl_narg narg, cl_object type, ...));
ecl/external.h:extern ECL_API cl_object si_allocated_pages _ECL_ARGS((cl_narg narg, cl_object type, ...));
ecl/external.h:extern ECL_API cl_object si_alloc_contpage _ECL_ARGS((cl_narg narg, cl_object qty, ...));
ecl/external.h:extern ECL_API cl_object si_allocated_contiguous_pages _ECL_ARGS((cl_narg narg, ...));
ecl/external.h:extern ECL_API cl_object si_maximum_contiguous_pages _ECL_ARGS((cl_narg narg, ...));
ecl/external.h:extern ECL_API cl_object si_allocate_contiguous_pages _ECL_ARGS((cl_narg narg, cl_object qty, ...));
ecl/external.h:extern ECL_API cl_object si_get_hole_size _ECL_ARGS((cl_narg narg, ...));
ecl/external.h:extern ECL_API cl_object si_set_hole_size _ECL_ARGS((cl_narg narg, cl_object size, ...));
ecl/external.h:extern ECL_API cl_object si_ignore_maximum_pages _ECL_ARGS((cl_narg narg, ...));
ecl/external.h:extern ECL_API cl_object si_mangle_name _ECL_ARGS((cl_narg narg, cl_object symbol, ...));
ecl/external.h:                cl_object value;
ecl/external.h:#define ECL_SYM(name,code) ((cl_object)(cl_symbols+(code)))
ecl/external.h:extern ECL_API cl_object APPLY_fixed(cl_narg n, cl_object (*f)(), cl_object *x);
ecl/external.h:extern ECL_API cl_object APPLY(cl_narg n, cl_objectfn, cl_object *x);
ecl/external.h:extern ECL_API cl_object cl_row_major_aref(cl_object x, cl_object i);
ecl/external.h:extern ECL_API cl_object si_row_major_aset(cl_object x, cl_object i, cl_object v);
ecl/external.h:extern ECL_API cl_object si_make_vector(cl_object etype, cl_object dim, cl_object adj, cl_object fillp, cl_object displ, cl_object disploff);
ecl/external.h:extern ECL_API void *ecl_row_major_ptr(cl_object arr, cl_index index, cl_index bytes);
ecl/external.h:extern ECL_API cl_object cl_array_element_type(cl_object a);
ecl/external.h:extern ECL_API cl_object cl_array_rank(cl_object a);
ecl/external.h:extern ECL_API cl_object cl_array_dimension(cl_object a, cl_object index);
ecl/external.h:extern ECL_API cl_object cl_array_total_size(cl_object a);
ecl/external.h:extern ECL_API cl_object cl_adjustable_array_p(cl_object a);
ecl/external.h:extern ECL_API cl_object cl_array_displacement(cl_object a);
ecl/external.h:extern ECL_API cl_object si_array_raw_data(cl_object array);
ecl/external.h:extern ECL_API cl_object si_array_element_type_byte_size(cl_object type);
ecl/external.h:extern ECL_API cl_object cl_svref(cl_object x, cl_object index);
ecl/external.h:extern ECL_API cl_object si_svset(cl_object x, cl_object index, cl_object v);
ecl/external.h:extern ECL_API cl_object cl_array_has_fill_pointer_p(cl_object a);
ecl/external.h:extern ECL_API cl_object cl_fill_pointer(cl_object a);
ecl/external.h:extern ECL_API cl_object si_fill_pointer_set(cl_object a, cl_object fp);
ecl/external.h:extern ECL_API cl_object si_replace_array(cl_object old_obj, cl_object new_obj);
ecl/external.h:extern ECL_API cl_object cl_aref _ECL_ARGS((cl_narg narg, cl_object x, ...));
ecl/external.h:extern ECL_API cl_object si_aset _ECL_ARGS((cl_narg narg, cl_object x, ...));
ecl/external.h:extern ECL_API cl_object si_make_pure_array(cl_object etype, cl_object dims, cl_object adj, cl_object fillp, cl_object displ, cl_object disploff);
ecl/external.h:extern ECL_API cl_object si_copy_subarray(cl_object dest, cl_object start0, cl_object orig, cl_object start1, cl_object length);
ecl/external.h:extern ECL_API cl_object si_fill_array_with_elt(cl_object array, cl_object elt, cl_object start, cl_object end);
ecl/external.h:extern ECL_API void FEwrong_dimensions(cl_object a, cl_index rank) ecl_attr_noreturn;
ecl/external.h:extern ECL_API cl_index ecl_to_index(cl_object n);
ecl/external.h:extern ECL_API cl_index ecl_array_dimension(cl_object x, cl_index n);
ecl/external.h:extern ECL_API cl_index ecl_array_rank(cl_object x);
ecl/external.h:extern ECL_API cl_object ecl_aref_unsafe(cl_object x, cl_index index);
ecl/external.h:extern ECL_API cl_object ecl_aset_unsafe(cl_object x, cl_index index, cl_object value);
ecl/external.h:extern ECL_API cl_object ecl_aref(cl_object x, cl_index index);
ecl/external.h:extern ECL_API cl_object ecl_aref1(cl_object v, cl_index index);
ecl/external.h:extern ECL_API cl_object ecl_aset(cl_object x, cl_index index, cl_object value);
ecl/external.h:extern ECL_API cl_object ecl_aset1(cl_object v, cl_index index, cl_object val);
ecl/external.h:extern ECL_API void ecl_array_allocself(cl_object x);
ecl/external.h:extern ECL_API cl_object ecl_alloc_simple_vector(cl_index l, cl_elttype aet);
ecl/external.h:extern ECL_API cl_elttype ecl_array_elttype(cl_object x);
ecl/external.h:extern ECL_API cl_elttype ecl_symbol_to_elttype(cl_object x);
ecl/external.h:extern ECL_API cl_object ecl_elttype_to_symbol(cl_elttype aet);
ecl/external.h:extern ECL_API void ecl_copy_subarray(cl_object dest, cl_index i0, cl_object orig, cl_index i1, cl_index l);
ecl/external.h:extern ECL_API void ecl_reverse_subarray(cl_object dest, cl_index i0, cl_index i1);
ecl/external.h:extern ECL_API cl_object mp_compare_and_swap_svref(cl_object x, cl_object index, cl_object old_val, cl_object new_val);
ecl/external.h:extern ECL_API cl_object mp_atomic_incf_svref(cl_object x, cl_object index, cl_object increment);
ecl/external.h:extern ECL_API cl_object cl_set(cl_object var, cl_object val);
ecl/external.h:extern ECL_API cl_object cl_makunbound(cl_object sym);
ecl/external.h:extern ECL_API cl_object cl_fmakunbound(cl_object sym);
ecl/external.h:extern ECL_API cl_object si_fset _ECL_ARGS((cl_narg narg, cl_object fun, cl_object def, ...));
ecl/external.h:extern ECL_API cl_object si_get_sysprop(cl_object sym, cl_object prop);
ecl/external.h:extern ECL_API cl_object si_put_sysprop(cl_object sym, cl_object prop, cl_object value);
ecl/external.h:extern ECL_API cl_object si_rem_sysprop(cl_object sym, cl_object prop);
ecl/external.h:extern ECL_API cl_object ecl_setf_definition(cl_object fname, cl_object createp);
ecl/external.h:extern ECL_API cl_object si_setf_definition(cl_object fname, cl_object createp);
ecl/external.h:extern ECL_API void ecl_clear_compiler_properties(cl_object sym);
ecl/external.h:extern ECL_API cl_object mp_compare_and_swap_symbol_value(cl_object x, cl_object old_val, cl_object new_val);
ecl/external.h:extern ECL_API cl_object mp_atomic_incf_symbol_value(cl_object x, cl_object increment);
ecl/external.h:extern ECL_API cl_object _ecl_fix_times_fix(cl_fixnum x, cl_fixnum y);
ecl/external.h:extern ECL_API cl_object _ecl_big_register_copy(cl_object x);
ecl/external.h:extern ECL_API cl_object _ecl_big_register_normalize(cl_object x);
ecl/external.h:extern ECL_API cl_object _ecl_big_times_fix(cl_object x, cl_fixnum y);
ecl/external.h:extern ECL_API cl_object _ecl_big_times_big(cl_object x, cl_object y);
ecl/external.h:extern ECL_API cl_object _ecl_big_plus_fix(cl_object x, cl_fixnum y);
ecl/external.h:extern ECL_API cl_object _ecl_big_plus_big(cl_object x, cl_object y);
ecl/external.h:extern ECL_API cl_object _ecl_fix_minus_big(cl_fixnum x, cl_object y);
ecl/external.h:extern ECL_API cl_object _ecl_big_minus_big(cl_object x, cl_object y);
ecl/external.h:extern ECL_API cl_object _ecl_fix_divided_by_big(cl_fixnum x, cl_object y);
ecl/external.h:extern ECL_API cl_object _ecl_big_divided_by_fix(cl_object x, cl_fixnum y);
ecl/external.h:extern ECL_API cl_object _ecl_big_divided_by_big(cl_object x, cl_object y);
ecl/external.h:extern ECL_API cl_object _ecl_big_gcd(cl_object x, cl_object y);
ecl/external.h:extern ECL_API cl_object _ecl_big_ceiling(cl_object x, cl_object y, cl_object *r);
ecl/external.h:extern ECL_API cl_object _ecl_big_floor(cl_object x, cl_object y, cl_object *r);
ecl/external.h:extern ECL_API cl_object _ecl_big_negate(cl_object x);
ecl/external.h:extern ECL_API void _ecl_big_register_free(cl_object x);
ecl/external.h:extern ECL_API cl_object si_compiled_function_name(cl_object fun);
ecl/external.h:extern ECL_API cl_object si_compiled_function_block(cl_object fun);
ecl/external.h:extern ECL_API cl_object cl_function_lambda_expression(cl_object fun);
ecl/external.h:extern ECL_API cl_object si_compiled_function_file(cl_object fun);
ecl/external.h:extern ECL_API cl_object ecl_make_cfun(cl_objectfn_fixed c_function, cl_object name, cl_object block, int narg);
ecl/external.h:extern ECL_API cl_object ecl_make_cfun_va(cl_objectfn c_function, cl_object name, cl_object block, int narg_fixed);
ecl/external.h:extern ECL_API cl_object ecl_make_cclosure_va(cl_objectfn c_function, cl_object env, cl_object block, int narg_fixed);
ecl/external.h:extern ECL_API void ecl_def_c_function(cl_object sym, cl_objectfn_fixed c_function, int narg);
ecl/external.h:extern ECL_API void ecl_def_c_macro(cl_object sym, cl_objectfn_fixed c_function, int narg);
ecl/external.h:extern ECL_API void ecl_def_c_macro_va(cl_object sym, cl_objectfn c_function, int narg_fixed);
ecl/external.h:extern ECL_API void ecl_def_c_function_va(cl_object sym, cl_objectfn c_function, int narg_fixed);
ecl/external.h:extern ECL_API void ecl_set_function_source_file_info(cl_object fun, cl_object source, cl_object position);
ecl/external.h:extern ECL_API void ecl_cmp_defmacro(cl_object data);
ecl/external.h:extern ECL_API void ecl_cmp_defun(cl_object data);
ecl/external.h:extern ECL_API cl_object cl_digit_char_p _ECL_ARGS((cl_narg narg, cl_object c, ...));
ecl/external.h:extern ECL_API cl_object cl_charE _ECL_ARGS((cl_narg narg, cl_object c, ...));
ecl/external.h:extern ECL_API cl_object cl_charNE _ECL_ARGS((cl_narg narg, ...));
ecl/external.h:extern ECL_API cl_object cl_charL _ECL_ARGS((cl_narg narg, ...));
ecl/external.h:extern ECL_API cl_object cl_charG _ECL_ARGS((cl_narg narg, ...));
ecl/external.h:extern ECL_API cl_object cl_charLE _ECL_ARGS((cl_narg narg, ...));
ecl/external.h:extern ECL_API cl_object cl_charGE _ECL_ARGS((cl_narg narg, ...));
ecl/external.h:extern ECL_API cl_object cl_char_equal _ECL_ARGS((cl_narg narg, cl_object c, ...));
ecl/external.h:extern ECL_API cl_object cl_char_not_equal _ECL_ARGS((cl_narg narg, ...));
ecl/external.h:extern ECL_API cl_object cl_char_lessp _ECL_ARGS((cl_narg narg, ...));
ecl/external.h:extern ECL_API cl_object cl_char_greaterp _ECL_ARGS((cl_narg narg, ...));
ecl/external.h:extern ECL_API cl_object cl_char_not_greaterp _ECL_ARGS((cl_narg narg, ...));
ecl/external.h:extern ECL_API cl_object cl_char_not_lessp _ECL_ARGS((cl_narg narg, ...));
ecl/external.h:extern ECL_API cl_object cl_digit_char _ECL_ARGS((cl_narg narg, cl_object w, ...));
ecl/external.h:extern ECL_API cl_object cl_alpha_char_p(cl_object c);
ecl/external.h:extern ECL_API cl_object cl_alphanumericp(cl_object c);
ecl/external.h:extern ECL_API cl_object cl_both_case_p(cl_object c);
ecl/external.h:extern ECL_API cl_object cl_char_code(cl_object c);
ecl/external.h:extern ECL_API cl_object cl_char_downcase(cl_object c);
ecl/external.h:extern ECL_API cl_object cl_char_int(cl_object c);
ecl/external.h:extern ECL_API cl_object cl_char_name(cl_object c);
ecl/external.h:extern ECL_API cl_object cl_char_upcase(cl_object c);
ecl/external.h:extern ECL_API cl_object cl_character(cl_object x);
ecl/external.h:extern ECL_API cl_object cl_code_char(cl_object c);
ecl/external.h:extern ECL_API cl_object cl_graphic_char_p(cl_object c);
ecl/external.h:extern ECL_API cl_object cl_lower_case_p(cl_object c);
ecl/external.h:extern ECL_API cl_object cl_name_char(cl_object s);
ecl/external.h:extern ECL_API cl_object cl_standard_char_p(cl_object c);
ecl/external.h:extern ECL_API cl_object cl_upper_case_p(cl_object c);
ecl/external.h:extern ECL_API int ecl_string_case(cl_object s);
ecl/external.h:extern ECL_API int ecl_base_string_case(cl_object s);
ecl/external.h:extern ECL_API ecl_character ecl_char_code(cl_object c);
ecl/external.h:extern ECL_API ecl_base_char ecl_base_char_code(cl_object c);
ecl/external.h:extern ECL_API bool ecl_char_eq(cl_object x, cl_object y);
ecl/external.h:extern ECL_API int ecl_char_cmp(cl_object x, cl_object y);
ecl/external.h:extern ECL_API bool ecl_char_equal(cl_object x, cl_object y);
ecl/external.h:extern ECL_API int ecl_char_compare(cl_object x, cl_object y);
ecl/external.h:extern ECL_API cl_object cl_find_class _ECL_ARGS((cl_narg narg, cl_object name, ...));
ecl/external.h:extern ECL_API cl_object cl_class_of(cl_object x);
ecl/external.h:extern ECL_API cl_object si_specialp(cl_object sym);
ecl/external.h:extern ECL_API char ecl_to_char(cl_object x);
ecl/external.h:extern ECL_API cl_fixnum ecl_to_fixnum(cl_object x);
ecl/external.h:extern ECL_API cl_index ecl_to_unsigned_integer(cl_object x);
ecl/external.h:extern ECL_API int ecl_aref_bv(cl_object x, cl_index index);
ecl/external.h:extern ECL_API int ecl_aset_bv(cl_object x, cl_index index, int value);
ecl/external.h:extern ECL_API void cl_throw(cl_object tag) /*ecl_attr_noreturn*/;
ecl/external.h:extern ECL_API void cl_return_from(cl_object block_id, cl_object block_name) /*ecl_attr_noreturn*/;
ecl/external.h:extern ECL_API void cl_go(cl_object tag_id, cl_object label) /*ecl_attr_noreturn*/;
ecl/external.h:extern ECL_API void cl_parse_key(ecl_va_list args, int nkey, cl_object *keys, cl_object *vars, cl_object *rest, bool allow_other_keys);
ecl/external.h:extern ECL_API cl_object cl_grab_rest_args(ecl_va_list args);
ecl/external.h:extern ECL_API cl_object si_macrolet_function(cl_object form, cl_object env);
ecl/external.h:extern ECL_API cl_object si_need_to_make_load_form_p(cl_object object);
ecl/external.h:extern ECL_API cl_object si_process_lambda_list(cl_object lambda_list, cl_object context);
ecl/external.h:extern ECL_API cl_object si_process_lambda(cl_object lambda);
ecl/external.h:extern ECL_API cl_object si_make_lambda(cl_object name, cl_object body);
ecl/external.h:extern ECL_API cl_object si_function_block_name(cl_object name);
ecl/external.h:extern ECL_API cl_object si_valid_function_name_p(cl_object name);
ecl/external.h:extern ECL_API cl_object si_process_declarations _ECL_ARGS((cl_narg narg, cl_object body, ...));
ecl/external.h:extern ECL_API cl_object si_bc_compile_from_stream (cl_object input);
ecl/external.h:extern ECL_API cl_object si_eval_with_env _ECL_ARGS((cl_narg narg, cl_object form, ...));
ecl/external.h:extern ECL_API cl_object si_interpreter_stack _ECL_ARGS((cl_narg narg, ...));
ecl/external.h:extern ECL_API cl_object ecl_stack_frame_open(cl_env_ptr env, cl_object f, cl_index size);
ecl/external.h:extern ECL_API void ecl_stack_frame_push(cl_object f, cl_object o);
ecl/external.h:extern ECL_API void ecl_stack_frame_push_values(cl_object f);
ecl/external.h:extern ECL_API cl_object ecl_stack_frame_pop_values(cl_object f);
ecl/external.h:extern ECL_API void ecl_stack_frame_close(cl_object f);
ecl/external.h:extern ECL_API cl_object *ecl_stack_grow(cl_env_ptr env);
ecl/external.h:extern ECL_API cl_object *ecl_stack_set_size(cl_env_ptr env, cl_index new_size);
ecl/external.h:extern ECL_API cl_object ecl_interpret(cl_object frame, cl_object env, cl_object bytecodes);
ecl/external.h:extern ECL_API cl_object _ecl_bytecodes_dispatch(cl_narg narg, ...);
ecl/external.h:extern ECL_API cl_object _ecl_bclosure_dispatch(cl_narg narg, ...);
ecl/external.h:extern ECL_API cl_object si_bc_disassemble(cl_object v);
ecl/external.h:extern ECL_API cl_object si_bc_split(cl_object v);
ecl/external.h:extern ECL_API cl_object si_bc_join(cl_object lex, cl_object code, cl_object data, cl_object name);
ecl/external.h:extern ECL_API cl_object cl_error _ECL_ARGS((cl_narg narg, cl_object eformat, ...)) ecl_attr_noreturn;
ecl/external.h:extern ECL_API cl_object cl_cerror _ECL_ARGS((cl_narg narg, cl_object cformat, cl_object eformat, ...));
ecl/external.h:extern ECL_API void FEreader_error(const char *s, cl_object stream, int narg, ...) ecl_attr_noreturn;
ecl/external.h:extern ECL_API void FEcannot_open(cl_object fn) ecl_attr_noreturn;
ecl/external.h:extern ECL_API void FEend_of_file(cl_object strm) ecl_attr_noreturn;
ecl/external.h:extern ECL_API void FEclosed_stream(cl_object strm) ecl_attr_noreturn;
ecl/external.h:extern ECL_API void FEwrong_type_argument(cl_object type, cl_object value) ecl_attr_noreturn;
ecl/external.h:extern ECL_API void FEwrong_type_only_arg(cl_object function, cl_object type, cl_object value) ecl_attr_noreturn;
ecl/external.h:extern ECL_API void FEwrong_type_nth_arg(cl_object function, cl_narg narg, cl_object value, cl_object type) ecl_attr_noreturn;
ecl/external.h:extern ECL_API void FEwrong_type_key_arg(cl_object function, cl_object keyo, cl_object type, cl_object value) ecl_attr_noreturn;
ecl/external.h:extern ECL_API void FEwrong_num_arguments(cl_object fun) ecl_attr_noreturn;
ecl/external.h:extern ECL_API void FEwrong_index(cl_object function, cl_object a, int which, cl_object ndx, cl_index nonincl_limit) ecl_attr_noreturn;
ecl/external.h:extern ECL_API void FEunbound_variable(cl_object sym) ecl_attr_noreturn;
ecl/external.h:extern ECL_API void FEinvalid_macro_call(cl_object obj) ecl_attr_noreturn;
ecl/external.h:extern ECL_API void FEinvalid_variable(const char *s, cl_object obj) ecl_attr_noreturn;
ecl/external.h:extern ECL_API void FEillegal_variable_name(cl_object) ecl_attr_noreturn;
ecl/external.h:extern ECL_API void FEassignment_to_constant(cl_object v) ecl_attr_noreturn;
ecl/external.h:extern ECL_API void FEbinding_a_constant(cl_object v) ecl_attr_noreturn;
ecl/external.h:extern ECL_API void FEundefined_function(cl_object fname) ecl_attr_noreturn;
ecl/external.h:extern ECL_API void FEinvalid_function(cl_object obj) ecl_attr_noreturn;
ecl/external.h:extern ECL_API void FEinvalid_function_name(cl_object obj) ecl_attr_noreturn;
ecl/external.h:extern ECL_API void FEprint_not_readable(cl_object obj) ecl_attr_noreturn;
ecl/external.h:extern ECL_API cl_object CEerror(cl_object c, const char *err_str, int narg, ...);
ecl/external.h:extern ECL_API cl_object si_signal_type_error(cl_object value, cl_object type) ecl_attr_noreturn;
ecl/external.h:extern ECL_API cl_object cl_funcall _ECL_ARGS((cl_narg narg, cl_object fun, ...));
ecl/external.h:extern ECL_API cl_object cl_apply _ECL_ARGS((cl_narg narg, cl_object fun, cl_object arg, ...));
ecl/external.h:extern ECL_API cl_object si_safe_eval _ECL_ARGS((cl_narg narg, cl_object form, cl_object env, ...));
ecl/external.h:extern ECL_API cl_object *_ecl_va_sp(cl_narg narg);
ecl/external.h:extern ECL_API cl_object si_unlink_symbol(cl_object s);
ecl/external.h:extern ECL_API cl_object cl_eval(cl_object form);
ecl/external.h:extern ECL_API cl_object cl_constantp _ECL_ARGS((cl_narg narg, cl_object arg, ...));
ecl/external.h:extern ECL_API cl_object cl_apply_from_stack(cl_index narg, cl_object fun);
ecl/external.h:extern ECL_API cl_object ecl_apply_from_stack_frame(cl_object f, cl_object o);
ecl/external.h:extern ECL_API cl_objectfn ecl_function_dispatch(cl_env_ptr env, cl_object f);
ecl/external.h:extern ECL_API cl_object _ecl_link_call(cl_object sym, cl_objectfn *pLK, cl_object cblock, int narg, ecl_va_list args);
ecl/external.h:extern ECL_API cl_object si_get_cdata(cl_object filename);
ecl/external.h:extern ECL_API cl_object si_add_cdata(cl_object filename, cl_object cdata);
ecl/external.h:extern ECL_API cl_object ecl_make_codeblock();
ecl/external.h:extern ECL_API cl_object ecl_library_open(cl_object filename, bool force_reload);
ecl/external.h:extern ECL_API void *ecl_library_symbol(cl_object block, const char *symbol, bool lock);
ecl/external.h:extern ECL_API cl_object ecl_library_error(cl_object block);
ecl/external.h:extern ECL_API bool ecl_library_close(cl_object block);
ecl/external.h:extern ECL_API cl_object si_mmap _ECL_ARGS((cl_narg narg, cl_object filename, ...));
ecl/external.h:extern ECL_API cl_object si_munmap(cl_object map);
ecl/external.h:extern ECL_API cl_object si_mmap_array(cl_object map);
ecl/external.h:extern ECL_API cl_object si_dump_c_backtrace(cl_object size);
ecl/external.h:extern ECL_API cl_object si_allocate_foreign_data(cl_object tag, cl_object size);
ecl/external.h:extern ECL_API cl_object si_foreign_elt_type_p(cl_object f);
ecl/external.h:extern ECL_API cl_object si_foreign_data_p(cl_object f);
ecl/external.h:extern ECL_API cl_object si_foreign_data_address(cl_object f);
ecl/external.h:extern ECL_API cl_object si_foreign_data_equal(cl_object f1, cl_object f2);
ecl/external.h:extern ECL_API cl_object si_foreign_data_pointer(cl_object f, cl_object ndx, cl_object size, cl_object tag);
ecl/external.h:extern ECL_API cl_object si_foreign_data_ref(cl_object f, cl_object ndx, cl_object size, cl_object tag);
ecl/external.h:extern ECL_API cl_object si_foreign_data_ref_elt(cl_object f, cl_object ndx, cl_object tag);
ecl/external.h:extern ECL_API cl_object si_foreign_data_set(cl_object f, cl_object ndx, cl_object value);
ecl/external.h:extern ECL_API cl_object si_foreign_data_set_elt(cl_object f, cl_object ndx, cl_object tag, cl_object value);
ecl/external.h:extern ECL_API cl_object si_foreign_data_tag(cl_object x);
ecl/external.h:extern ECL_API cl_object si_foreign_data_recast(cl_object f, cl_object size, cl_object tag);
ecl/external.h:extern ECL_API cl_object si_free_foreign_data(cl_object x);
ecl/external.h:extern ECL_API cl_object si_make_foreign_data_from_array(cl_object x);
ecl/external.h:extern ECL_API cl_object si_null_pointer_p(cl_object f);
ecl/external.h:extern ECL_API cl_object si_size_of_foreign_elt_type(cl_object tag);
ecl/external.h:extern ECL_API cl_object si_alignment_of_foreign_elt_type(cl_object tag);
ecl/external.h:extern ECL_API cl_object si_load_foreign_module(cl_object module);
ecl/external.h:extern ECL_API cl_object si_unload_foreign_module(cl_object module);
ecl/external.h:extern ECL_API cl_object si_find_foreign_symbol(cl_object var, cl_object module, cl_object type, cl_object size);
ecl/external.h:extern ECL_API cl_object si_call_cfun(cl_narg, cl_object fun, cl_object return_type, cl_object arg_types, cl_object args, ...);
ecl/external.h:extern ECL_API cl_object si_make_dynamic_callback(cl_narg, cl_object fun, cl_object sym, cl_object return_type, cl_object arg_types, ...);
ecl/external.h:extern ECL_API cl_object si_free_ffi_closure(cl_object closure);
ecl/external.h:extern ECL_API cl_object ecl_make_foreign_data(cl_object tag, cl_index size, void *data);
ecl/external.h:extern ECL_API cl_object ecl_allocate_foreign_data(cl_object tag, cl_index size);
ecl/external.h:extern ECL_API void *ecl_foreign_data_pointer_safe(cl_object f);
ecl/external.h:extern ECL_API char *ecl_base_string_pointer_safe(cl_object f);
ecl/external.h:extern ECL_API cl_object ecl_null_terminated_base_string(cl_object s);
ecl/external.h:extern ECL_API cl_object ecl_foreign_data_ref_elt(void *p, enum ecl_ffi_tag type);
ecl/external.h:extern ECL_API void ecl_foreign_data_set_elt(void *p, enum ecl_ffi_tag type, cl_object value);
ecl/external.h:extern ECL_API cl_object cl_make_synonym_stream(cl_object sym);
ecl/external.h:extern ECL_API cl_object cl_synonym_stream_symbol(cl_object strm);
ecl/external.h:extern ECL_API cl_object cl_make_two_way_stream(cl_object strm1, cl_object strm2);
ecl/external.h:extern ECL_API cl_object cl_two_way_stream_input_stream(cl_object strm);
ecl/external.h:extern ECL_API cl_object cl_two_way_stream_output_stream(cl_object strm);
ecl/external.h:extern ECL_API cl_object cl_make_echo_stream(cl_object strm1, cl_object strm2);
ecl/external.h:extern ECL_API cl_object cl_echo_stream_input_stream(cl_object strm);
ecl/external.h:extern ECL_API cl_object cl_echo_stream_output_stream(cl_object strm);
ecl/external.h:extern ECL_API cl_object cl_make_string_output_stream _ECL_ARGS((cl_narg narg, ...));
ecl/external.h:extern ECL_API cl_object cl_get_output_stream_string(cl_object strm);
ecl/external.h:extern ECL_API cl_object cl_streamp(cl_object strm);
ecl/external.h:extern ECL_API cl_object cl_input_stream_p(cl_object strm);
ecl/external.h:extern ECL_API cl_object cl_output_stream_p(cl_object strm);
ecl/external.h:extern ECL_API cl_object cl_stream_element_type(cl_object strm);
ecl/external.h:extern ECL_API cl_object cl_stream_external_format(cl_object strm);
ecl/external.h:extern ECL_API cl_object cl_file_length(cl_object strm);
ecl/external.h:extern ECL_API cl_object si_get_string_input_stream_index(cl_object strm);
ecl/external.h:extern ECL_API cl_object si_make_string_output_stream_from_string(cl_object strng);
ecl/external.h:extern ECL_API cl_object si_copy_stream(cl_object in, cl_object out, cl_object wait);
ecl/external.h:extern ECL_API cl_object cl_open_stream_p(cl_object strm);
ecl/external.h:extern ECL_API cl_object cl_make_broadcast_stream _ECL_ARGS((cl_narg narg, ...));
ecl/external.h:extern ECL_API cl_object cl_broadcast_stream_streams(cl_object strm);
ecl/external.h:extern ECL_API cl_object cl_make_concatenated_stream _ECL_ARGS((cl_narg narg, ...));
ecl/external.h:extern ECL_API cl_object cl_concatenated_stream_streams(cl_object strm);
ecl/external.h:extern ECL_API cl_object cl_make_string_input_stream _ECL_ARGS((cl_narg narg, cl_object strng, ...));
ecl/external.h:extern ECL_API cl_object si_make_sequence_input_stream _ECL_ARGS((cl_narg narg, cl_object vector, ...));
ecl/external.h:extern ECL_API cl_object si_make_sequence_output_stream _ECL_ARGS((cl_narg narg, cl_object vector, ...));
ecl/external.h:extern ECL_API cl_object cl_close _ECL_ARGS((cl_narg narg, cl_object strm, ...));
ecl/external.h:extern ECL_API cl_object cl_open _ECL_ARGS((cl_narg narg, cl_object filename, ...));
ecl/external.h:extern ECL_API cl_object cl_file_position _ECL_ARGS((cl_narg narg, cl_object file_stream, ...));
ecl/external.h:extern ECL_API cl_object cl_file_string_length(cl_object stream, cl_object string);
ecl/external.h:extern ECL_API cl_object si_do_write_sequence(cl_object string, cl_object stream, cl_object start, cl_object end);
ecl/external.h:extern ECL_API cl_object si_do_read_sequence(cl_object string, cl_object stream, cl_object start, cl_object end);
ecl/external.h:extern ECL_API cl_object si_file_column(cl_object strm);
ecl/external.h:extern ECL_API cl_object cl_interactive_stream_p(cl_object strm);
ecl/external.h:extern ECL_API cl_object si_windows_codepage_encoding();
ecl/external.h:extern ECL_API cl_object si_set_buffering_mode(cl_object strm, cl_object mode);
ecl/external.h:extern ECL_API cl_object si_stream_external_format_set(cl_object strm, cl_object format);
ecl/external.h:extern ECL_API bool ecl_input_stream_p(cl_object strm);
ecl/external.h:extern ECL_API bool ecl_output_stream_p(cl_object strm);
ecl/external.h:extern ECL_API cl_object ecl_stream_element_type(cl_object strm);
ecl/external.h:extern ECL_API bool ecl_interactive_stream_p(cl_object strm);
ecl/external.h:extern ECL_API cl_object ecl_open_stream(cl_object fn, enum ecl_smmode smm, cl_object if_exists, cl_object if_does_not_exist, cl_fixnum byte_size, int flags, cl_object external_format);
ecl/external.h:extern ECL_API cl_object ecl_make_string_input_stream(cl_object strng, cl_index istart, cl_index iend);
ecl/external.h:extern ECL_API cl_object ecl_make_string_output_stream(cl_index line_length, int extended);
ecl/external.h:extern ECL_API cl_object ecl_read_byte(cl_object strm);
ecl/external.h:extern ECL_API void ecl_write_byte(cl_object byte, cl_object strm);
ecl/external.h:extern ECL_API ecl_character ecl_read_char_noeof(cl_object strm);
ecl/external.h:extern ECL_API ecl_character ecl_read_char(cl_object strm);
ecl/external.h:extern ECL_API void ecl_unread_char(ecl_character c, cl_object strm);
ecl/external.h:extern ECL_API ecl_character ecl_peek_char(cl_object strm);
ecl/external.h:extern ECL_API ecl_character ecl_write_char(ecl_character c, cl_object strm);
ecl/external.h:extern ECL_API void writestr_stream(const char *s, cl_object strm);
ecl/external.h:extern ECL_API void ecl_force_output(cl_object strm);
ecl/external.h:extern ECL_API void ecl_finish_output(cl_object strm);
ecl/external.h:extern ECL_API void ecl_clear_input(cl_object strm);
ecl/external.h:extern ECL_API void ecl_clear_output(cl_object strm);
ecl/external.h:extern ECL_API bool ecl_listen_stream(cl_object strm);
ecl/external.h:extern ECL_API cl_object ecl_file_position(cl_object strm);
ecl/external.h:extern ECL_API cl_object ecl_file_position_set(cl_object strm, cl_object disp);
ecl/external.h:extern ECL_API cl_object ecl_file_length(cl_object strm);
ecl/external.h:extern ECL_API int ecl_file_column(cl_object strm);
ecl/external.h:extern ECL_API cl_fixnum ecl_normalize_stream_element_type(cl_object element);
ecl/external.h:extern ECL_API cl_object ecl_make_stream_from_FILE(cl_object fname, void *fd, enum ecl_smmode smm, cl_fixnum byte_size, int flags, cl_object external_format);
ecl/external.h:extern ECL_API cl_object ecl_make_stream_from_fd(cl_object fname, int fd, enum ecl_smmode smm, cl_fixnum byte_size, int flags, cl_object external_format);
ecl/external.h:extern ECL_API cl_object si_file_stream_fd(cl_object s);
ecl/external.h:extern ECL_API int ecl_stream_to_handle(cl_object s, bool output);
ecl/external.h:extern ECL_API void ecl_set_finalizer_unprotected(cl_object o, cl_object finalizer);
ecl/external.h:extern ECL_API cl_object si_get_finalizer(cl_object o);
ecl/external.h:extern ECL_API cl_object si_set_finalizer(cl_object o, cl_object finalizer);
ecl/external.h:extern ECL_API cl_object cl_format _ECL_ARGS((cl_narg narg, cl_object stream, cl_object string, ...));
ecl/external.h:extern ECL_API cl_object si_room_report _ECL_ARGS((cl_narg narg, ...));
ecl/external.h:extern ECL_API cl_object si_reset_gc_count _ECL_ARGS((cl_narg narg, ...));
ecl/external.h:extern ECL_API cl_object si_gc_time _ECL_ARGS((cl_narg narg, ...));
ecl/external.h:extern ECL_API cl_object si_gc(cl_object area, ...);
ecl/external.h:extern ECL_API cl_object (*GC_enter_hook)(void);
ecl/external.h:extern ECL_API cl_object (*GC_exit_hook)(void);
ecl/external.h:extern ECL_API void ecl_register_root(cl_object *p);
ecl/external.h:extern ECL_API void ecl_register_root(cl_object *p);
ecl/external.h:extern ECL_API cl_object si_clear_gfun_hash(cl_object what);
ecl/external.h:extern ECL_API cl_object clos_set_funcallable_instance_function(cl_object x, cl_object function_or_t);
ecl/external.h:extern ECL_API cl_object si_generic_function_p(cl_object instance);
ecl/external.h:extern ECL_API cl_object _ecl_standard_dispatch(cl_object frame, cl_object fun);
ecl/external.h:extern ECL_API cl_object cl__make_hash_table(cl_object test, cl_object size, cl_object rehash_size, cl_object rehash_threshold);
ecl/external.h:extern ECL_API cl_object cl_hash_table_p(cl_object ht);
ecl/external.h:extern ECL_API cl_object si_hash_set(cl_object key, cl_object ht, cl_object val);
ecl/external.h:extern ECL_API cl_object cl_remhash(cl_object key, cl_object ht);
ecl/external.h:extern ECL_API cl_object cl_clrhash(cl_object ht);
ecl/external.h:extern ECL_API cl_object cl_hash_table_count(cl_object ht);
ecl/external.h:extern ECL_API cl_object cl_sxhash(cl_object key);
ecl/external.h:extern ECL_API cl_object cl_maphash(cl_object fun, cl_object ht);
ecl/external.h:extern ECL_API cl_object cl_hash_table_rehash_size(cl_object ht);
ecl/external.h:extern ECL_API cl_object cl_hash_table_rehash_threshold(cl_object ht);
ecl/external.h:extern ECL_API cl_object cl_hash_table_size(cl_object ht);
ecl/external.h:extern ECL_API cl_object cl_hash_table_test(cl_object ht);
ecl/external.h:extern ECL_API cl_object si_hash_table_iterator(cl_object ht);
ecl/external.h:extern ECL_API cl_object cl_make_hash_table _ECL_ARGS((cl_narg narg, ...));
ecl/external.h:extern ECL_API cl_object cl_gethash _ECL_ARGS((cl_narg narg, cl_object key, cl_object ht, ...));
ecl/external.h:extern ECL_API cl_object si_copy_hash_table(cl_object orig);
ecl/external.h:extern ECL_API cl_object si_hash_eql _ECL_ARGS((cl_narg narg, ...));
ecl/external.h:extern ECL_API cl_object si_hash_equal _ECL_ARGS((cl_narg narg, ...));
ecl/external.h:extern ECL_API cl_object si_hash_equalp _ECL_ARGS((cl_narg narg, ...));
ecl/external.h:extern ECL_API cl_object si_hash_table_content(cl_object ht);
ecl/external.h:extern ECL_API cl_object si_hash_table_fill(cl_object ht, cl_object values);
ecl/external.h:extern ECL_API cl_object si_hash_table_weakness(cl_object ht);
ecl/external.h:extern ECL_API cl_object si_hash_table_synchronized_p(cl_object ht);
ecl/external.h:extern ECL_API cl_object ecl_sethash(cl_object key, cl_object hashtable, cl_object value);
ecl/external.h:extern ECL_API cl_object ecl_gethash(cl_object key, cl_object hash);
ecl/external.h:extern ECL_API cl_object ecl_gethash_safe(cl_object key, cl_object hash, cl_object def);
ecl/external.h:extern ECL_API bool ecl_remhash(cl_object key, cl_object hash);
ecl/external.h:extern ECL_API cl_object _ecl_sethash(cl_object key, cl_object hashtable, cl_object value);
ecl/external.h:extern ECL_API cl_index ecl_hash_table_count(cl_object hash);
ecl/external.h:extern ECL_API cl_object si_allocate_raw_instance(cl_object orig, cl_object clas, cl_object size);
ecl/external.h:extern ECL_API cl_object si_instance_class(cl_object x);
ecl/external.h:extern ECL_API cl_object si_instance_class_set(cl_object x, cl_object y);
ecl/external.h:extern ECL_API cl_object si_instance_ref(cl_object x, cl_object index);
ecl/external.h:extern ECL_API cl_object clos_safe_instance_ref(cl_object x, cl_object index);
ecl/external.h:extern ECL_API cl_object si_instance_set(cl_object x, cl_object index, cl_object value);
ecl/external.h:extern ECL_API cl_object si_instancep(cl_object x);
ecl/external.h:extern ECL_API cl_object si_unbound(void);
ecl/external.h:extern ECL_API cl_object si_sl_boundp(cl_object x);
ecl/external.h:extern ECL_API cl_object si_sl_makunbound(cl_object x, cl_object index);
ecl/external.h:extern ECL_API cl_object si_instance_obsolete_p(cl_object x);
ecl/external.h:extern ECL_API cl_object si_instance_new_stamp(cl_object x);
ecl/external.h:extern ECL_API cl_object si_instance_get_stamp(cl_object x);
ecl/external.h:extern ECL_API cl_object si_instance_slotds(cl_object x);
ecl/external.h:extern ECL_API cl_object si_instance_sig_set(cl_object x);
ecl/external.h:extern ECL_API cl_object ecl_allocate_instance(cl_object clas, cl_index size);
ecl/external.h:extern ECL_API cl_object ecl_instance_ref(cl_object x, cl_fixnum i);
ecl/external.h:extern ECL_API cl_object ecl_instance_set(cl_object x, cl_fixnum i, cl_object v);
ecl/external.h:extern ECL_API cl_object si_copy_instance(cl_object x);
ecl/external.h:extern ECL_API cl_object ecl_slot_value(cl_object x, const char *slot);
ecl/external.h:extern ECL_API cl_object ecl_slot_value_set(cl_object x, const char *slot, cl_object y);
ecl/external.h:extern ECL_API cl_object ecl_compare_and_swap_instance(cl_object x, cl_fixnum i, cl_object old_val, cl_object new_val);
ecl/external.h:extern ECL_API cl_object mp_compare_and_swap_instance(cl_object x, cl_object index, cl_object old_val, cl_object new_val);
ecl/external.h:extern ECL_API cl_object ecl_atomic_incf_instance(cl_object x, cl_fixnum i, cl_object increment);
ecl/external.h:extern ECL_API cl_object mp_atomic_incf_instance(cl_object x, cl_object index, cl_object increment);
ecl/external.h:extern ECL_API cl_object cl_fifth(cl_object x);
ecl/external.h:extern ECL_API cl_object cl_sixth(cl_object x);
ecl/external.h:extern ECL_API cl_object cl_seventh(cl_object x);
ecl/external.h:extern ECL_API cl_object cl_eighth(cl_object x);
ecl/external.h:extern ECL_API cl_object cl_ninth(cl_object x);
ecl/external.h:extern ECL_API cl_object cl_tenth(cl_object x);
ecl/external.h:extern ECL_API cl_object cl_endp(cl_object x);
ecl/external.h:extern ECL_API cl_object cl_list_length(cl_object x);
ecl/external.h:extern ECL_API cl_object cl_nth(cl_object n, cl_object x);
ecl/external.h:extern ECL_API cl_object cl_nthcdr(cl_object n, cl_object x);
ecl/external.h:extern ECL_API cl_object cl_copy_list(cl_object x);
ecl/external.h:extern ECL_API cl_object cl_copy_alist(cl_object x);
ecl/external.h:extern ECL_API cl_object cl_copy_tree(cl_object x);
ecl/external.h:extern ECL_API cl_object cl_revappend(cl_object x, cl_object y);
ecl/external.h:extern ECL_API cl_object cl_ldiff(cl_object x, cl_object y);
ecl/external.h:extern ECL_API cl_object cl_rplaca(cl_object x, cl_object v);
ecl/external.h:extern ECL_API cl_object cl_rplacd(cl_object x, cl_object v);
ecl/external.h:extern ECL_API cl_object cl_tailp(cl_object y, cl_object x);
ecl/external.h:extern ECL_API cl_object si_memq(cl_object x, cl_object l);
ecl/external.h:extern ECL_API cl_object cl_nreconc(cl_object x, cl_object y);
ecl/external.h:extern ECL_API cl_object cl_cons(cl_object x, cl_object y);
ecl/external.h:extern ECL_API cl_object cl_acons(cl_object x, cl_object y, cl_object z);
ecl/external.h:extern ECL_API cl_object cl_list _ECL_ARGS((cl_narg narg, ...));
ecl/external.h:extern ECL_API cl_object cl_listX _ECL_ARGS((cl_narg narg, ...));
ecl/external.h:extern ECL_API cl_object cl_append _ECL_ARGS((cl_narg narg, ...));
ecl/external.h:extern ECL_API cl_object cl_tree_equal _ECL_ARGS((cl_narg narg, cl_object x, cl_object y, ...));
ecl/external.h:extern ECL_API cl_object cl_last _ECL_ARGS((cl_narg narg, cl_object x, ...));
ecl/external.h:extern ECL_API cl_object cl_make_list _ECL_ARGS((cl_narg narg, cl_object size, ...));
ecl/external.h:extern ECL_API cl_object cl_nconc _ECL_ARGS((cl_narg narg, ...));
ecl/external.h:extern ECL_API cl_object cl_butlast _ECL_ARGS((cl_narg narg, cl_object lis, ...));
ecl/external.h:extern ECL_API cl_object cl_nbutlast _ECL_ARGS((cl_narg narg, cl_object lis, ...));
ecl/external.h:extern ECL_API cl_object cl_subst _ECL_ARGS((cl_narg narg, cl_object new_obj, cl_object old_obj, cl_object tree, ...));
ecl/external.h:extern ECL_API cl_object cl_nsubst _ECL_ARGS((cl_narg narg, cl_object new_obj, cl_object old_obj, cl_object tree, ...));
ecl/external.h:extern ECL_API cl_object cl_sublis _ECL_ARGS((cl_narg narg, cl_object alist, cl_object tree, ...));
ecl/external.h:extern ECL_API cl_object cl_nsublis _ECL_ARGS((cl_narg narg, cl_object alist, cl_object tree, ...));
ecl/external.h:extern ECL_API cl_object cl_member _ECL_ARGS((cl_narg narg, cl_object item, cl_object list, ...));
ecl/external.h:extern ECL_API cl_object si_member1 (cl_object item, cl_object list, cl_object test, cl_object test_not, cl_object key);
ecl/external.h:extern ECL_API cl_object cl_adjoin _ECL_ARGS((cl_narg narg, cl_object item, cl_object list, ...));
ecl/external.h:extern ECL_API cl_object cl_pairlis _ECL_ARGS((cl_narg narg, cl_object keys, cl_object data, ...));
ecl/external.h:extern ECL_API cl_object cl_rassoc _ECL_ARGS((cl_narg narg, cl_object item, cl_object alist, ...));
ecl/external.h:extern ECL_API cl_object cl_assoc _ECL_ARGS((cl_narg narg, cl_object item, cl_object alist, ...));
ecl/external.h:extern ECL_API cl_object si_proper_list_p(cl_object V1);
ecl/external.h:extern ECL_API cl_object ecl_last(cl_object x, cl_index n);
ecl/external.h:extern ECL_API cl_object ecl_butlast(cl_object x, cl_index n);
ecl/external.h:extern ECL_API cl_object ecl_nbutlast(cl_object x, cl_index n);
ecl/external.h:extern ECL_API cl_object ecl_append(cl_object x, cl_object y);
ecl/external.h:extern ECL_API bool ecl_endp(cl_object x);
ecl/external.h:extern ECL_API cl_object ecl_nth(cl_fixnum n, cl_object x);
ecl/external.h:extern ECL_API cl_object ecl_nthcdr(cl_fixnum n, cl_object x);
ecl/external.h:extern ECL_API cl_object ecl_nconc(cl_object x, cl_object y);
ecl/external.h:extern ECL_API bool ecl_member_eq(cl_object x, cl_object l);
ecl/external.h:extern ECL_API cl_object ecl_memql(cl_object x, cl_object l);
ecl/external.h:extern ECL_API cl_object ecl_member(cl_object x, cl_object l);
ecl/external.h:extern ECL_API cl_object ecl_assq(cl_object x, cl_object l);
ecl/external.h:extern ECL_API cl_object ecl_assql(cl_object x, cl_object l);
ecl/external.h:extern ECL_API cl_object ecl_assoc(cl_object x, cl_object l);
ecl/external.h:extern ECL_API cl_object ecl_assqlp(cl_object x, cl_object l);
ecl/external.h:extern ECL_API cl_object ecl_remove_eq(cl_object x, cl_object l);
ecl/external.h:extern ECL_API cl_object ecl_delete_eq(cl_object x, cl_object l);
ecl/external.h:extern ECL_API cl_object mp_compare_and_swap_car(cl_object x, cl_object old_val, cl_object new_val);
ecl/external.h:extern ECL_API cl_object mp_atomic_incf_car(cl_object x, cl_object increment);
ecl/external.h:extern ECL_API cl_object mp_compare_and_swap_cdr(cl_object x, cl_object old_val, cl_object new_val);
ecl/external.h:extern ECL_API cl_object mp_atomic_incf_cdr(cl_object x, cl_object increment);
ecl/external.h:extern ECL_API cl_object si_load_bytecodes(cl_object file, cl_object verbose, cl_object print, cl_object format);
ecl/external.h:extern ECL_API cl_object si_load_source(cl_object file, cl_object verbose, cl_object print, cl_object format);
ecl/external.h:extern ECL_API cl_object si_load_binary(cl_object file, cl_object verbose, cl_object print, cl_object format);
ecl/external.h:extern ECL_API cl_object cl_load _ECL_ARGS((cl_narg narg, cl_object pathname, ...));
ecl/external.h:extern ECL_API cl_object cl_macroexpand _ECL_ARGS((cl_narg narg, cl_object form, ...));
ecl/external.h:extern ECL_API cl_object cl_macroexpand_1 _ECL_ARGS((cl_narg narg, cl_object form, ...));
ecl/external.h:extern ECL_API cl_object cl_macro_function _ECL_ARGS((cl_narg narg, cl_object sym, ...));
ecl/external.h:extern ECL_API cl_object si_argc(void);
ecl/external.h:extern ECL_API cl_object si_argv(cl_object index);
ecl/external.h:extern ECL_API cl_object si_getenv(cl_object var);
ecl/external.h:extern ECL_API cl_object si_setenv(cl_object var, cl_object value);
ecl/external.h:extern ECL_API cl_object si_environ(void);
ecl/external.h:extern ECL_API cl_object si_pointer(cl_object x);
ecl/external.h:extern ECL_API cl_object si_quit _ECL_ARGS((cl_narg narg, ...)) /*ecl_attr_noreturn*/;
ecl/external.h:extern ECL_API cl_object si_exit _ECL_ARGS((cl_narg narg, ...)) ecl_attr_noreturn;
ecl/external.h:extern ECL_API cl_object cl_mapcar _ECL_ARGS((cl_narg narg, cl_object fun, ...));
ecl/external.h:extern ECL_API cl_object cl_maplist _ECL_ARGS((cl_narg narg, cl_object fun, ...));
ecl/external.h:extern ECL_API cl_object cl_mapc _ECL_ARGS((cl_narg narg, cl_object fun, ...));
ecl/external.h:extern ECL_API cl_object cl_mapl _ECL_ARGS((cl_narg narg, cl_object fun, ...));
ecl/external.h:extern ECL_API cl_object cl_mapcan _ECL_ARGS((cl_narg narg, cl_object fun, ...));
ecl/external.h:extern ECL_API cl_object cl_mapcon _ECL_ARGS((cl_narg narg, cl_object fun, ...));
ecl/external.h:extern ECL_API cl_object cl_values_list(cl_object list);
ecl/external.h:extern ECL_API cl_object cl_values _ECL_ARGS((cl_narg narg, ...));
ecl/external.h:extern ECL_API cl_object cl_conjugate(cl_object c);
ecl/external.h:extern ECL_API cl_object cl_1P(cl_object x);
ecl/external.h:extern ECL_API cl_object cl_1M(cl_object x);
ecl/external.h:extern ECL_API cl_object cl_X _ECL_ARGS((cl_narg narg, ...));
ecl/external.h:extern ECL_API cl_object cl_P _ECL_ARGS((cl_narg narg, ...));
ecl/external.h:extern ECL_API cl_object cl_M _ECL_ARGS((cl_narg narg, cl_object num, ...));
ecl/external.h:extern ECL_API cl_object cl_N _ECL_ARGS((cl_narg narg, cl_object num, ...));
ecl/external.h:extern ECL_API cl_object cl_gcd _ECL_ARGS((cl_narg narg, ...));
ecl/external.h:extern ECL_API cl_object cl_lcm _ECL_ARGS((cl_narg narg, ...));
ecl/external.h:extern ECL_API cl_object ecl_times(cl_object x, cl_object y);
ecl/external.h:extern ECL_API cl_object number_to_complex(cl_object x);
ecl/external.h:extern ECL_API cl_object ecl_plus(cl_object x, cl_object y);
ecl/external.h:extern ECL_API cl_object ecl_minus(cl_object x, cl_object y);
ecl/external.h:extern ECL_API cl_object ecl_negate(cl_object x);
ecl/external.h:extern ECL_API cl_object ecl_divide(cl_object x, cl_object y);
ecl/external.h:extern ECL_API cl_object ecl_integer_divide(cl_object x, cl_object y);
ecl/external.h:extern ECL_API cl_object ecl_gcd(cl_object x, cl_object y);
ecl/external.h:extern ECL_API cl_object ecl_one_plus(cl_object x);
ecl/external.h:extern ECL_API cl_object ecl_one_minus(cl_object x);
ecl/external.h:extern ECL_API cl_object ecl_conjugate(cl_object x);
ecl/external.h:extern ECL_API cl_fixnum fixint(cl_object x);
ecl/external.h:extern ECL_API cl_index  fixnnint(cl_object x);
ecl/external.h:extern ECL_API cl_object ecl_make_integer(cl_fixnum i);
ecl/external.h:extern ECL_API cl_object ecl_make_unsigned_integer(cl_index i);
ecl/external.h:extern ECL_API int ecl_to_bit(cl_object o);
ecl/external.h:extern ECL_API ecl_uint8_t ecl_to_uint8_t(cl_object o);
ecl/external.h:extern ECL_API ecl_int8_t ecl_to_int8_t(cl_object o);
ecl/external.h:extern ECL_API ecl_uint16_t ecl_to_uint16_t(cl_object o);
ecl/external.h:extern ECL_API ecl_int16_t ecl_to_int16_t(cl_object o);
ecl/external.h:extern ECL_API unsigned short ecl_to_ushort(cl_object o);
ecl/external.h:extern ECL_API short ecl_to_short(cl_object o);
ecl/external.h:extern ECL_API ecl_uint32_t ecl_to_uint32_t(cl_object o);
ecl/external.h:extern ECL_API ecl_int32_t ecl_to_int32_t(cl_object o);
ecl/external.h:extern ECL_API ecl_uint64_t ecl_to_uint64_t(cl_object p);
ecl/external.h:extern ECL_API ecl_int64_t ecl_to_int64_t(cl_object p);
ecl/external.h:extern ECL_API cl_object ecl_make_uint64_t(ecl_uint64_t i);
ecl/external.h:extern ECL_API cl_object ecl_make_int64_t(ecl_int64_t i);
ecl/external.h:extern ECL_API ecl_ulong_long_t ecl_to_ulong_long(cl_object p);
ecl/external.h:extern ECL_API ecl_long_long_t ecl_to_long_long(cl_object p);
ecl/external.h:extern ECL_API cl_object ecl_make_ulong_long(ecl_ulong_long_t i);
ecl/external.h:extern ECL_API cl_object ecl_make_long_long(ecl_long_long_t i);
ecl/external.h:extern ECL_API cl_object ecl_make_ratio(cl_object num, cl_object den);
ecl/external.h:extern ECL_API cl_object ecl_make_single_float(float f);
ecl/external.h:extern ECL_API cl_object ecl_make_double_float(double f);
ecl/external.h:extern ECL_API cl_object ecl_make_complex(cl_object r, cl_object i);
ecl/external.h:extern ECL_API cl_object cl_rational(cl_object x);
ecl/external.h:extern ECL_API float ecl_to_float(cl_object x);
ecl/external.h:extern ECL_API double ecl_to_double(cl_object x);
ecl/external.h:extern ECL_API long double ecl_to_long_double(cl_object x);
ecl/external.h:extern ECL_API cl_object ecl_make_long_float(long double f);
ecl/external.h:extern ECL_API cl_object   ecl_make_csfloat(float _Complex x);
ecl/external.h:extern ECL_API cl_object   ecl_make_cdfloat(double _Complex x);
ecl/external.h:extern ECL_API cl_object   ecl_make_clfloat(long double _Complex x);
ecl/external.h:extern ECL_API cl_object   si_complex_float_p(cl_object o);
ecl/external.h:extern ECL_API cl_object   si_complex_float(cl_object r, cl_object i);
ecl/external.h:extern ECL_API float       _Complex ecl_to_csfloat(cl_object x);
ecl/external.h:extern ECL_API double      _Complex ecl_to_cdfloat(cl_object x);
ecl/external.h:extern ECL_API long double _Complex ecl_to_clfloat(cl_object x);
ecl/external.h:extern ECL_API cl_object si_nan();
ecl/external.h:extern ECL_API cl_object cl_numerator(cl_object x);
ecl/external.h:extern ECL_API cl_object cl_denominator(cl_object x);
ecl/external.h:extern ECL_API cl_object cl_mod(cl_object x, cl_object y);
ecl/external.h:extern ECL_API cl_object cl_rem(cl_object x, cl_object y);
ecl/external.h:extern ECL_API cl_object cl_decode_float(cl_object x);
ecl/external.h:extern ECL_API cl_object cl_scale_float(cl_object x, cl_object y);
ecl/external.h:extern ECL_API cl_object cl_float_radix(cl_object x);
ecl/external.h:extern ECL_API cl_object cl_float_digits(cl_object x);
ecl/external.h:extern ECL_API cl_object cl_float_precision(cl_object x);
ecl/external.h:extern ECL_API cl_object cl_integer_decode_float(cl_object x);
ecl/external.h:extern ECL_API cl_object cl_realpart(cl_object x);
ecl/external.h:extern ECL_API cl_object cl_imagpart(cl_object x);
ecl/external.h:extern ECL_API cl_object cl_float _ECL_ARGS((cl_narg narg, cl_object x, ...));
ecl/external.h:extern ECL_API cl_object cl_floor _ECL_ARGS((cl_narg narg, cl_object x, ...));
ecl/external.h:extern ECL_API cl_object cl_ceiling _ECL_ARGS((cl_narg narg, cl_object x, ...));
ecl/external.h:extern ECL_API cl_object cl_truncate _ECL_ARGS((cl_narg narg, cl_object x, ...));
ecl/external.h:extern ECL_API cl_object cl_round _ECL_ARGS((cl_narg narg, cl_object x, ...));
ecl/external.h:extern ECL_API cl_object cl_float_sign _ECL_ARGS((cl_narg narg, cl_object x, ...));
ecl/external.h:extern ECL_API cl_object cl_complex _ECL_ARGS((cl_narg narg, cl_object r, ...));
ecl/external.h:extern ECL_API cl_object ecl_floor1(cl_object x);
ecl/external.h:extern ECL_API cl_object ecl_ceiling1(cl_object x);
ecl/external.h:extern ECL_API cl_object ecl_truncate1(cl_object x);
ecl/external.h:extern ECL_API cl_object ecl_round1(cl_object x);
ecl/external.h:extern ECL_API int ecl_signbit(cl_object x);
ecl/external.h:extern ECL_API cl_object ecl_floor2(cl_object x, cl_object y);
ecl/external.h:extern ECL_API cl_object ecl_ceiling2(cl_object x, cl_object y);
ecl/external.h:extern ECL_API cl_object ecl_truncate2(cl_object x, cl_object y);
ecl/external.h:extern ECL_API cl_object ecl_round2(cl_object x, cl_object y);
ecl/external.h:extern ECL_API cl_object cl_E _ECL_ARGS((cl_narg narg, cl_object num, ...));
ecl/external.h:extern ECL_API cl_object cl_NE _ECL_ARGS((cl_narg narg, ...));
ecl/external.h:extern ECL_API cl_object cl_L _ECL_ARGS((cl_narg narg, ...));
ecl/external.h:extern ECL_API cl_object cl_G _ECL_ARGS((cl_narg narg, ...));
ecl/external.h:extern ECL_API cl_object cl_GE _ECL_ARGS((cl_narg narg, ...));
ecl/external.h:extern ECL_API cl_object cl_LE _ECL_ARGS((cl_narg narg, ...));
ecl/external.h:extern ECL_API cl_object cl_max _ECL_ARGS((cl_narg narg, cl_object max, ...));
ecl/external.h:extern ECL_API cl_object cl_min _ECL_ARGS((cl_narg narg, cl_object min, ...));
ecl/external.h:extern ECL_API int ecl_number_equalp(cl_object x, cl_object y);
ecl/external.h:extern ECL_API int ecl_number_compare(cl_object x, cl_object y);
ecl/external.h:extern ECL_API cl_object cl_lognand(cl_object x, cl_object y);
ecl/external.h:extern ECL_API cl_object cl_lognor(cl_object x, cl_object y);
ecl/external.h:extern ECL_API cl_object cl_logandc1(cl_object x, cl_object y);
ecl/external.h:extern ECL_API cl_object cl_logandc2(cl_object x, cl_object y);
ecl/external.h:extern ECL_API cl_object cl_logorc1(cl_object x, cl_object y);
ecl/external.h:extern ECL_API cl_object cl_logorc2(cl_object x, cl_object y);
ecl/external.h:extern ECL_API cl_object cl_lognot(cl_object x);
ecl/external.h:extern ECL_API cl_object cl_boole(cl_object o, cl_object x, cl_object y);
ecl/external.h:extern ECL_API cl_object cl_logbitp(cl_object p, cl_object x);
ecl/external.h:extern ECL_API cl_object cl_ash(cl_object x, cl_object y);
ecl/external.h:extern ECL_API cl_object cl_logcount(cl_object x);
ecl/external.h:extern ECL_API cl_object cl_integer_length(cl_object x);
ecl/external.h:extern ECL_API cl_object si_bit_array_op(cl_object o, cl_object x, cl_object y, cl_object r);
ecl/external.h:extern ECL_API cl_object cl_logior _ECL_ARGS((cl_narg narg, ...));
ecl/external.h:extern ECL_API cl_object cl_logxor _ECL_ARGS((cl_narg narg, ...));
ecl/external.h:extern ECL_API cl_object cl_logand _ECL_ARGS((cl_narg narg, ...));
ecl/external.h:extern ECL_API cl_object cl_logeqv _ECL_ARGS((cl_narg narg, ...));
ecl/external.h:extern ECL_API cl_fixnum ecl_logand_index(cl_object n, cl_index i);
ecl/external.h:extern ECL_API cl_object ecl_boole(int op, cl_object x, cl_object y);
ecl/external.h:extern ECL_API cl_object ecl_ash(cl_object x, cl_fixnum w);
ecl/external.h:extern ECL_API cl_index ecl_integer_length(cl_object i);
ecl/external.h:extern ECL_API cl_object cl_zerop(cl_object x);
ecl/external.h:extern ECL_API cl_object cl_plusp(cl_object x);
ecl/external.h:extern ECL_API cl_object cl_minusp(cl_object x);
ecl/external.h:extern ECL_API cl_object cl_oddp(cl_object x);
ecl/external.h:extern ECL_API cl_object cl_evenp(cl_object x);
ecl/external.h:extern ECL_API cl_object si_float_nan_p(cl_object x);
ecl/external.h:extern ECL_API cl_object si_float_infinity_p(cl_object x);
ecl/external.h:extern ECL_API int ecl_zerop(cl_object x);
ecl/external.h:extern ECL_API int ecl_plusp(cl_object x);
ecl/external.h:extern ECL_API int ecl_minusp(cl_object x);
ecl/external.h:extern ECL_API int ecl_oddp(cl_object x);
ecl/external.h:extern ECL_API int ecl_evenp(cl_object x);
ecl/external.h:extern ECL_API bool ecl_float_nan_p(cl_object x);
ecl/external.h:extern ECL_API bool ecl_float_infinity_p(cl_object x);
ecl/external.h:extern ECL_API cl_object cl_random_state_p(cl_object x);
ecl/external.h:extern ECL_API cl_object cl_random _ECL_ARGS((cl_narg narg, cl_object x, ...));
ecl/external.h:extern ECL_API cl_object cl_make_random_state _ECL_ARGS((cl_narg narg, ...));
ecl/external.h:extern ECL_API cl_object ecl_make_random_state(cl_object rs);
ecl/external.h:extern ECL_API cl_object si_random_state_array(cl_object rs);
ecl/external.h:extern ECL_API cl_object cl_abs(cl_object x);
ecl/external.h:extern ECL_API cl_object cl_exp(cl_object x);
ecl/external.h:extern ECL_API cl_object cl_expt(cl_object x, cl_object y);
ecl/external.h:extern ECL_API cl_object cl_sqrt(cl_object x);
ecl/external.h:extern ECL_API cl_object cl_sin(cl_object x);
ecl/external.h:extern ECL_API cl_object cl_cos(cl_object x);
ecl/external.h:extern ECL_API cl_object cl_tan(cl_object x);
ecl/external.h:extern ECL_API cl_object cl_sinh(cl_object x);
ecl/external.h:extern ECL_API cl_object cl_cosh(cl_object x);
ecl/external.h:extern ECL_API cl_object cl_tanh(cl_object x);
ecl/external.h:extern ECL_API cl_object cl_atan _ECL_ARGS((cl_narg narg, cl_object x, ...));
ecl/external.h:extern ECL_API cl_object cl_log _ECL_ARGS((cl_narg narg, cl_object x, ...));
ecl/external.h:extern ECL_API cl_object si_log1p(cl_object x);
ecl/external.h:extern ECL_API cl_object ecl_log1p(cl_object x);
ecl/external.h:extern ECL_API cl_object ecl_log1(cl_object x);
ecl/external.h:extern ECL_API cl_object ecl_log2(cl_object x, cl_object y);
ecl/external.h:extern ECL_API cl_object ecl_atan2(cl_object y, cl_object x);
ecl/external.h:extern ECL_API cl_object ecl_atan1(cl_object y);
ecl/external.h:extern ECL_API cl_object ecl_abs(cl_object x);
ecl/external.h:extern ECL_API cl_object ecl_exp(cl_object x);
ecl/external.h:extern ECL_API cl_object ecl_expt(cl_object x, cl_object y);
ecl/external.h:extern ECL_API cl_object ecl_sqrt(cl_object x);
ecl/external.h:extern ECL_API cl_object ecl_sin(cl_object x);
ecl/external.h:extern ECL_API cl_object ecl_cos(cl_object x);
ecl/external.h:extern ECL_API cl_object ecl_tan(cl_object x);
ecl/external.h:extern ECL_API cl_object ecl_sinh(cl_object x);
ecl/external.h:extern ECL_API cl_object ecl_cosh(cl_object x);
ecl/external.h:extern ECL_API cl_object ecl_tanh(cl_object x);
ecl/external.h:extern ECL_API void CEpackage_error(const char *message, const char *continue_message, cl_object package, int narg, ...);
ecl/external.h:extern ECL_API cl_object si_select_package(cl_object pack_name);
ecl/external.h:extern ECL_API cl_object cl_find_package(cl_object p);
ecl/external.h:extern ECL_API cl_object cl_package_name(cl_object p);
ecl/external.h:extern ECL_API cl_object cl_package_nicknames(cl_object p);
ecl/external.h:extern ECL_API cl_object cl_package_use_list(cl_object p);
ecl/external.h:extern ECL_API cl_object cl_package_used_by_list(cl_object p);
ecl/external.h:extern ECL_API cl_object cl_package_shadowing_symbols(cl_object p);
ecl/external.h:extern ECL_API cl_object si_package_local_nicknames(cl_object p);
ecl/external.h:extern ECL_API cl_object si_package_locally_nicknamed_by_list(cl_object p);
ecl/external.h:extern ECL_API cl_object si_add_package_local_nickname(cl_object n, cl_object p1, cl_object p2);
ecl/external.h:extern ECL_API cl_object si_remove_package_local_nickname(cl_object n, cl_object p);
ecl/external.h:extern ECL_API cl_object cl_list_all_packages(void);
ecl/external.h:extern ECL_API cl_object si_package_hash_tables(cl_object p);
ecl/external.h:extern ECL_API cl_object si_package_lock(cl_object p, cl_object t);
ecl/external.h:extern ECL_API cl_object si_package_locked_p(cl_object p);
ecl/external.h:extern ECL_API cl_object cl_delete_package(cl_object p);
ecl/external.h:extern ECL_API cl_object cl_make_package _ECL_ARGS((cl_narg narg, cl_object pack_name, ...));
ecl/external.h:extern ECL_API cl_object cl_intern _ECL_ARGS((cl_narg narg, cl_object strng, ...));
ecl/external.h:extern ECL_API cl_object cl_find_symbol _ECL_ARGS((cl_narg narg, cl_object strng, ...));
ecl/external.h:extern ECL_API cl_object cl_unintern _ECL_ARGS((cl_narg narg, cl_object symbl, ...));
ecl/external.h:extern ECL_API cl_object cl_export _ECL_ARGS((cl_narg narg, cl_object symbols, ...));
ecl/external.h:extern ECL_API cl_object cl_unexport _ECL_ARGS((cl_narg narg, cl_object symbols, ...));
ecl/external.h:extern ECL_API cl_object cl_import _ECL_ARGS((cl_narg narg, cl_object symbols, ...));
ecl/external.h:extern ECL_API cl_object cl_rename_package _ECL_ARGS((cl_narg narg, cl_object pack, cl_object new_name, ...));
ecl/external.h:extern ECL_API cl_object cl_shadowing_import _ECL_ARGS((cl_narg narg, cl_object symbols, ...));
ecl/external.h:extern ECL_API cl_object cl_shadow _ECL_ARGS((cl_narg narg, cl_object symbols, ...));
ecl/external.h:extern ECL_API cl_object cl_use_package _ECL_ARGS((cl_narg narg, cl_object pack, ...));
ecl/external.h:extern ECL_API cl_object cl_unuse_package _ECL_ARGS((cl_narg narg, cl_object pack, ...));
ecl/external.h:extern ECL_API cl_object ecl_make_package(cl_object n, cl_object ns, cl_object ul, cl_object lns);
ecl/external.h:extern ECL_API cl_object ecl_rename_package(cl_object x, cl_object n, cl_object ns);
ecl/external.h:extern ECL_API cl_object ecl_find_package_nolock(cl_object n);
ecl/external.h:extern ECL_API cl_object ecl_find_package(const char *p);
ecl/external.h:extern ECL_API cl_object si_coerce_to_package(cl_object p);
ecl/external.h:extern ECL_API cl_object ecl_current_package(void);
ecl/external.h:extern ECL_API cl_object ecl_find_symbol(cl_object n, cl_object p, int *intern_flag);
ecl/external.h:extern ECL_API cl_object ecl_intern(cl_object name, cl_object p, int *intern_flag);
ecl/external.h:extern ECL_API cl_object _ecl_intern(const char *s, cl_object p);
ecl/external.h:extern ECL_API bool ecl_unintern(cl_object s, cl_object p);
ecl/external.h:extern ECL_API void cl_export2(cl_object s, cl_object p);
ecl/external.h:extern ECL_API void cl_unexport2(cl_object s, cl_object p);
ecl/external.h:extern ECL_API void cl_import2(cl_object s, cl_object p);
ecl/external.h:extern ECL_API void ecl_shadowing_import(cl_object s, cl_object p);
ecl/external.h:extern ECL_API void ecl_shadow(cl_object s, cl_object p);
ecl/external.h:extern ECL_API void ecl_use_package(cl_object x0, cl_object p);
ecl/external.h:extern ECL_API void ecl_unuse_package(cl_object x0, cl_object p);
ecl/external.h:extern ECL_API bool ecl_string_match(cl_object s, cl_index j, cl_index ls, cl_object p, cl_index i, cl_index lp);
ecl/external.h:extern ECL_API cl_object cl_pathname(cl_object name);
ecl/external.h:extern ECL_API cl_object cl_logical_pathname(cl_object pname);
ecl/external.h:extern ECL_API cl_object cl_pathnamep(cl_object pname);
ecl/external.h:extern ECL_API cl_object cl_pathname_host _ECL_ARGS((cl_narg narg, cl_object pname, ...));
ecl/external.h:extern ECL_API cl_object cl_pathname_device _ECL_ARGS((cl_narg narg, cl_object pname, ...));
ecl/external.h:extern ECL_API cl_object cl_pathname_directory _ECL_ARGS((cl_narg narg, cl_object pname, ...));
ecl/external.h:extern ECL_API cl_object cl_pathname_name _ECL_ARGS((cl_narg narg, cl_object pname, ...));
ecl/external.h:extern ECL_API cl_object cl_pathname_type _ECL_ARGS((cl_narg narg, cl_object pname, ...));
ecl/external.h:extern ECL_API cl_object cl_pathname_version(cl_object pname);
ecl/external.h:extern ECL_API cl_object cl_namestring(cl_object pname);
ecl/external.h:extern ECL_API cl_object cl_file_namestring(cl_object pname);
ecl/external.h:extern ECL_API cl_object cl_directory_namestring(cl_object pname);
ecl/external.h:extern ECL_API cl_object cl_host_namestring(cl_object pname);
ecl/external.h:extern ECL_API cl_object si_logical_pathname_p(cl_object pname);
ecl/external.h:extern ECL_API cl_object cl_pathname_match_p(cl_object path, cl_object mask);
ecl/external.h:extern ECL_API cl_object cl_translate_pathname _ECL_ARGS((cl_narg narg, cl_object source, cl_object from, cl_object to, ...));
ecl/external.h:extern ECL_API cl_object cl_translate_logical_pathname _ECL_ARGS((cl_narg narg, cl_object source, ...));
ecl/external.h:extern ECL_API cl_object cl_parse_namestring _ECL_ARGS((cl_narg narg, cl_object thing, ...));
ecl/external.h:extern ECL_API cl_object cl_parse_logical_namestring _ECL_ARGS((cl_narg narg, cl_object thing, ...));
ecl/external.h:extern ECL_API cl_object cl_merge_pathnames _ECL_ARGS((cl_narg narg, cl_object path, ...));
ecl/external.h:extern ECL_API cl_object cl_make_pathname _ECL_ARGS((cl_narg narg, ...));
ecl/external.h:extern ECL_API cl_object cl_enough_namestring _ECL_ARGS((cl_narg narg, cl_object path, ...));
ecl/external.h:extern ECL_API cl_object si_pathname_translations _ECL_ARGS((cl_narg narg, cl_object host, ...));
ecl/external.h:extern ECL_API cl_object si_default_pathname_defaults(void);
ecl/external.h:extern ECL_API cl_object cl_wild_pathname_p _ECL_ARGS((cl_narg narg, cl_object pathname, ...));
ecl/external.h:extern ECL_API cl_object ecl_make_pathname(cl_object host, cl_object device, cl_object directory, cl_object name, cl_object type, cl_object version, cl_object scase);
ecl/external.h:extern ECL_API cl_object ecl_parse_namestring(cl_object s, cl_index start, cl_index end, cl_index *ep, cl_object default_host);
ecl/external.h:extern ECL_API cl_object coerce_to_physical_pathname(cl_object x);
ecl/external.h:extern ECL_API cl_object coerce_to_file_pathname(cl_object pathname);
ecl/external.h:extern ECL_API cl_object ecl_namestring(cl_object pname, int truncate_if_impossible);
ecl/external.h:extern ECL_API cl_object si_coerce_to_filename(cl_object pathname);
ecl/external.h:extern ECL_API cl_object ecl_merge_pathnames(cl_object path, cl_object defaults, cl_object default_version);
ecl/external.h:extern ECL_API bool ecl_logical_hostname_p(cl_object host);
ecl/external.h:extern ECL_API cl_object cl_identity(cl_object x);
ecl/external.h:extern ECL_API cl_object cl_null(cl_object x);
ecl/external.h:extern ECL_API cl_object cl_symbolp(cl_object x);
ecl/external.h:extern ECL_API cl_object cl_atom(cl_object x);
ecl/external.h:extern ECL_API cl_object cl_consp(cl_object x);
ecl/external.h:extern ECL_API cl_object cl_listp(cl_object x);
ecl/external.h:extern ECL_API cl_object cl_numberp(cl_object x);
ecl/external.h:extern ECL_API cl_object cl_integerp(cl_object x);
ecl/external.h:extern ECL_API cl_object cl_rationalp(cl_object x);
ecl/external.h:extern ECL_API cl_object cl_floatp(cl_object x);
ecl/external.h:extern ECL_API cl_object cl_realp(cl_object x);
ecl/external.h:extern ECL_API cl_object cl_complexp(cl_object x);
ecl/external.h:extern ECL_API cl_object cl_characterp(cl_object x);
ecl/external.h:extern ECL_API cl_object cl_stringp(cl_object x);
ecl/external.h:extern ECL_API cl_object cl_bit_vector_p(cl_object x);
ecl/external.h:extern ECL_API cl_object cl_vectorp(cl_object x);
ecl/external.h:extern ECL_API cl_object cl_simple_string_p(cl_object x);
ecl/external.h:extern ECL_API cl_object cl_simple_bit_vector_p(cl_object x);
ecl/external.h:extern ECL_API cl_object cl_simple_vector_p(cl_object x);
ecl/external.h:extern ECL_API cl_object cl_arrayp(cl_object x);
ecl/external.h:extern ECL_API cl_object cl_packagep(cl_object x);
ecl/external.h:extern ECL_API cl_object cl_functionp(cl_object x);
ecl/external.h:extern ECL_API cl_object cl_compiled_function_p(cl_object x);
ecl/external.h:extern ECL_API cl_object cl_eq(cl_object x, cl_object y);
ecl/external.h:extern ECL_API cl_object cl_eql(cl_object x, cl_object y);
ecl/external.h:extern ECL_API cl_object cl_equal(cl_object x, cl_object y);
ecl/external.h:extern ECL_API cl_object cl_equalp(cl_object x, cl_object y);
ecl/external.h:extern ECL_API cl_object si_fixnump(cl_object x);
ecl/external.h:extern ECL_API bool floatp(cl_object x);
ecl/external.h:extern ECL_API bool ecl_numberp(cl_object x);
ecl/external.h:extern ECL_API bool ecl_realp(cl_object x);
ecl/external.h:extern ECL_API bool ecl_eql(cl_object x, cl_object y);
ecl/external.h:extern ECL_API bool ecl_equal(register cl_object x, cl_object y);
ecl/external.h:extern ECL_API bool ecl_equalp(cl_object x, cl_object y);
ecl/external.h:extern ECL_API bool ecl_stringp(cl_object x);
ecl/external.h:extern ECL_API cl_object cl_write_byte(cl_object integer, cl_object binary_output_stream);
ecl/external.h:extern ECL_API cl_object cl_write_sequence _ECL_ARGS((cl_narg narg, cl_object seq, cl_object stream, ...));
ecl/external.h:extern ECL_API cl_object cl_write _ECL_ARGS((cl_narg narg, cl_object x, ...));
ecl/external.h:extern ECL_API cl_object cl_prin1 _ECL_ARGS((cl_narg narg, cl_object obj, ...));
ecl/external.h:extern ECL_API cl_object cl_print _ECL_ARGS((cl_narg narg, cl_object obj, ...));
ecl/external.h:extern ECL_API cl_object cl_pprint _ECL_ARGS((cl_narg narg, cl_object obj, ...));
ecl/external.h:extern ECL_API cl_object cl_princ _ECL_ARGS((cl_narg narg, cl_object obj, ...));
ecl/external.h:extern ECL_API cl_object cl_write_char _ECL_ARGS((cl_narg narg, cl_object c, ...));
ecl/external.h:extern ECL_API cl_object cl_write_string _ECL_ARGS((cl_narg narg, cl_object strng, ...));
ecl/external.h:extern ECL_API cl_object cl_write_line _ECL_ARGS((cl_narg narg, cl_object strng, ...));
ecl/external.h:extern ECL_API cl_object cl_terpri _ECL_ARGS((cl_narg narg, ...));
ecl/external.h:extern ECL_API cl_object cl_finish_output _ECL_ARGS((cl_narg narg, ...));
ecl/external.h:extern ECL_API cl_object cl_fresh_line _ECL_ARGS((cl_narg narg, ...));
ecl/external.h:extern ECL_API cl_object cl_force_output _ECL_ARGS((cl_narg narg, ...));
ecl/external.h:extern ECL_API cl_object cl_clear_output _ECL_ARGS((cl_narg narg, ...));
ecl/external.h:extern ECL_API cl_object si_search_print_circle(cl_object x);
ecl/external.h:extern ECL_API cl_object si_write_object_with_circle(cl_object object, cl_object stream, cl_object print_function);
ecl/external.h:extern ECL_API cl_object si_write_object(cl_object object, cl_object stream);
ecl/external.h:extern ECL_API cl_object si_write_ugly_object(cl_object object, cl_object stream);
ecl/external.h:extern ECL_API cl_object ecl_princ(cl_object obj, cl_object strm);
ecl/external.h:extern ECL_API cl_object ecl_prin1(cl_object obj, cl_object strm);
ecl/external.h:extern ECL_API cl_object ecl_print(cl_object obj, cl_object strm);
ecl/external.h:extern ECL_API cl_object ecl_terpri(cl_object strm);
ecl/external.h:extern ECL_API void ecl_write_string(cl_object strng, cl_object strm);
ecl/external.h:extern ECL_API void ecl_princ_str(const char *s, cl_object sym);
ecl/external.h:extern ECL_API int ecl_princ_char(int c, cl_object sym);
ecl/external.h:extern ECL_API cl_object ecl_print_case(void);
ecl/external.h:extern ECL_API cl_object si_integer_to_string(cl_object buffer, cl_object integer, cl_object base, cl_object radix, cl_object decimalp);
ecl/external.h:extern ECL_API cl_object si_float_string(cl_narg narg, cl_object string, cl_object x, ...);
ecl/external.h:extern ECL_API cl_object si_float_to_digits(cl_object digits, cl_object number, cl_object position, cl_object relativep);
ecl/external.h:extern ECL_API cl_object si_float_to_string_free(cl_object buffer, cl_object number, cl_object e_min, cl_object e_max);
ecl/external.h:extern ECL_API cl_object si_print_unreadable_object_function(cl_object o, cl_object stream, cl_object type, cl_object id, cl_object fn);
ecl/external.h:extern ECL_API cl_object si_profile _ECL_ARGS((cl_narg narg, cl_object scale, cl_object start_address, ...));
ecl/external.h:extern ECL_API cl_object si_clear_profile _ECL_ARGS((cl_narg narg, ...));
ecl/external.h:extern ECL_API cl_object si_display_profile _ECL_ARGS((cl_narg narg, ...));
ecl/external.h:extern ECL_API cl_object si_get_buffer_string();
ecl/external.h:extern ECL_API cl_object si_put_buffer_string(cl_object string);
ecl/external.h:extern ECL_API cl_object cl_read_sequence _ECL_ARGS((cl_narg narg, cl_object seq, cl_object stream, ...));
ecl/external.h:extern ECL_API cl_object cl_readtablep(cl_object readtable);
ecl/external.h:extern ECL_API cl_object si_standard_readtable(void);
ecl/external.h:extern ECL_API cl_object cl_read _ECL_ARGS((cl_narg narg, ...));
ecl/external.h:extern ECL_API cl_object cl_read_preserving_whitespace _ECL_ARGS((cl_narg narg, ...));
ecl/external.h:extern ECL_API cl_object cl_read_delimited_list _ECL_ARGS((cl_narg narg, cl_object d, ...));
ecl/external.h:extern ECL_API cl_object cl_read_line _ECL_ARGS((cl_narg narg, ...));
ecl/external.h:extern ECL_API cl_object cl_read_char _ECL_ARGS((cl_narg narg, ...));
ecl/external.h:extern ECL_API cl_object cl_unread_char _ECL_ARGS((cl_narg narg, cl_object c, ...));
ecl/external.h:extern ECL_API cl_object cl_peek_char _ECL_ARGS((cl_narg narg, ...));
ecl/external.h:extern ECL_API cl_object cl_listen _ECL_ARGS((cl_narg narg, ...));
ecl/external.h:extern ECL_API cl_object cl_read_char_no_hang _ECL_ARGS((cl_narg narg, ...));
ecl/external.h:extern ECL_API cl_object cl_clear_input _ECL_ARGS((cl_narg narg, ...));
ecl/external.h:extern ECL_API cl_object cl_parse_integer _ECL_ARGS((cl_narg narg, cl_object strng, ...));
ecl/external.h:extern ECL_API cl_object cl_read_byte _ECL_ARGS((cl_narg narg, cl_object binary_input_stream, ...));
ecl/external.h:extern ECL_API cl_object cl_copy_readtable _ECL_ARGS((cl_narg narg, ...));
ecl/external.h:extern ECL_API cl_object cl_readtable_case(cl_object r);
ecl/external.h:extern ECL_API cl_object si_readtable_case_set(cl_object r, cl_object mode);
ecl/external.h:extern ECL_API cl_object cl_set_syntax_from_char _ECL_ARGS((cl_narg narg, cl_object tochr, cl_object fromchr, ...));
ecl/external.h:extern ECL_API cl_object cl_set_macro_character _ECL_ARGS((cl_narg narg, cl_object chr, cl_object fnc, ...));
ecl/external.h:extern ECL_API cl_object cl_get_macro_character _ECL_ARGS((cl_narg narg, cl_object chr, ...));
ecl/external.h:extern ECL_API cl_object cl_make_dispatch_macro_character _ECL_ARGS((cl_narg narg, cl_object chr, ...));
ecl/external.h:extern ECL_API cl_object cl_set_dispatch_macro_character _ECL_ARGS((cl_narg narg, cl_object dspchr, cl_object subchr, cl_object fnc, ...));
ecl/external.h:extern ECL_API cl_object cl_get_dispatch_macro_character _ECL_ARGS((cl_narg narg, cl_object dspchr, cl_object subchr, ...));
ecl/external.h:extern ECL_API cl_object si_read_object_or_ignore(cl_object stream, cl_object eof);
ecl/external.h:extern ECL_API cl_object si_readtable_lock _ECL_ARGS((cl_narg narg, cl_object readtable, ...));
ecl/external.h:extern ECL_API int ecl_readtable_get(cl_object rdtbl, int c, cl_object *macro);
ecl/external.h:extern ECL_API void ecl_readtable_set(cl_object rdtbl, int c, enum ecl_chattrib cat, cl_object macro_or_table);
ecl/external.h:extern ECL_API cl_object ecl_read_object_non_recursive(cl_object in);
ecl/external.h:extern ECL_API cl_object ecl_read_object(cl_object in);
ecl/external.h:extern ECL_API cl_object ecl_parse_number(cl_object s, cl_index start, cl_index end, cl_index *ep, unsigned int radix);
ecl/external.h:extern ECL_API cl_object ecl_parse_integer(cl_object s, cl_index start, cl_index end, cl_index *ep, unsigned int radix);
ecl/external.h:extern ECL_API cl_object ecl_copy_readtable(cl_object from, cl_object to);
ecl/external.h:extern ECL_API cl_object ecl_current_readtable(void);
ecl/external.h:extern ECL_API cl_object ecl_init_module(cl_object block, void (*entry)(cl_object));
ecl/external.h:extern ECL_API cl_object cl_fboundp(cl_object sym);
ecl/external.h:extern ECL_API cl_object cl_symbol_function(cl_object sym);
ecl/external.h:extern ECL_API cl_object cl_fdefinition(cl_object fname);
ecl/external.h:extern ECL_API cl_object si_coerce_to_function(cl_object form);
ecl/external.h:extern ECL_API cl_object cl_symbol_value(cl_object sym);
ecl/external.h:extern ECL_API cl_object cl_boundp(cl_object sym);
ecl/external.h:extern ECL_API cl_object cl_special_operator_p(cl_object form);
ecl/external.h:extern ECL_API cl_object ecl_fdefinition(cl_object fname);
ecl/external.h:extern ECL_API bool ecl_boundp(cl_env_ptr env, cl_object o);
ecl/external.h:extern ECL_API cl_object si_sequence_start_end(cl_object fun, cl_object sequence, cl_object start, cl_object end);
ecl/external.h:extern ECL_API cl_object cl_elt(cl_object x, cl_object i);
ecl/external.h:extern ECL_API cl_object si_elt_set(cl_object seq, cl_object index, cl_object val);
ecl/external.h:extern ECL_API cl_object cl_copy_seq(cl_object x);
ecl/external.h:extern ECL_API cl_object cl_length(cl_object x);
ecl/external.h:extern ECL_API cl_object cl_reverse(cl_object x);
ecl/external.h:extern ECL_API cl_object cl_nreverse(cl_object x);
ecl/external.h:extern ECL_API cl_object cl_subseq _ECL_ARGS((cl_narg narg, cl_object sequence, cl_object start, ...));
ecl/external.h:extern ECL_API cl_object ecl_elt(cl_object seq, cl_fixnum index);
ecl/external.h:extern ECL_API cl_object ecl_elt_set(cl_object seq, cl_fixnum index, cl_object val);
ecl/external.h:extern ECL_API cl_fixnum ecl_length(cl_object x);
ecl/external.h:extern ECL_API cl_object ecl_subseq(cl_object seq, cl_index start, cl_index limit);
ecl/external.h:extern ECL_API cl_object ecl_copy_seq(cl_object seq);
ecl/external.h:extern cl_object si_serialize(cl_object root);
ecl/external.h:extern cl_object si_deserialize(cl_object root);
ecl/external.h:extern ECL_API cl_object si_sse_pack_p(cl_object x);
ecl/external.h:extern ECL_API cl_object si_sse_pack_as_elt_type(cl_object x, cl_object type);
ecl/external.h:extern ECL_API cl_object si_sse_pack_element_type(cl_object x);
ecl/external.h:extern ECL_API cl_object si_vector_to_sse_pack(cl_object x);
ecl/external.h:extern ECL_API cl_object si_sse_pack_to_vector(cl_object x, cl_object elt_type);
ecl/external.h:extern ECL_API cl_object ecl_make_int_sse_pack(__m128i value);
ecl/external.h:extern ECL_API __m128i ecl_unbox_int_sse_pack(cl_object value);
ecl/external.h:extern ECL_API cl_object ecl_make_float_sse_pack(__m128 value);
ecl/external.h:extern ECL_API __m128 ecl_unbox_float_sse_pack(cl_object value);
ecl/external.h:extern ECL_API cl_object ecl_make_double_sse_pack(__m128d value);
ecl/external.h:extern ECL_API __m128d ecl_unbox_double_sse_pack(cl_object value);
ecl/external.h:extern ECL_API cl_object si_ihs_top(void);
ecl/external.h:extern ECL_API cl_object si_ihs_fun(cl_object arg);
ecl/external.h:extern ECL_API cl_object si_ihs_env(cl_object arg);
ecl/external.h:extern ECL_API cl_object si_ihs_bds(cl_object arg);
ecl/external.h:extern ECL_API cl_object si_ihs_next(cl_object arg);
ecl/external.h:extern ECL_API cl_object si_ihs_prev(cl_object arg);
ecl/external.h:extern ECL_API cl_object si_frs_top(void);
ecl/external.h:extern ECL_API cl_object si_frs_bds(cl_object arg);
ecl/external.h:extern ECL_API cl_object si_frs_tag(cl_object arg);
ecl/external.h:extern ECL_API cl_object si_frs_ihs(cl_object arg);
ecl/external.h:extern ECL_API cl_object si_bds_top(void);
ecl/external.h:extern ECL_API cl_object si_bds_var(cl_object arg);
ecl/external.h:extern ECL_API cl_object si_bds_val(cl_object arg);
ecl/external.h:extern ECL_API cl_object si_sch_frs_base(cl_object fr, cl_object ihs);
ecl/external.h:extern ECL_API cl_object si_reset_stack_limits(void);
ecl/external.h:extern ECL_API cl_object si_reset_margin(cl_object type);
ecl/external.h:extern ECL_API cl_object si_set_limit(cl_object type, cl_object size);
ecl/external.h:extern ECL_API cl_object si_get_limit(cl_object type);
ecl/external.h:extern ECL_API cl_index ecl_progv(cl_env_ptr env, cl_object vars, cl_object values);
ecl/external.h:extern ECL_API struct ecl_frame *frs_sch(cl_object frame_id);
ecl/external.h:extern ECL_API cl_object cl_char(cl_object s, cl_object i);
ecl/external.h:extern ECL_API cl_object si_char_set(cl_object str, cl_object index, cl_object c);
ecl/external.h:extern ECL_API cl_object cl_string_trim(cl_object char_bag, cl_object strng);
ecl/external.h:extern ECL_API cl_object cl_string_left_trim(cl_object char_bag, cl_object strng);
ecl/external.h:extern ECL_API cl_object cl_string_right_trim(cl_object char_bag, cl_object strng);
ecl/external.h:extern ECL_API cl_object cl_string(cl_object x);
ecl/external.h:extern ECL_API cl_object cl_make_string _ECL_ARGS((cl_narg narg, cl_object size, ...));
ecl/external.h:extern ECL_API cl_object cl_stringE _ECL_ARGS((cl_narg narg, cl_object string1, cl_object string2, ...));
ecl/external.h:extern ECL_API cl_object cl_string_equal _ECL_ARGS((cl_narg narg, cl_object string1, cl_object string2, ...));
ecl/external.h:extern ECL_API cl_object cl_stringL _ECL_ARGS((cl_narg narg, ...));
ecl/external.h:extern ECL_API cl_object cl_stringG _ECL_ARGS((cl_narg narg, ...));
ecl/external.h:extern ECL_API cl_object cl_stringLE _ECL_ARGS((cl_narg narg, ...));
ecl/external.h:extern ECL_API cl_object cl_stringGE _ECL_ARGS((cl_narg narg, ...));
ecl/external.h:extern ECL_API cl_object cl_stringNE _ECL_ARGS((cl_narg narg, ...));
ecl/external.h:extern ECL_API cl_object cl_string_lessp _ECL_ARGS((cl_narg narg, ...));
ecl/external.h:extern ECL_API cl_object cl_string_greaterp _ECL_ARGS((cl_narg narg, ...));
ecl/external.h:extern ECL_API cl_object cl_string_not_greaterp _ECL_ARGS((cl_narg narg, ...));
ecl/external.h:extern ECL_API cl_object cl_string_not_lessp _ECL_ARGS((cl_narg narg, ...));
ecl/external.h:extern ECL_API cl_object cl_string_not_equal _ECL_ARGS((cl_narg narg, ...));
ecl/external.h:extern ECL_API cl_object cl_string_upcase _ECL_ARGS((cl_narg narg, ...));
ecl/external.h:extern ECL_API cl_object cl_string_downcase _ECL_ARGS((cl_narg narg, ...));
ecl/external.h:extern ECL_API cl_object cl_string_capitalize _ECL_ARGS((cl_narg narg, ...));
ecl/external.h:extern ECL_API cl_object cl_nstring_upcase _ECL_ARGS((cl_narg narg, ...));
ecl/external.h:extern ECL_API cl_object cl_nstring_downcase _ECL_ARGS((cl_narg narg, ...));
ecl/external.h:extern ECL_API cl_object cl_nstring_capitalize _ECL_ARGS((cl_narg narg, ...));
ecl/external.h:extern ECL_API cl_object si_base_string_concatenate _ECL_ARGS((cl_narg narg, ...));
ecl/external.h:extern ECL_API cl_object si_copy_to_simple_base_string(cl_object s);
ecl/external.h:extern ECL_API cl_object ecl_alloc_adjustable_base_string(cl_index l);
ecl/external.h:extern ECL_API cl_object ecl_make_constant_base_string(const char *s, cl_fixnum i);
ecl/external.h:extern ECL_API cl_object ecl_make_simple_base_string(const char *s, cl_fixnum i);
ecl/external.h:extern ECL_API cl_object ecl_cstring_to_base_string_or_nil(const char *s);
ecl/external.h:extern ECL_API bool ecl_string_eq(cl_object x, cl_object y);
ecl/external.h:extern ECL_API bool ecl_member_char(ecl_character c, cl_object char_bag);
ecl/external.h:extern ECL_API bool ecl_fits_in_base_string(cl_object s);
ecl/external.h:extern ECL_API ecl_character ecl_char(cl_object s, cl_index i);
ecl/external.h:extern ECL_API ecl_character ecl_char_set(cl_object s, cl_index i, ecl_character c);
ecl/external.h:extern ECL_API cl_object si_structure_subtype_p(cl_object x, cl_object y);
ecl/external.h:extern ECL_API cl_object cl_copy_structure(cl_object s);
ecl/external.h:extern ECL_API cl_object si_structure_name(cl_object s);
ecl/external.h:extern ECL_API cl_object si_structure_ref(cl_object x, cl_object type, cl_object index);
ecl/external.h:extern ECL_API cl_object si_structure_set(cl_object x, cl_object type, cl_object index, cl_object val);
ecl/external.h:extern ECL_API cl_object si_structurep(cl_object s);
ecl/external.h:extern ECL_API cl_object si_make_structure _ECL_ARGS((cl_narg narg, cl_object type, ...));
ecl/external.h:extern ECL_API cl_object ecl_structure_ref(cl_object x, cl_object name, cl_fixnum n);
ecl/external.h:extern ECL_API cl_object ecl_structure_set(cl_object x, cl_object name, cl_fixnum n, cl_object v);
ecl/external.h:extern ECL_API cl_object mp_compare_and_swap_structure(cl_object x, cl_object type, cl_object index, cl_object old_val, cl_object new_val);
ecl/external.h:extern ECL_API cl_object cl_make_symbol(cl_object str);
ecl/external.h:extern ECL_API cl_object cl_remprop(cl_object sym, cl_object prop);
ecl/external.h:extern ECL_API cl_object cl_symbol_plist(cl_object sym);
ecl/external.h:extern ECL_API cl_object cl_get_properties(cl_object place, cl_object indicator_list);
ecl/external.h:extern ECL_API cl_object cl_symbol_name(cl_object sym);
ecl/external.h:extern ECL_API cl_object cl_symbol_package(cl_object sym);
ecl/external.h:extern ECL_API cl_object cl_keywordp(cl_object sym);
ecl/external.h:extern ECL_API cl_object si_put_f(cl_object plist, cl_object value, cl_object indicator);
ecl/external.h:extern ECL_API cl_object si_rem_f(cl_object plist, cl_object indicator);
ecl/external.h:extern ECL_API cl_object si_set_symbol_plist(cl_object sym, cl_object plist);
ecl/external.h:extern ECL_API cl_object si_putprop(cl_object sym, cl_object value, cl_object indicator);
ecl/external.h:extern ECL_API cl_object si_Xmake_special(cl_object sym);
ecl/external.h:extern ECL_API cl_object si_Xmake_constant(cl_object sym, cl_object val);
ecl/external.h:extern ECL_API cl_object cl_get _ECL_ARGS((cl_narg narg, cl_object sym, cl_object indicator, ...));
ecl/external.h:extern ECL_API cl_object cl_getf _ECL_ARGS((cl_narg narg, cl_object place, cl_object indicator, ...));
ecl/external.h:extern ECL_API cl_object cl_copy_symbol _ECL_ARGS((cl_narg narg, cl_object sym, ...));
ecl/external.h:extern ECL_API cl_object cl_gensym _ECL_ARGS((cl_narg narg, ...));
ecl/external.h:extern ECL_API cl_object cl_gentemp _ECL_ARGS((cl_narg narg, ...));
ecl/external.h:extern ECL_API cl_object si_put_properties _ECL_ARGS((cl_narg narg, cl_object sym, ...));
ecl/external.h:extern ECL_API void ecl_defvar(cl_object s, cl_object v);
ecl/external.h:extern ECL_API void ecl_defparameter(cl_object s, cl_object v);
ecl/external.h:extern ECL_API cl_object ecl_make_symbol(const char *s, const char*p);
ecl/external.h:extern ECL_API cl_object ecl_make_keyword(const char *s);
ecl/external.h:extern ECL_API cl_object ecl_symbol_value(cl_object s);
ecl/external.h:extern ECL_API cl_object ecl_setq(cl_env_ptr env, cl_object var, cl_object value);
ecl/external.h:extern ECL_API cl_object ecl_symbol_name(cl_object s);
ecl/external.h:extern ECL_API cl_object ecl_symbol_package(cl_object s);
ecl/external.h:extern ECL_API int ecl_symbol_type(cl_object s);
ecl/external.h:extern ECL_API void ecl_symbol_type_set(cl_object s, int t);
ecl/external.h:extern ECL_API cl_object ecl_getf(cl_object place, cl_object indicator, cl_object deflt);
ecl/external.h:extern ECL_API cl_object ecl_get(cl_object s, cl_object p, cl_object d);
ecl/external.h:extern ECL_API bool ecl_keywordp(cl_object s);
ecl/external.h:extern ECL_API cl_object mp_compare_and_swap_symbol_plist(cl_object x, cl_object old_val, cl_object new_val);
ecl/external.h:extern ECL_API cl_object si_open_client_stream(cl_object host, cl_object port);
ecl/external.h:extern ECL_API cl_object si_open_server_stream(cl_object port);
ecl/external.h:extern ECL_API cl_object si_open_unix_socket_stream(cl_object path);
ecl/external.h:extern ECL_API cl_object si_lookup_host_entry(cl_object host_or_address);
ecl/external.h:extern ECL_API cl_object mp_own_process(void) __attribute__((const));
ecl/external.h:extern ECL_API cl_object mp_all_processes(void);
ecl/external.h:extern ECL_API cl_object mp_exit_process(void) ecl_attr_noreturn;
ecl/external.h:extern ECL_API cl_object mp_interrupt_process(cl_object process, cl_object function);
ecl/external.h:extern ECL_API cl_object mp_make_process _ECL_ARGS((cl_narg narg, ...));
ecl/external.h:extern ECL_API cl_object mp_process_active_p(cl_object process);
ecl/external.h:extern ECL_API cl_object mp_process_enable(cl_object process);
ecl/external.h:extern ECL_API cl_object mp_process_yield(void);
ecl/external.h:extern ECL_API cl_object mp_process_join(cl_object process);
ecl/external.h:extern ECL_API cl_object mp_process_kill(cl_object process);
ecl/external.h:extern ECL_API cl_object mp_process_suspend(cl_object process);
ecl/external.h:extern ECL_API cl_object mp_process_resume(cl_object process);
ecl/external.h:extern ECL_API cl_object mp_process_name(cl_object process);
ecl/external.h:extern ECL_API cl_object mp_process_preset _ECL_ARGS((cl_narg narg, cl_object process, cl_object function, ...));
ecl/external.h:extern ECL_API cl_object mp_process_run_function _ECL_ARGS((cl_narg narg, cl_object name, cl_object function, ...));
ecl/external.h:extern ECL_API cl_object mp_process_run_function_wait _ECL_ARGS((cl_narg narg, ...));
ecl/external.h:extern ECL_API cl_object mp_process_whostate(cl_object process);
ecl/external.h:extern ECL_API cl_object mp_make_condition_variable(void);
ecl/external.h:extern ECL_API cl_object mp_condition_variable_wait(cl_object cv, cl_object lock);
ecl/external.h:extern ECL_API cl_object mp_condition_variable_timedwait(cl_object cv, cl_object lock, cl_object seconds);
ecl/external.h:extern ECL_API cl_object mp_condition_variable_signal(cl_object cv);
ecl/external.h:extern ECL_API cl_object mp_condition_variable_broadcast(cl_object cv);
ecl/external.h:extern ECL_API cl_object mp_current_process(void);
ecl/external.h:extern ECL_API cl_object mp_block_signals(void);
ecl/external.h:extern ECL_API cl_object mp_restore_signals(cl_object sigmask);
ecl/external.h:extern ECL_API bool ecl_import_current_thread(cl_object process_name, cl_object process_binding);
ecl/external.h:extern ECL_API cl_object mp_make_semaphore _ECL_ARGS((cl_narg, ...));
ecl/external.h:extern ECL_API cl_object mp_semaphore_count(cl_object);
ecl/external.h:extern ECL_API cl_object mp_semaphore_name(cl_object);
ecl/external.h:extern ECL_API cl_object mp_semaphore_wait_count(cl_object);
ecl/external.h:extern ECL_API cl_object mp_wait_on_semaphore(cl_object);
ecl/external.h:extern ECL_API cl_object mp_try_get_semaphore(cl_object);
ecl/external.h:extern ECL_API cl_object mp_signal_semaphore _ECL_ARGS((cl_narg, cl_object, ...));
ecl/external.h:extern ECL_API cl_object ecl_make_semaphore(cl_object name, cl_fixnum count);
ecl/external.h:extern ECL_API cl_object ecl_make_barrier(cl_object name, cl_index count);
ecl/external.h:extern ECL_API cl_object mp_make_barrier _ECL_ARGS((cl_narg, cl_object, ...));
ecl/external.h:extern ECL_API cl_object mp_barrier_count(cl_object);
ecl/external.h:extern ECL_API cl_object mp_barrier_name(cl_object);
ecl/external.h:extern ECL_API cl_object mp_barrier_arrivers_count(cl_object);
ecl/external.h:extern ECL_API cl_object mp_barrier_wait (cl_object);
ecl/external.h:extern ECL_API cl_object mp_barrier_unblock _ECL_ARGS((cl_narg, cl_object, ...));
ecl/external.h:extern ECL_API cl_object mp_make_mailbox _ECL_ARGS((cl_narg, ...));
ecl/external.h:extern ECL_API cl_object mp_mailbox_name(cl_object mailbox);
ecl/external.h:extern ECL_API cl_object mp_mailbox_count(cl_object mailbox);
ecl/external.h:extern ECL_API cl_object mp_mailbox_empty_p(cl_object);
ecl/external.h:extern ECL_API cl_object mp_mailbox_read(cl_object mailbox);
ecl/external.h:extern ECL_API cl_object mp_mailbox_try_read(cl_object mailbox);
ecl/external.h:extern ECL_API cl_object mp_mailbox_send(cl_object mailbox, cl_object msg);
ecl/external.h:extern ECL_API cl_object mp_mailbox_try_send(cl_object mailbox, cl_object msg);
ecl/external.h:extern ECL_API cl_object ecl_atomic_get(cl_object *slot);
ecl/external.h:extern ECL_API void ecl_atomic_push(cl_object *slot, cl_object o);
ecl/external.h:extern ECL_API cl_object ecl_atomic_pop(cl_object *slot);
ecl/external.h:extern ECL_API cl_object mp_make_lock _ECL_ARGS((cl_narg narg, ...));
ecl/external.h:extern ECL_API cl_object mp_recursive_lock_p(cl_object lock);
ecl/external.h:extern ECL_API cl_object mp_holding_lock_p(cl_object lock);
ecl/external.h:extern ECL_API cl_object mp_lock_name(cl_object lock);
ecl/external.h:extern ECL_API cl_object mp_lock_owner(cl_object lock);
ecl/external.h:extern ECL_API cl_object mp_lock_count(cl_object lock);
ecl/external.h:extern ECL_API cl_object mp_get_lock _ECL_ARGS((cl_narg narg, cl_object lock, ...));
ecl/external.h:extern ECL_API cl_object mp_get_lock_wait(cl_object lock);
ecl/external.h:extern ECL_API cl_object mp_get_lock_nowait(cl_object lock);
ecl/external.h:extern ECL_API cl_object mp_giveup_lock(cl_object lock);
ecl/external.h:extern ECL_API cl_object ecl_make_lock(cl_object lock, bool recursive);
ecl/external.h:extern ECL_API cl_object mp_make_rwlock _ECL_ARGS((cl_narg narg, ...));
ecl/external.h:extern ECL_API cl_object mp_rwlock_name(cl_object lock);
ecl/external.h:extern ECL_API cl_object mp_get_rwlock_read _ECL_ARGS((cl_narg narg, cl_object lock, ...));
ecl/external.h:extern ECL_API cl_object mp_get_rwlock_write _ECL_ARGS((cl_narg narg, cl_object lock, ...));
ecl/external.h:extern ECL_API cl_object mp_giveup_rwlock_read(cl_object lock);
ecl/external.h:extern ECL_API cl_object mp_giveup_rwlock_write(cl_object lock);
ecl/external.h:extern ECL_API cl_object ecl_make_rwlock(cl_object lock);
ecl/external.h:extern ECL_API cl_object cl_sleep(cl_object z);
ecl/external.h:extern ECL_API cl_object cl_get_internal_run_time(void);
ecl/external.h:extern ECL_API cl_object cl_get_internal_real_time(void);
ecl/external.h:extern ECL_API cl_object cl_get_universal_time(void);
ecl/external.h:extern ECL_API void assert_type_integer(cl_object p);
ecl/external.h:extern ECL_API void assert_type_non_negative_integer(cl_object p);
ecl/external.h:extern ECL_API void assert_type_proper_list(cl_object p);
ecl/external.h:extern ECL_API cl_object cl_type_of(cl_object x);
ecl/external.h:extern ECL_API void FEtype_error_fixnum(cl_object x) ecl_attr_noreturn;
ecl/external.h:extern ECL_API void FEtype_error_size(cl_object x) ecl_attr_noreturn;
ecl/external.h:extern ECL_API void FEtype_error_cons(cl_object x) ecl_attr_noreturn;
ecl/external.h:extern ECL_API void FEtype_error_list(cl_object x) ecl_attr_noreturn;
ecl/external.h:extern ECL_API void FEtype_error_proper_list(cl_object x) ecl_attr_noreturn;
ecl/external.h:extern ECL_API void FEtype_error_sequence(cl_object x) ecl_attr_noreturn;
ecl/external.h:extern ECL_API void FEtype_error_vector(cl_object x) ecl_attr_noreturn;
ecl/external.h:extern ECL_API void FEcircular_list(cl_object x) ecl_attr_noreturn;
ecl/external.h:extern ECL_API void FEtype_error_index(cl_object seq, cl_fixnum ndx) ecl_attr_noreturn;
ecl/external.h:extern ECL_API void FEtype_error_array(cl_object x) ecl_attr_noreturn;
ecl/external.h:extern ECL_API void FEdivision_by_zero(cl_object x, cl_object y) ecl_attr_noreturn;
ecl/external.h:extern ECL_API cl_object ecl_type_error(cl_object function, const char *place, cl_object o, cl_object type);
ecl/external.h:extern ECL_API cl_object ecl_check_cl_type(cl_object fun, cl_object p, cl_type t);
ecl/external.h:extern ECL_API cl_object ecl_make_integer_type(cl_object min, cl_object max);
ecl/external.h:extern ECL_API cl_object cl_truename(cl_object file);
ecl/external.h:extern ECL_API cl_object cl_rename_file _ECL_ARGS((cl_narg narg, cl_object old_obj, cl_object new_obj, ...));
ecl/external.h:extern ECL_API cl_object cl_delete_file(cl_object file);
ecl/external.h:extern ECL_API cl_object cl_probe_file(cl_object file);
ecl/external.h:extern ECL_API cl_object cl_file_write_date(cl_object file);
ecl/external.h:extern ECL_API cl_object cl_file_author(cl_object file);
ecl/external.h:extern ECL_API cl_object si_file_kind(cl_object pathname, cl_object follow_links);
ecl/external.h:extern ECL_API cl_object si_getcwd _ECL_ARGS((cl_narg narg, ...));
ecl/external.h:extern ECL_API cl_object si_getpid(void);
ecl/external.h:extern ECL_API cl_object si_getuid(void);
ecl/external.h:extern ECL_API cl_object si_chdir _ECL_ARGS((cl_narg narg, cl_object directory, ...));
ecl/external.h:extern ECL_API cl_object si_chmod(cl_object filename, cl_object mode);
ecl/external.h:extern ECL_API cl_object si_mkdir(cl_object directory, cl_object mode);
ecl/external.h:extern ECL_API cl_object cl_directory _ECL_ARGS((cl_narg narg, cl_object directory, ...));
ecl/external.h:extern ECL_API cl_object cl_user_homedir_pathname _ECL_ARGS((cl_narg narg, ...));
ecl/external.h:extern ECL_API cl_object si_mkstemp(cl_object templ);
ecl/external.h:extern ECL_API cl_object si_rmdir(cl_object directory);
ecl/external.h:extern ECL_API cl_object ecl_cstring_to_pathname(char *s);
ecl/external.h:extern ECL_API cl_object ecl_file_len(int f);
ecl/external.h:extern ECL_API cl_object ecl_homedir_pathname(cl_object user);
ecl/external.h:extern ECL_API cl_object si_get_library_pathname(void);
ecl/external.h:extern ECL_API cl_object si_copy_file(cl_object orig, cl_object end);
ecl/external.h:extern ECL_API cl_object si_handle_signal(cl_object signal);
ecl/external.h:extern ECL_API cl_object si_get_signal_handler(cl_object signal);
ecl/external.h:extern ECL_API cl_object si_set_signal_handler(cl_object signal, cl_object handler);
ecl/external.h:extern ECL_API cl_object si_catch_signal(cl_narg narg, cl_object signal, cl_object state, ...);
ecl/external.h:extern ECL_API cl_object si_check_pending_interrupts(void);
ecl/external.h:extern ECL_API cl_object si_disable_interrupts(void);
ecl/external.h:extern ECL_API cl_object si_enable_interrupts(void);
ecl/external.h:extern ECL_API cl_object si_trap_fpe(cl_object condition, cl_object flag);
ecl/external.h:extern ECL_API cl_object si_system(cl_object cmd);
ecl/external.h:extern ECL_API cl_object si_make_pipe();
ecl/external.h:extern ECL_API cl_object si_run_program _ECL_ARGS((cl_narg narg, cl_object command, cl_object args, ...));
ecl/external.h:extern ECL_API cl_object si_close_windows_handle(cl_object h);
ecl/external.h:extern ECL_API cl_object si_terminate_process _ECL_ARGS((cl_narg narg, cl_object process, ...));
ecl/external.h:extern ECL_API cl_object si_waitpid(cl_object pid, cl_object wait);
ecl/external.h:extern ECL_API cl_object si_killpid(cl_object pid, cl_object signal);
ecl/external.h:extern ECL_API cl_object si_run_program_inner
ecl/external.h:(cl_object command, cl_object argv, cl_object environment, cl_object wait);
ecl/external.h:extern ECL_API cl_object si_spawn_subprocess
ecl/external.h:(cl_object command, cl_object argv, cl_object environment,
ecl/external.h: cl_object input, cl_object output, cl_object error);
ecl/external.h:extern ECL_API cl_object si_base_char_p(cl_object x);
ecl/external.h:extern ECL_API cl_object si_base_string_p(cl_object x);
ecl/external.h:extern ECL_API cl_object si_coerce_to_base_string(cl_object x);
ecl/external.h:extern ECL_API cl_object si_coerce_to_extended_string(cl_object x);
ecl/external.h:extern ECL_API cl_object ecl_alloc_adjustable_extended_string(cl_index l);
ecl/external.h:extern ECL_API cl_object _ecl_ucd_code_to_name(ecl_character c);
ecl/external.h:extern ECL_API cl_object _ecl_ucd_name_to_code(cl_object name);
ecl/external.h:extern ECL_API ecl_character ecl_string_push_extend(cl_object s, ecl_character c);
ecl/external.h:extern ECL_API cl_object cl_vector_push _ECL_ARGS((cl_object V1, cl_object V2));
ecl/external.h:extern ECL_API cl_object cl_vector_push_extend _ECL_ARGS((cl_narg narg, cl_object V1, cl_object V2, ...));
ecl/external.h:extern ECL_API cl_object cl_make_array _ECL_ARGS((cl_narg narg, cl_object V1, ...));
ecl/external.h:extern ECL_API cl_object si_fill_array_with_seq _ECL_ARGS((cl_narg narg, cl_object V1, cl_object V2, ...));
ecl/external.h:extern ECL_API cl_object cl_vector _ECL_ARGS((cl_narg narg, ...));
ecl/external.h:extern ECL_API cl_object cl_array_dimensions(cl_object V1);
ecl/external.h:extern ECL_API cl_object cl_array_in_bounds_p _ECL_ARGS((cl_narg narg, cl_object V1, ...));
ecl/external.h:extern ECL_API cl_object cl_array_row_major_index _ECL_ARGS((cl_narg narg, cl_object V1, ...));
ecl/external.h:extern ECL_API cl_object cl_bit _ECL_ARGS((cl_narg narg, cl_object V1, ...));
ecl/external.h:extern ECL_API cl_object cl_sbit _ECL_ARGS((cl_narg narg, cl_object V1, ...));
ecl/external.h:extern ECL_API cl_object cl_bit_and _ECL_ARGS((cl_narg narg, cl_object V1, cl_object V2, ...));
ecl/external.h:extern ECL_API cl_object cl_bit_ior _ECL_ARGS((cl_narg narg, cl_object V1, cl_object V2, ...));
ecl/external.h:extern ECL_API cl_object cl_bit_xor _ECL_ARGS((cl_narg narg, cl_object V1, cl_object V2, ...));
ecl/external.h:extern ECL_API cl_object cl_bit_eqv _ECL_ARGS((cl_narg narg, cl_object V1, cl_object V2, ...));
ecl/external.h:extern ECL_API cl_object cl_bit_nand _ECL_ARGS((cl_narg narg, cl_object V1, cl_object V2, ...));
ecl/external.h:extern ECL_API cl_object cl_bit_nor _ECL_ARGS((cl_narg narg, cl_object V1, cl_object V2, ...));
ecl/external.h:extern ECL_API cl_object cl_bit_andc1 _ECL_ARGS((cl_narg narg, cl_object V1, cl_object V2, ...));
ecl/external.h:extern ECL_API cl_object cl_bit_andc2 _ECL_ARGS((cl_narg narg, cl_object V1, cl_object V2, ...));
ecl/external.h:extern ECL_API cl_object cl_bit_orc1 _ECL_ARGS((cl_narg narg, cl_object V1, cl_object V2, ...));
ecl/external.h:extern ECL_API cl_object cl_bit_orc2 _ECL_ARGS((cl_narg narg, cl_object V1, cl_object V2, ...));
ecl/external.h:extern ECL_API cl_object cl_bit_not _ECL_ARGS((cl_narg narg, cl_object V1, ...));
ecl/external.h:extern ECL_API cl_object cl_vector_pop(cl_object V1);
ecl/external.h:extern ECL_API cl_object cl_adjust_array _ECL_ARGS((cl_narg narg, cl_object V1, cl_object V2, ...));
ecl/external.h:extern ECL_API cl_object cl_short_site_name();
ecl/external.h:extern ECL_API cl_object cl_long_site_name();
ecl/external.h:extern ECL_API cl_object cl_lisp_implementation_type();
ecl/external.h:extern ECL_API cl_object cl_lisp_implementation_version();
ecl/external.h:extern ECL_API cl_object si_lisp_implementation_vcs_id();
ecl/external.h:extern ECL_API cl_object cl_machine_type();
ecl/external.h:extern ECL_API cl_object cl_machine_instance();
ecl/external.h:extern ECL_API cl_object cl_machine_version();
ecl/external.h:extern ECL_API cl_object cl_software_type();
ecl/external.h:extern ECL_API cl_object cl_software_version();
ecl/external.h:extern ECL_API cl_object cl_inspect(cl_object o);
ecl/external.h:extern ECL_API cl_object cl_describe _ECL_ARGS((cl_narg narg, cl_object o, ...));
ecl/external.h:extern ECL_API cl_object cl_read_from_string _ECL_ARGS((cl_narg narg, cl_object V1, ...));
ecl/external.h:extern ECL_API cl_object cl_write_to_string _ECL_ARGS((cl_narg narg, cl_object V1, ...));
ecl/external.h:extern ECL_API cl_object cl_prin1_to_string(cl_object V1);
ecl/external.h:extern ECL_API cl_object cl_princ_to_string(cl_object V1);
ecl/external.h:extern ECL_API cl_object cl_y_or_n_p _ECL_ARGS((cl_narg narg, ...));
ecl/external.h:extern ECL_API cl_object cl_yes_or_no_p _ECL_ARGS((cl_narg narg, ...));
ecl/external.h:extern ECL_API cl_object si_string_to_object _ECL_ARGS((cl_narg narg, cl_object str, ...));
ecl/external.h:extern ECL_API cl_object cl_dribble _ECL_ARGS((cl_narg narg, ...));
ecl/external.h:extern ECL_API cl_object si_load_encoding(cl_object name);
ecl/external.h:extern ECL_API cl_object si_make_encoding(cl_object mapping);
ecl/external.h:extern ECL_API cl_object cl_union _ECL_ARGS((cl_narg narg, cl_object V1, cl_object V2, ...));
ecl/external.h:extern ECL_API cl_object cl_nunion _ECL_ARGS((cl_narg narg, cl_object V1, cl_object V2, ...));
ecl/external.h:extern ECL_API cl_object cl_intersection _ECL_ARGS((cl_narg narg, cl_object V1, cl_object V2, ...));
ecl/external.h:extern ECL_API cl_object cl_nintersection _ECL_ARGS((cl_narg narg, cl_object V1, cl_object V2, ...));
ecl/external.h:extern ECL_API cl_object cl_set_difference _ECL_ARGS((cl_narg narg, cl_object V1, cl_object V2, ...));
ecl/external.h:extern ECL_API cl_object cl_nset_difference _ECL_ARGS((cl_narg narg, cl_object V1, cl_object V2, ...));
ecl/external.h:extern ECL_API cl_object cl_set_exclusive_or _ECL_ARGS((cl_narg narg, cl_object V1, cl_object V2, ...));
ecl/external.h:extern ECL_API cl_object cl_nset_exclusive_or _ECL_ARGS((cl_narg narg, cl_object V1, cl_object V2, ...));
ecl/external.h:extern ECL_API cl_object cl_subsetp _ECL_ARGS((cl_narg narg, cl_object V1, cl_object V2, ...));
ecl/external.h:extern ECL_API cl_object cl_rassoc_if _ECL_ARGS((cl_narg narg, cl_object V1, cl_object V2, ...));
ecl/external.h:extern ECL_API cl_object cl_rassoc_if_not _ECL_ARGS((cl_narg narg, cl_object V1, cl_object V2, ...));
ecl/external.h:extern ECL_API cl_object cl_assoc_if _ECL_ARGS((cl_narg narg, cl_object V1, cl_object V2, ...));
ecl/external.h:extern ECL_API cl_object cl_assoc_if_not _ECL_ARGS((cl_narg narg, cl_object V1, cl_object V2, ...));
ecl/external.h:extern ECL_API cl_object cl_member_if _ECL_ARGS((cl_narg narg, cl_object V1, cl_object V2, ...));
ecl/external.h:extern ECL_API cl_object cl_member_if_not _ECL_ARGS((cl_narg narg, cl_object V1, cl_object V2, ...));
ecl/external.h:extern ECL_API cl_object cl_subst_if _ECL_ARGS((cl_narg narg, cl_object V1, cl_object V2, cl_object V3, ...));
ecl/external.h:extern ECL_API cl_object cl_subst_if_not _ECL_ARGS((cl_narg narg, cl_object V1, cl_object V2, cl_object V3, ...));
ecl/external.h:extern ECL_API cl_object cl_nsubst_if _ECL_ARGS((cl_narg narg, cl_object V1, cl_object V2, cl_object V3, ...));
ecl/external.h:extern ECL_API cl_object cl_nsubst_if_not _ECL_ARGS((cl_narg narg, cl_object V1, cl_object V2, cl_object V3, ...));
ecl/external.h:extern ECL_API cl_object cl_logical_pathname_translations(cl_object V1);
ecl/external.h:extern ECL_API cl_object cl_load_logical_pathname_translations(cl_object V1);
ecl/external.h:extern ECL_API cl_object cl_decode_universal_time _ECL_ARGS((cl_narg narg, cl_object V1, ...));
ecl/external.h:extern ECL_API cl_object cl_encode_universal_time _ECL_ARGS((cl_narg narg, cl_object V1, cl_object V2, cl_object V3, cl_object V4, cl_object V5, cl_object V6, ...));
ecl/external.h:extern ECL_API cl_object cl_get_decoded_time();
ecl/external.h:extern ECL_API cl_object cl_ensure_directories_exist _ECL_ARGS((cl_narg narg, cl_object V1, ...));
ecl/external.h:extern ECL_API cl_object si_simple_program_error _ECL_ARGS((cl_narg narg, cl_object format, ...)) ecl_attr_noreturn;
ecl/external.h:extern ECL_API cl_object si_signal_simple_error _ECL_ARGS((cl_narg narg, cl_object condition, cl_object continuable, cl_object format, cl_object args, ...));
ecl/external.h:extern ECL_API cl_object si_make_stream_from_fd _ECL_ARGS((cl_narg narg, cl_object fd, cl_object direction, ...));
ecl/external.h:extern ECL_API cl_object cl_provide(cl_object V1);
ecl/external.h:extern ECL_API cl_object cl_require _ECL_ARGS((cl_narg narg, cl_object V1, ...));
ecl/external.h:extern ECL_API cl_object cl_isqrt(cl_object V1);
ecl/external.h:extern ECL_API cl_object cl_phase(cl_object V1);
ecl/external.h:extern ECL_API cl_object cl_signum(cl_object V1);
ecl/external.h:extern ECL_API cl_object cl_cis(cl_object V1);
ecl/external.h:extern ECL_API cl_object cl_asin(cl_object V1);
ecl/external.h:extern ECL_API cl_object cl_acos(cl_object V1);
ecl/external.h:extern ECL_API cl_object cl_asinh(cl_object V1);
ecl/external.h:extern ECL_API cl_object cl_acosh(cl_object V1);
ecl/external.h:extern ECL_API cl_object cl_atanh(cl_object V1);
ecl/external.h:extern ECL_API cl_object cl_ffloor _ECL_ARGS((cl_narg narg, cl_object V1, ...));
ecl/external.h:extern ECL_API cl_object cl_fceiling _ECL_ARGS((cl_narg narg, cl_object V1, ...));
ecl/external.h:extern ECL_API cl_object cl_ftruncate _ECL_ARGS((cl_narg narg, cl_object V1, ...));
ecl/external.h:extern ECL_API cl_object cl_fround _ECL_ARGS((cl_narg narg, cl_object V1, ...));
ecl/external.h:extern ECL_API cl_object cl_logtest(cl_object V1, cl_object V2);
ecl/external.h:extern ECL_API cl_object cl_byte(cl_object V1, cl_object V2);
ecl/external.h:extern ECL_API cl_object cl_byte_size(cl_object V1);
ecl/external.h:extern ECL_API cl_object cl_byte_position(cl_object V1);
ecl/external.h:extern ECL_API cl_object cl_ldb(cl_object V1, cl_object V2);
ecl/external.h:extern ECL_API cl_object cl_ldb_test(cl_object V1, cl_object V2);
ecl/external.h:extern ECL_API cl_object cl_mask_field(cl_object V1, cl_object V2);
ecl/external.h:extern ECL_API cl_object cl_dpb(cl_object V1, cl_object V2, cl_object V3);
ecl/external.h:extern ECL_API cl_object cl_deposit_field(cl_object V1, cl_object V2, cl_object V3);
ecl/external.h:extern ECL_API cl_object cl_find_all_symbols(cl_object V1);
ecl/external.h:extern ECL_API cl_object cl_apropos _ECL_ARGS((cl_narg arg, cl_object V1, ...));
ecl/external.h:extern ECL_API cl_object cl_apropos_list _ECL_ARGS((cl_narg arg, cl_object V1, ...));
ecl/external.h:extern ECL_API cl_object si_subclassp _ECL_ARGS((cl_narg narg, cl_object V1, cl_object V2, ...));
ecl/external.h:extern ECL_API cl_object si_of_class_p _ECL_ARGS((cl_narg narg, cl_object V1, cl_object V2, ...));
ecl/external.h:extern ECL_API cl_object si_do_deftype _ECL_ARGS((cl_narg narg, cl_object V1, cl_object V2, cl_object V3, ...));
ecl/external.h:extern ECL_API cl_object cl_upgraded_array_element_type _ECL_ARGS((cl_narg narg, cl_object V1, ...));
ecl/external.h:extern ECL_API cl_object cl_upgraded_complex_part_type _ECL_ARGS((cl_narg narg, cl_object V1, ...));
ecl/external.h:extern ECL_API cl_object cl_typep _ECL_ARGS((cl_narg narg, cl_object V1, cl_object V2, ...));
ecl/external.h:extern ECL_API cl_object cl_coerce(cl_object V1, cl_object V2);
ecl/external.h:extern ECL_API cl_object cl_subtypep _ECL_ARGS((cl_narg narg, cl_object V1, cl_object V2, ...));
ecl/external.h:extern ECL_API cl_object si_short_float_p(cl_object t);
ecl/external.h:extern ECL_API cl_object si_single_float_p(cl_object t);
ecl/external.h:extern ECL_API cl_object si_double_float_p(cl_object t);
ecl/external.h:extern ECL_API cl_object si_long_float_p(cl_object t);
ecl/external.h:extern ECL_API cl_object si_ratiop(cl_object t);
ecl/external.h:extern ECL_API cl_object si_do_defsetf _ECL_ARGS ((cl_narg narg, cl_object name, cl_object function, ...));
ecl/external.h:extern ECL_API cl_object si_do_define_setf_method(cl_object name, cl_object function);
ecl/external.h:extern ECL_API cl_object cl_make_sequence _ECL_ARGS((cl_narg narg, cl_object V1, cl_object V2, ...));
ecl/external.h:extern ECL_API cl_object cl_concatenate _ECL_ARGS((cl_narg narg, cl_object V1, ...));
ecl/external.h:extern ECL_API cl_object cl_map _ECL_ARGS((cl_narg narg, cl_object V1, cl_object V2, cl_object V3, ...));
ecl/external.h:extern ECL_API cl_object cl_some _ECL_ARGS((cl_narg narg, cl_object V1, cl_object V2, ...));
ecl/external.h:extern ECL_API cl_object cl_every _ECL_ARGS((cl_narg narg, cl_object V1, cl_object V2, ...));
ecl/external.h:extern ECL_API cl_object cl_notany _ECL_ARGS((cl_narg narg, cl_object V1, cl_object V2, ...));
ecl/external.h:extern ECL_API cl_object cl_notevery _ECL_ARGS((cl_narg narg, cl_object V1, cl_object V2, ...));
ecl/external.h:extern ECL_API cl_object cl_map_into _ECL_ARGS((cl_narg narg, cl_object V1, cl_object V2, ...));
ecl/external.h:extern ECL_API cl_object si_sequence_count(cl_object count);
ecl/external.h:extern ECL_API cl_object cl_reduce _ECL_ARGS((cl_narg narg, cl_object V1, cl_object V2, ...));
ecl/external.h:extern ECL_API cl_object cl_fill _ECL_ARGS((cl_narg narg, cl_object V1, cl_object V2, ...));
ecl/external.h:extern ECL_API cl_object cl_replace _ECL_ARGS((cl_narg narg, cl_object V1, cl_object V2, ...));
ecl/external.h:extern ECL_API cl_object cl_remove _ECL_ARGS((cl_narg narg, cl_object V1, cl_object V2, ...));
ecl/external.h:extern ECL_API cl_object cl_remove_if _ECL_ARGS((cl_narg narg, cl_object V1, cl_object V2, ...));
ecl/external.h:extern ECL_API cl_object cl_remove_if_not _ECL_ARGS((cl_narg narg, cl_object V1, cl_object V2, ...));
ecl/external.h:extern ECL_API cl_object cl_delete _ECL_ARGS((cl_narg narg, cl_object V1, cl_object V2, ...));
ecl/external.h:extern ECL_API cl_object cl_delete_if _ECL_ARGS((cl_narg narg, cl_object V1, cl_object V2, ...));
ecl/external.h:extern ECL_API cl_object cl_delete_if_not _ECL_ARGS((cl_narg narg, cl_object V1, cl_object V2, ...));
ecl/external.h:extern ECL_API cl_object cl_count _ECL_ARGS((cl_narg narg, cl_object V1, cl_object V2, ...));
ecl/external.h:extern ECL_API cl_object cl_count_if _ECL_ARGS((cl_narg narg, cl_object V1, cl_object V2, ...));
ecl/external.h:extern ECL_API cl_object cl_count_if_not _ECL_ARGS((cl_narg narg, cl_object V1, cl_object V2, ...));
ecl/external.h:extern ECL_API cl_object cl_substitute _ECL_ARGS((cl_narg narg, cl_object V1, cl_object V2, cl_object V3, ...));
ecl/external.h:extern ECL_API cl_object cl_substitute_if _ECL_ARGS((cl_narg narg, cl_object V1, cl_object V2, cl_object V3, ...));
ecl/external.h:extern ECL_API cl_object cl_substitute_if_not _ECL_ARGS((cl_narg narg, cl_object V1, cl_object V2, cl_object V3, ...));
ecl/external.h:extern ECL_API cl_object cl_nsubstitute _ECL_ARGS((cl_narg narg, cl_object V1, cl_object V2, cl_object V3, ...));
ecl/external.h:extern ECL_API cl_object cl_nsubstitute_if _ECL_ARGS((cl_narg narg, cl_object V1, cl_object V2, cl_object V3, ...));
ecl/external.h:extern ECL_API cl_object cl_nsubstitute_if_not _ECL_ARGS((cl_narg narg, cl_object V1, cl_object V2, cl_object V3, ...));
ecl/external.h:extern ECL_API cl_object cl_find _ECL_ARGS((cl_narg narg, cl_object V1, cl_object V2, ...));
ecl/external.h:extern ECL_API cl_object cl_find_if _ECL_ARGS((cl_narg narg, cl_object V1, cl_object V2, ...));
ecl/external.h:extern ECL_API cl_object cl_find_if_not _ECL_ARGS((cl_narg narg, cl_object V1, cl_object V2, ...));
ecl/external.h:extern ECL_API cl_object cl_position _ECL_ARGS((cl_narg narg, cl_object V1, cl_object V2, ...));
ecl/external.h:extern ECL_API cl_object cl_position_if _ECL_ARGS((cl_narg narg, cl_object V1, cl_object V2, ...));
ecl/external.h:extern ECL_API cl_object cl_position_if_not _ECL_ARGS((cl_narg narg, cl_object V1, cl_object V2, ...));
ecl/external.h:extern ECL_API cl_object cl_remove_duplicates _ECL_ARGS((cl_narg narg, cl_object V1, ...));
ecl/external.h:extern ECL_API cl_object cl_delete_duplicates _ECL_ARGS((cl_narg narg, cl_object V1, ...));
ecl/external.h:extern ECL_API cl_object cl_mismatch _ECL_ARGS((cl_narg narg, cl_object V1, cl_object V2, ...));
ecl/external.h:extern ECL_API cl_object cl_search _ECL_ARGS((cl_narg narg, cl_object V1, cl_object V2, ...));
ecl/external.h:extern ECL_API cl_object cl_sort _ECL_ARGS((cl_narg narg, cl_object V1, cl_object V2, ...));
ecl/external.h:extern ECL_API cl_object cl_stable_sort _ECL_ARGS((cl_narg narg, cl_object V1, cl_object V2, ...));
ecl/external.h:extern ECL_API cl_object cl_merge _ECL_ARGS((cl_narg narg, cl_object V1, cl_object V2, cl_object V3, cl_object V4, ...));
ecl/external.h:extern ECL_API cl_object cl_constantly(cl_object V1);
ecl/external.h:extern ECL_API cl_object cl_complement(cl_object V1);
ecl/external.h:extern ECL_API cl_object si_traced_old_definition(cl_object V1);
ecl/external.h:extern ECL_API cl_object cl_pprint_newline _ECL_ARGS((cl_narg narg, cl_object V1, ...));
ecl/external.h:extern ECL_API cl_object cl_pprint_indent _ECL_ARGS((cl_narg narg, cl_object V1, cl_object V2, ...));
ecl/external.h:extern ECL_API cl_object cl_pprint_tab _ECL_ARGS((cl_narg narg, cl_object V1, cl_object V2, cl_object V3, ...));
ecl/external.h:extern ECL_API cl_object cl_pprint_fill _ECL_ARGS((cl_narg narg, cl_object V1, cl_object V2, ...));
ecl/external.h:extern ECL_API cl_object cl_pprint_linear _ECL_ARGS((cl_narg narg, cl_object V1, cl_object V2, ...));
ecl/external.h:extern ECL_API cl_object cl_pprint_tabular _ECL_ARGS((cl_narg narg, cl_object V1, cl_object V2, ...));
ecl/external.h:extern ECL_API cl_object cl_copy_pprint_dispatch _ECL_ARGS((cl_narg narg, ...));
ecl/external.h:extern ECL_API cl_object cl_pprint_dispatch _ECL_ARGS((cl_narg narg, cl_object V1, ...));
ecl/external.h:extern ECL_API cl_object cl_set_pprint_dispatch _ECL_ARGS((cl_narg narg, cl_object V1, cl_object V2, ...));
ecl/external.h:extern ECL_API cl_object cl_method_combination_error _ECL_ARGS((cl_narg narg, cl_object format, ...));
ecl/external.h:extern ECL_API cl_object cl_invalid_method_error _ECL_ARGS((cl_narg narg, cl_object method, cl_object format, ...));
ecl/external.h:extern ECL_API cl_object clos_std_compute_applicable_methods(cl_object gf, cl_object arglist);
ecl/external.h:extern ECL_API cl_object clos_std_compute_effective_method(cl_object gf, cl_object combination, cl_object methods_list);
ecl/external.h:extern ECL_API cl_object clos_compute_effective_method_function(cl_object gf, cl_object combination, cl_object methods_list);
ecl/external.h:extern ECL_API cl_object cl_slot_boundp(cl_object object, cl_object slot);
ecl/external.h:extern ECL_API cl_object cl_slot_makunbound(cl_object object, cl_object slot);
ecl/external.h:extern ECL_API cl_object cl_slot_exists_p(cl_object object, cl_object slot);
ecl/external.h:extern ECL_API cl_object clos_load_defclass(cl_object name, cl_object superclasses, cl_object slots, cl_object options);
ecl/external.h:extern ECL_API cl_object clos_ensure_class _ECL_ARGS((cl_narg narg, cl_object V1, ...));
ecl/external.h:extern ECL_API cl_object clos_class_id _ECL_ARGS((cl_narg narg, cl_object V1, ...));
ecl/external.h:extern ECL_API cl_object clos_class_direct_superclasses _ECL_ARGS((cl_narg narg, cl_object V1, ...));
ecl/external.h:extern ECL_API cl_object clos_class_direct_subclasses _ECL_ARGS((cl_narg narg, cl_object V1, ...));
ecl/external.h:extern ECL_API cl_object clos_class_slots _ECL_ARGS((cl_narg narg, cl_object V1, ...));
ecl/external.h:extern ECL_API cl_object clos_class_precedence_list _ECL_ARGS((cl_narg narg, cl_object V1, ...));
ecl/external.h:extern ECL_API cl_object clos_class_direct_slots _ECL_ARGS((cl_narg narg, cl_object V1, ...));
ecl/external.h:extern ECL_API cl_object clos_slot_index_table _ECL_ARGS((cl_narg narg, cl_object V1, ...));
ecl/external.h:extern ECL_API cl_object clos_class_shared_slots _ECL_ARGS((cl_narg narg, cl_object V1, ...));
ecl/external.h:extern ECL_API cl_object clos_generic_function_method_combination _ECL_ARGS((cl_narg narg, cl_object V1, ...));
ecl/external.h:extern ECL_API cl_object clos_generic_function_lambda_list _ECL_ARGS((cl_narg narg, cl_object V1, ...));
ecl/external.h:extern ECL_API cl_object clos_generic_function_argument_precedence_order _ECL_ARGS((cl_narg narg, cl_object V1, ...));
ecl/external.h:extern ECL_API cl_object clos_generic_function_method_class _ECL_ARGS((cl_narg narg, cl_object V1, ...));
ecl/external.h:extern ECL_API cl_object clos_generic_function_methods _ECL_ARGS((cl_narg narg, cl_object V1, ...));
ecl/external.h:extern ECL_API cl_object clos_method_generic_function _ECL_ARGS((cl_narg narg, cl_object V1, ...));
ecl/external.h:extern ECL_API cl_object clos_method_lambda_list _ECL_ARGS((cl_narg narg, cl_object V1, ...));
ecl/external.h:extern ECL_API cl_object clos_method_specializers _ECL_ARGS((cl_narg narg, cl_object V1, ...));
ecl/external.h:extern ECL_API cl_object cl_method_qualifiers _ECL_ARGS((cl_narg narg, cl_object V1, ...));
ecl/external.h:extern ECL_API cl_object clos_method_function _ECL_ARGS((cl_narg narg, cl_object V1, ...));
ecl/external.h:extern ECL_API cl_object clos_method_plist _ECL_ARGS((cl_narg narg, cl_object V1, ...));
ecl/external.h:extern ECL_API cl_object clos_install_method _ECL_ARGS((cl_narg narg, cl_object V1, cl_object V2, cl_object V3, cl_object V4, cl_object V5, ...));
ecl/external.h:extern ECL_API cl_object cl_slot_value(cl_object object, cl_object slot);
ecl/external.h:extern ECL_API cl_object clos_slot_value_set(cl_object value, cl_object instance, cl_object name);
ecl/external.h:extern ECL_API cl_object clos_standard_instance_access(cl_object object, cl_object location);
ecl/external.h:extern ECL_API cl_object clos_standard_instance_set(cl_object object, cl_object location, cl_object value);
ecl/external.h:extern ECL_API cl_object clos_extract_lambda_list(cl_object object);
ecl/external.h:extern ECL_API cl_object clos_extract_specializer_names(cl_object object);
ecl/external.h:extern ECL_API cl_object cl_abort _ECL_ARGS((cl_narg narg, ...));
ecl/external.h:extern ECL_API cl_object cl_continue _ECL_ARGS((cl_narg narg, ...));
ecl/external.h:extern ECL_API cl_object cl_compute_restarts _ECL_ARGS((cl_narg narg, ...));
ecl/external.h:extern ECL_API cl_object cl_find_restart _ECL_ARGS((cl_narg narg, cl_object name, ...));
ecl/external.h:extern ECL_API cl_object cl_invoke_restart _ECL_ARGS((cl_narg narg, cl_object restart, ...));
ecl/external.h:extern ECL_API cl_object cl_invoke_restart_interactively(cl_object restart);
ecl/external.h:extern ECL_API cl_object cl_make_condition _ECL_ARGS((cl_narg narg, cl_object type, ...));
ecl/external.h:extern ECL_API cl_object cl_muffle_warning _ECL_ARGS((cl_narg narg, ...));
ecl/external.h:extern ECL_API cl_object cl_store_value _ECL_ARGS((cl_narg narg, cl_object value, ...));
ecl/external.h:extern ECL_API cl_object cl_use_value _ECL_ARGS((cl_narg narg, cl_object value, ...));
ecl/external.h:extern ECL_API cl_object si_bind_simple_restarts(cl_object tag, cl_object names);
ecl/external.h:extern ECL_API cl_object si_bind_simple_handlers(cl_object tag, cl_object names);
ecl/external.h:extern ECL_API cl_object si_assert_failure _ECL_ARGS((cl_narg narg, cl_object V1, ...));
ecl/external.h:extern ECL_API cl_object si_wrong_type_argument _ECL_ARGS((cl_narg narg, cl_object value, cl_object type, ...));
ecl/external.h:extern ECL_API cl_object si_ccase_error(cl_object keyform, cl_object key, cl_object values);
ecl/external.h:extern ECL_API cl_object si_ecase_error(cl_object value, cl_object values) ecl_attr_noreturn;
ecl/external.h:extern ECL_API cl_object si_etypecase_error(cl_object value, cl_object type) ecl_attr_noreturn;
ecl/external.h:extern ECL_API cl_object si_ctypecase_error(cl_object keyplace, cl_object value, cl_object type);
ecl/external.h:extern ECL_API cl_object si_do_check_type(cl_object value, cl_object type, cl_object type_string, cl_object place);
ecl/external.h:extern ECL_API cl_object si_negative_fixnum_p(cl_object);
ecl/external.h:extern ECL_API cl_object si_non_negative_fixnum_p(cl_object);
ecl/external.h:extern ECL_API cl_object si_non_positive_fixnum_p(cl_object);
ecl/external.h:extern ECL_API cl_object si_positive_fixnum_p(cl_object);
ecl/external.h:extern ECL_API cl_object si_array_index_p(cl_object);
ecl/external.h:extern ECL_API cl_object si_negative_integer_p(cl_object);
ecl/external.h:extern ECL_API cl_object si_non_negative_integer_p(cl_object);
ecl/external.h:extern ECL_API cl_object si_non_positive_integer_p(cl_object);
ecl/external.h:extern ECL_API cl_object si_positive_integer_p(cl_object);
ecl/external.h:extern ECL_API cl_object si_negative_rational_p(cl_object);
ecl/external.h:extern ECL_API cl_object si_non_negative_rational_p(cl_object);
ecl/external.h:extern ECL_API cl_object si_non_positive_rational_p(cl_object);
ecl/external.h:extern ECL_API cl_object si_positive_rational_p(cl_object);
ecl/external.h:extern ECL_API cl_object si_negative_ratio_p(cl_object);
ecl/external.h:extern ECL_API cl_object si_non_negative_ratio_p(cl_object);
ecl/external.h:extern ECL_API cl_object si_non_positive_ratio_p(cl_object);
ecl/external.h:extern ECL_API cl_object si_positive_ratio_p(cl_object);
ecl/external.h:extern ECL_API cl_object si_negative_real_p(cl_object);
ecl/external.h:extern ECL_API cl_object si_non_negative_real_p(cl_object);
ecl/external.h:extern ECL_API cl_object si_non_positive_real_p(cl_object);
ecl/external.h:extern ECL_API cl_object si_positive_real_p(cl_object);
ecl/external.h:extern ECL_API cl_object si_negative_float_p(cl_object);
ecl/external.h:extern ECL_API cl_object si_non_negative_float_p(cl_object);
ecl/external.h:extern ECL_API cl_object si_non_positive_float_p(cl_object);
ecl/external.h:extern ECL_API cl_object si_positive_float_p(cl_object);
ecl/external.h:extern ECL_API cl_object si_negative_short_float_p(cl_object);
ecl/external.h:extern ECL_API cl_object si_non_negative_short_float_p(cl_object);
ecl/external.h:extern ECL_API cl_object si_non_positive_short_float_p(cl_object);
ecl/external.h:extern ECL_API cl_object si_positive_short_float_p(cl_object);
ecl/external.h:extern ECL_API cl_object si_negative_single_float_p(cl_object);
ecl/external.h:extern ECL_API cl_object si_non_negative_single_float_p(cl_object);
ecl/external.h:extern ECL_API cl_object si_non_positive_single_float_p(cl_object);
ecl/external.h:extern ECL_API cl_object si_positive_single_float_p(cl_object);
ecl/external.h:extern ECL_API cl_object si_negative_double_float_p(cl_object);
ecl/external.h:extern ECL_API cl_object si_non_negative_double_float_p(cl_object);
ecl/external.h:extern ECL_API cl_object si_non_positive_double_float_p(cl_object);
ecl/external.h:extern ECL_API cl_object si_positive_double_float_p(cl_object);
ecl/external.h:extern ECL_API cl_object si_negative_long_float_p(cl_object);
ecl/external.h:extern ECL_API cl_object si_non_negative_long_float_p(cl_object);
ecl/external.h:extern ECL_API cl_object si_non_positive_long_float_p(cl_object);
ecl/external.h:extern ECL_API cl_object si_positive_long_float_p(cl_object);
ecl/impl/math_dispatch.h:typedef cl_object (*math_one_arg_fn)(cl_object);
ecl/impl/math_dispatch.h:    static cl_object name##failed(cl_object x) {                        \
ecl/impl/math_dispatch.h:    cl_object ecl_##name(cl_object arg)                                 \
ecl/impl/math_dispatch.h:    cl_object ecl_##name(cl_object arg)                                 \
ecl/impl/math_dispatch.h:        cl_object out;                                                  \
ecl/impl/math_dispatch.h:typedef int (*math_one_arg_bool_fn)(cl_object);
ecl/impl/math_dispatch.h:    static int name##failed(cl_object x) {                              \
ecl/impl/math_dispatch.h:    int ecl_##name(cl_object arg)                                       \
ecl/internal.h:extern void init_lib_LSP(cl_object);
ecl/internal.h:extern cl_object ecl_alloc_bytecodes(cl_index data_size, cl_index code_size);
ecl/internal.h:extern cl_index ecl_object_byte_size(cl_type t);
ecl/internal.h:  sizeof(cl_object),          /* ecl_aet_object */
ecl/internal.h:extern void ecl_displace(cl_object from, cl_object to, cl_object offset);
ecl/internal.h:        cl_object variables;            /* Variables, tags, functions, etc: the env. */
ecl/internal.h:        cl_object macros;               /* Macros and function bindings */
ecl/internal.h:        cl_object constants;            /* Constants for this form */
ecl/internal.h:        cl_object load_time_forms;      /* Constants that have to be rebuilt */
ecl/internal.h:        cl_object ltf_being_created;    /* Load time objects being compiled */
ecl/internal.h:        cl_object ltf_defer_init_until; /* Defer evaluation of current
ecl/internal.h:        cl_object ltf_locations;        /* Locations of constants externalized
ecl/internal.h:        cl_object lex_env;              /* Lexical env. for eval-when */
ecl/internal.h:        cl_object code_walker;          /* Value of SI:*CODE-WALKER* */
ecl/internal.h:extern cl_object _ecl_strerror(int code);
ecl/internal.h:extern ECL_API cl_object si_serror _ECL_ARGS
ecl/internal.h:((cl_narg narg, cl_object cformat, cl_object eformat, ...));
ecl/internal.h:extern cl_object si_constantp_inner _ECL_ARGS((cl_narg narg, cl_object form, ...));
ecl/internal.h:extern cl_object si_constant_form_value _ECL_ARGS((cl_narg narg, cl_object form, ...));
ecl/internal.h:        cl_object name = ecl_stack_frame_open(env, (cl_object)&frame, 0);
ecl/internal.h:                const cl_object __frame = (f);                          \
ecl/internal.h:        const cl_object frame = (cl_object)&__ecl_frame;                \
ecl/internal.h:                cl_object *p = frame->frame.base = env->values;         \
ecl/internal.h:                        *p = va_arg(args, cl_object);                   \
ecl/internal.h:                frame->frame.stack = (cl_object*)0x1;                   \
ecl/internal.h:extern cl_object _ecl_bytecodes_dispatch_vararg(cl_narg narg, ...);
ecl/internal.h:extern cl_object _ecl_bclosure_dispatch_vararg(cl_narg narg, ...);
ecl/internal.h:extern cl_object ecl_close_around(cl_object fun, cl_object env);
ecl/internal.h:extern enum ecl_ffi_tag ecl_foreign_type_code(cl_object type);
ecl/internal.h:extern cl_object ecl_off_t_to_integer(ecl_off_t offset);
ecl/internal.h:extern ecl_off_t ecl_integer_to_off_t(cl_object offset);
ecl/internal.h:extern cl_object si_formatter_aux _ECL_ARGS((cl_narg narg, cl_object strm, cl_object string, ...));
ecl/internal.h:extern cl_object ecl_extend_hashtable(cl_object hashtable);
ecl/internal.h:extern void ecl_reconstruct_serialized_hashtable(cl_object h);
ecl/internal.h:extern cl_object FEnot_funcallable_vararg(cl_narg narg, ...);
ecl/internal.h:extern cl_object ecl_slot_reader_dispatch(cl_narg narg, ... /* cl_object instance */);
ecl/internal.h:extern cl_object ecl_slot_writer_dispatch(cl_narg narg, ... /* cl_object value, cl_object instance */);
ecl/internal.h:extern cl_object _ecl_library_init_prefix(void);
ecl/internal.h:extern cl_object _ecl_library_default_entry(void);
ecl/internal.h:extern cl_object _ecl_double_to_integer(double d);
ecl/internal.h:extern cl_object _ecl_float_to_integer(float d);
ecl/internal.h:extern cl_object _ecl_long_double_to_integer(long double d);
ecl/internal.h:extern cl_object _ecl_stream_or_default_output(cl_object stream);
ecl/internal.h:extern void _ecl_write_addr(void *x, cl_object stream);
ecl/internal.h:extern void _ecl_write_array(cl_object o, cl_object stream);
ecl/internal.h:extern void _ecl_write_vector(cl_object o, cl_object stream);
ecl/internal.h:extern void _ecl_write_bitvector(cl_object o, cl_object stream);
ecl/internal.h:extern void _ecl_write_string(cl_object o, cl_object stream);
ecl/internal.h:extern void _ecl_write_base_string(cl_object o, cl_object stream);
ecl/internal.h:extern void _ecl_write_list(cl_object o, cl_object stream);
ecl/internal.h:extern void _ecl_write_bclosure(cl_object o, cl_object stream);
ecl/internal.h:extern void _ecl_write_bytecodes(cl_object o, cl_object stream);
ecl/internal.h:extern void _ecl_write_symbol(cl_object o, cl_object stream);
ecl/internal.h:extern void _ecl_write_fixnum(cl_fixnum o, cl_object stream);
ecl/internal.h:extern void _ecl_write_sse(cl_object o, cl_object stream);
ecl/internal.h:extern void _ecl_write_unreadable(cl_object x, const char *prefix, cl_object name, cl_object stream);
ecl/internal.h:extern bool _ecl_will_print_as_hash(cl_object o);
ecl/internal.h:extern cl_object _ecl_ensure_buffer(cl_object buffer, cl_fixnum length);
ecl/internal.h:extern void _ecl_string_push_c_string(cl_object s, const char *c);
ecl/internal.h:extern void cl_write_object(cl_object x, cl_object stream);
ecl/internal.h:        const cl_object __ecl_the_lock = lock;           \
ecl/internal.h:        cl_object *__ecl_the_lock = (lock);              \
ecl/internal.h:extern cl_object si_make_backq_vector(cl_object dim, cl_object data, cl_object stream);
ecl/internal.h:extern cl_object _ecl_package_to_be_created(const cl_env_ptr env, cl_object name);
ecl/internal.h:extern bool ecl_wild_string_p(cl_object item);
ecl/internal.h:extern ECL_API cl_index_pair ecl_sequence_start_end(cl_object fun, cl_object s, cl_object start, cl_object end);
ecl/internal.h:extern cl_object ecl_deserialize(uint8_t *data);
ecl/internal.h:extern ECL_API cl_object mp_suspend_loop();
ecl/internal.h:extern ECL_API cl_object mp_break_suspend_loop();
ecl/internal.h:typedef cl_object (*mp_wait_test)(cl_env_ptr, cl_object);
ecl/internal.h:extern void print_lock(char *s, cl_object lock, ...);
ecl/internal.h:extern void ecl_get_spinlock(cl_env_ptr env, cl_object *lock);
ecl/internal.h:extern void ecl_giveup_spinlock(cl_object *lock);
ecl/internal.h:extern cl_object ecl_wait_on(cl_env_ptr env, mp_wait_test test, cl_object object);
ecl/internal.h:extern void ecl_wakeup_waiters(cl_env_ptr the_env, cl_object o, int flags);
ecl/internal.h:extern void ecl_wakeup_process(cl_object process);
ecl/internal.h:extern cl_object ecl_waiter_pop(cl_env_ptr the_env, cl_object q);
ecl/internal.h:extern cl_object mp_get_rwlock_read_wait(cl_object lock);
ecl/internal.h:extern cl_object mp_get_rwlock_write_wait(cl_object lock);
ecl/internal.h:extern void ecl_interrupt_process(cl_object process, cl_object function);
ecl/number.h:        const cl_object name = (name##aux.big_num->_mp_alloc = n,       \
ecl/number.h:                                (cl_object)(&name##aux))
ecl/number.h:extern ECL_API cl_object _ecl_big_set_fixnum(cl_object x, cl_fixnum f);
ecl/number.h:extern ECL_API cl_object _ecl_big_set_index(cl_object x, cl_index f);
ecl/number.h:extern ECL_API cl_fixnum _ecl_big_get_fixnum(cl_object x);
ecl/number.h:extern ECL_API cl_index _ecl_big_get_index(cl_object x);
ecl/number.h:extern ECL_API long double _ecl_big_to_long_double(cl_object x);
ecl/number.h:typedef void (*_ecl_big_binary_op)(cl_object out, cl_object o1, cl_object o2);
ecl/number.h:ecl_to_fix(cl_object f)
ecl/number.h:ecl_to_size(cl_object f)
ecl/number.h:extern ECL_API cl_fixnum ecl_fixnum_value(cl_object f);
ecl/number.h:extern ECL_API cl_index ecl_to_size(cl_object f);
ecl/object.h:typedef union cl_lispunion *cl_object;
ecl/object.h:typedef cl_object cl_return;
ecl/object.h:typedef cl_object (*cl_objectfn)(cl_narg narg, ...);
ecl/object.h:typedef cl_object (*cl_objectfn_fixed)();
ecl/object.h:#define OBJNULL         ((cl_object)NULL)
ecl/object.h:#define ecl_make_fixnum(n)      ((cl_object)(((cl_fixnum)(n) << 2) | t_fixnum))
ecl/object.h:#define ECL_CODE_CHAR(c)        ((cl_object)(((cl_fixnum)(c << 2)|ECL_CHARACTER_TAG)))
ecl/object.h:#define ECL_CODE_CHAR(c)        ((cl_object)(((cl_fixnum)((c & 0xff) << 2)|ECL_CHARACTER_TAG)))
ecl/object.h:        cl_object den;          /*  denominator, must be an integer  */
ecl/object.h:        cl_object num;          /*  numerator, must be an integer  */
ecl/object.h:        cl_object real;         /*  real part, must be a number  */
ecl/object.h:        cl_object imag;         /*  imaginary part, must be a number  */
ecl/object.h:#define ECL_NIL                 ((cl_object)t_list)
ecl/object.h:#define ECL_NIL_SYMBOL          ((cl_object)cl_symbols)
ecl/object.h:#define ECL_T                   ((cl_object)(cl_symbols+1))
ecl/object.h:#define ECL_UNBOUND             ((cl_object)(cl_symbols+2))
ecl/object.h:#define ECL_PROTECT_TAG         ((cl_object)(cl_symbols+3))
ecl/object.h:#define ECL_DUMMY_TAG           ((cl_object)(cl_symbols+4))
ecl/object.h:#define ECL_RESTART_CLUSTERS    ((cl_object)(cl_symbols+5))
ecl/object.h:#define ECL_HANDLER_CLUSTERS    ((cl_object)(cl_symbols+6))
ecl/object.h:#define ECL_INTERRUPTS_ENABLED  ((cl_object)(cl_symbols+7))
ecl/object.h:#define ECL_NO_TL_BINDING       ((cl_object)(1 << ECL_TAG_BITS))
ecl/object.h:        cl_object value;        /*  global value of the symbol  */
ecl/object.h:        cl_object gfdef;        /*  global function definition  */
ecl/object.h:        cl_object plist;        /*  property list  */
ecl/object.h:        cl_object name;         /*  print name  */
ecl/object.h:        cl_object cname;        /*  associated C name (or NIL)  */
ecl/object.h:        cl_object hpack;        /*  home package  */
ecl/object.h:        cl_object name;            /*  package name, a string  */
ecl/object.h:        cl_object nicknames;       /*  nicknames, list of strings  */
ecl/object.h:        cl_object local_nicknames; /*  local nicknames, assoc list */
ecl/object.h:        cl_object nicknamedby;  /*  nicknamed-by-list of packages */
ecl/object.h:        cl_object shadowings;   /*  shadowing symbol list  */
ecl/object.h:        cl_object uses;         /*  use-list of packages  */
ecl/object.h:        cl_object usedby;       /*  used-by-list of packages  */
ecl/object.h:        cl_object internal;     /*  hashtable for internal symbols  */
ecl/object.h:        cl_object external;     /*  hashtable for external symbols  */
ecl/object.h:#define ECL_PTR_CONS(x) (cl_object)((char*)(x) + t_list)
ecl/object.h:#define ECL_CONS_CAR(x) (*(cl_object*)((char *)(x) - t_list))
ecl/object.h:#define ECL_CONS_CDR(x) (*(cl_object*)((char *)(x) + sizeof(cl_object) - t_list))
ecl/object.h:        cl_object car;          /*  car  */
ecl/object.h:        cl_object cdr;          /*  cdr  */
ecl/object.h:        cl_object car;          /*  car  */
ecl/object.h:        cl_object cdr;          /*  cdr  */
ecl/object.h:        cl_object key;          /*  key  */
ecl/object.h:        cl_object value;        /*  value  */
ecl/object.h:        cl_object sync_lock;              /*  synchronization lock  */
ecl/object.h:        cl_object generic_test;           /*  generic test function */
ecl/object.h:        cl_object generic_hash;           /*  generic hashing function */
ecl/object.h:        cl_object rehash_size;  /*  rehash size  */
ecl/object.h:        cl_object threshold;    /*  rehash threshold  */
ecl/object.h:        cl_object (*get)(cl_object, cl_object, cl_object);
ecl/object.h:        cl_object (*set)(cl_object, cl_object, cl_object);
ecl/object.h:        bool (*rem)(cl_object, cl_object);
ecl/object.h:        cl_object (*get_unsafe)(cl_object, cl_object, cl_object);
ecl/object.h:        cl_object (*set_unsafe)(cl_object, cl_object, cl_object);
ecl/object.h:        bool (*rem_unsafe)(cl_object, cl_object);
ecl/object.h:        cl_object     *t;
ecl/object.h:        cl_object displaced;    /*  displaced  */
ecl/object.h:        cl_object displaced;    /*  displaced  */
ecl/object.h:        cl_object displaced;    /*  displaced  */
ecl/object.h:        cl_object displaced;    /*  displaced  */
ecl/object.h:        cl_index (*write_byte8)(cl_object strm, unsigned char *c, cl_index n);
ecl/object.h:        cl_index (*read_byte8)(cl_object strm, unsigned char *c, cl_index n);
ecl/object.h:        void (*write_byte)(cl_object c, cl_object strm);
ecl/object.h:        cl_object (*read_byte)(cl_object strm);
ecl/object.h:        int (*read_char)(cl_object strm);
ecl/object.h:        int (*write_char)(cl_object strm, int c);
ecl/object.h:        void (*unread_char)(cl_object strm, int c);
ecl/object.h:        int (*peek_char)(cl_object strm);
ecl/object.h:        cl_index (*read_vector)(cl_object strm, cl_object data, cl_index start, cl_index end);
ecl/object.h:        cl_index (*write_vector)(cl_object strm, cl_object data, cl_index start, cl_index end);
ecl/object.h:        int (*listen)(cl_object strm);
ecl/object.h:        void (*clear_input)(cl_object strm);
ecl/object.h:        void (*clear_output)(cl_object strm);
ecl/object.h:        void (*finish_output)(cl_object strm);
ecl/object.h:        void (*force_output)(cl_object strm);
ecl/object.h:        int (*input_p)(cl_object strm);
ecl/object.h:        int (*output_p)(cl_object strm);
ecl/object.h:        int (*interactive_p)(cl_object strm);
ecl/object.h:        cl_object (*element_type)(cl_object strm);
ecl/object.h:        cl_object (*length)(cl_object strm);
ecl/object.h:        cl_object (*get_position)(cl_object strm);
ecl/object.h:        cl_object (*set_position)(cl_object strm, cl_object pos);
ecl/object.h:        int (*column)(cl_object strm);
ecl/object.h:        cl_object (*close)(cl_object strm);
ecl/object.h:typedef ecl_character (*cl_eformat_decoder)(cl_object stream, unsigned char **buffer, unsigned char *buffer_end);
ecl/object.h:typedef int (*cl_eformat_encoder)(cl_object stream, unsigned char *buffer, ecl_character c);
ecl/object.h:        cl_object object0;      /*  some object  */
ecl/object.h:        cl_object object1;      /*  some object */
ecl/object.h:        cl_object byte_stack;   /*  buffer for unread bytes  */
ecl/object.h:        cl_object format;       /*  external format  */
ecl/object.h:        cl_object format_table;
ecl/object.h:        cl_object value;        /*  random state value  */
ecl/object.h:        cl_object dispatch;             /*  a macro, a hash or NIL  */
ecl/object.h:        cl_object hash;         /* hash for values outside base-char range */
ecl/object.h:        cl_object host;         /*  host  */
ecl/object.h:        cl_object device;       /*  device  */
ecl/object.h:        cl_object directory;    /*  directory  */
ecl/object.h:        cl_object name;         /*  name  */
ecl/object.h:        cl_object type;         /*  type  */
ecl/object.h:        cl_object version;      /*  version  */
ecl/object.h:        cl_object *data;                /*  data vector  */
ecl/object.h:        cl_object *temp_data;           /*  data vector for toplevel forms */
ecl/object.h:        const cl_object *data_text;     /*  strings with objects to be defined  */
ecl/object.h:        cl_object next;                 /*  next codeblock within same library */
ecl/object.h:        cl_object name;
ecl/object.h:        cl_object links;                /*  list of symbols with linking calls  */
ecl/object.h:        cl_object source;               /*  common debug information for this block  */
ecl/object.h:        cl_object refs;                 /*  reference counter for the library  */
ecl/object.h:        cl_object error;                /*  error message when loading */
ecl/object.h:        cl_object name;         /*  function name  */
ecl/object.h:        cl_object definition;   /*  function definition in list form  */
ecl/object.h:        cl_objectfn entry;      /*  entry address (must match the position of
ecl/object.h:        cl_object data;         /*  non-inmediate constants used in the code  */
ecl/object.h:        cl_object file;         /*  file where it was defined...  */
ecl/object.h:        cl_object file_position;/*  and where it was created  */
ecl/object.h:        cl_object code;
ecl/object.h:        cl_object lex;
ecl/object.h:        cl_objectfn entry;      /*  entry address  */
ecl/object.h:        cl_object name;         /*  compiled function name  */
ecl/object.h:        cl_object block;        /*  descriptor of C code block for GC  */
ecl/object.h:        cl_objectfn entry;      /*  entry address  */
ecl/object.h:        cl_objectfn entry_variadic;
ecl/object.h:        cl_object file;         /*  file where it was defined...  */
ecl/object.h:        cl_object file_position;/*  and where it was created  */
ecl/object.h:        cl_object name;         /*  compiled function name  */
ecl/object.h:        cl_object block;        /*  descriptor of C code block for GC  */
ecl/object.h:        cl_objectfn entry;      /*  entry address (must match the position of
ecl/object.h:        cl_objectfn_fixed entry_fixed;  /*  entry address  */
ecl/object.h:        cl_object file;         /*  file where it was defined...  */
ecl/object.h:        cl_object file_position;/*  and where it was created  */
ecl/object.h:        cl_object env;          /*  environment  */
ecl/object.h:        cl_object block;        /*  descriptor of C code block for GC  */
ecl/object.h:        cl_objectfn entry;      /*  entry address (must match the position of
ecl/object.h:        cl_objectfn entry_variadic; /* see struct ecl_cfun above */
ecl/object.h:        cl_object file;         /*  file where it was defined...  */
ecl/object.h:        cl_object file_position;/*  and where it was created  */
ecl/object.h:        cl_object o;
ecl/object.h:        cl_object tag;          /*  a tag identifying the type  */
ecl/object.h:        cl_object *stack;       /*  Is this relative to the lisp stack?  */
ecl/object.h:        cl_object *base;        /*  Start of frame  */
ecl/object.h:        cl_object value;
ecl/object.h:        cl_object name;
ecl/object.h:        cl_object function;
ecl/object.h:        cl_object args;
ecl/object.h:        cl_object interrupt;
ecl/object.h:        cl_object initial_bindings;
ecl/object.h:        cl_object parent;
ecl/object.h:        cl_object exit_barrier;
ecl/object.h:        cl_object exit_values;
ecl/object.h:        cl_object woken_up;
ecl/object.h:        cl_object queue_record;
ecl/object.h:        cl_object start_stop_spinlock;
ecl/object.h:        cl_object list;
ecl/object.h:        cl_object spinlock;
ecl/object.h:        cl_object queue_list;
ecl/object.h:        cl_object queue_spinlock;
ecl/object.h:        cl_object name;
ecl/object.h:        cl_object queue_list;
ecl/object.h:        cl_object queue_spinlock;
ecl/object.h:        cl_object name;
ecl/object.h:        cl_object queue_list;
ecl/object.h:        cl_object queue_spinlock;
ecl/object.h:        cl_object owner;       /* thread holding the lock or NIL */
ecl/object.h:        cl_object name;
ecl/object.h:        cl_object name;
ecl/object.h:        cl_object data;
ecl/object.h:        cl_object reader_semaphore;
ecl/object.h:        cl_object writer_semaphore;
ecl/object.h:        cl_object name;
ecl/object.h:        cl_object mutex;
ecl/object.h:        cl_object queue_list;
ecl/object.h:        cl_object queue_spinlock;
ecl/object.h:        cl_object lock;
ecl/object.h:        cl_object clas;          /*  instance class       */
ecl/object.h:        cl_objectfn entry;       /*  entry address        */
ecl/object.h:        cl_object slotds;        /*  slot definitions     */
ecl/object.h:        cl_object *slots;        /*  instance slots       */
ecl/object.h:static inline cl_type ecl_t_of(cl_object o) {
ecl/object.h:        cl_object *sp;
ecl/page.h:        cl_object       f_link;
ecl/page.h:        cl_object       tm_free;        /*  free list  */
ecl/stacks.h:        cl_object symbol;       /*  symbol  */
ecl/stacks.h:        cl_object value;        /*  previous value of the symbol  */
ecl/stacks.h:extern ECL_API void ecl_bds_bind(cl_env_ptr env, cl_object symbol, cl_object v);
ecl/stacks.h:extern ECL_API void ecl_bds_push(cl_env_ptr env, cl_object symbol);
ecl/stacks.h:extern ECL_API cl_object ecl_bds_read(cl_env_ptr env, cl_object s);
ecl/stacks.h:extern ECL_API cl_object *ecl_bds_ref(cl_env_ptr env, cl_object s);
ecl/stacks.h:extern ECL_API cl_object ecl_bds_set(cl_env_ptr env, cl_object s, cl_object v);
ecl/stacks.h:static inline void ecl_bds_bind_inl(cl_env_ptr env, cl_object s, cl_object v)
ecl/stacks.h:        cl_object *location;
ecl/stacks.h:static inline void ecl_bds_push_inl(cl_env_ptr env, cl_object s)
ecl/stacks.h:        cl_object *location;
ecl/stacks.h:        cl_object s = env->bds_top->symbol;
ecl/stacks.h:        cl_object *location = env->thread_local_bindings + s->symbol.binding;
ecl/stacks.h:static inline cl_object ecl_bds_read_inl(cl_env_ptr env, cl_object s)
ecl/stacks.h:                cl_object x = env->thread_local_bindings[index];
ecl/stacks.h:static inline cl_object *ecl_bds_ref_inl(cl_env_ptr env, cl_object s)
ecl/stacks.h:                cl_object *location = env->thread_local_bindings + index;
ecl/stacks.h:        const cl_object s = (sym);                \
ecl/stacks.h:        const cl_object v = (val);                \
ecl/stacks.h:        const cl_object s = (sym);                \
ecl/stacks.h:        const cl_object v = s->symbol.value;      \
ecl/stacks.h:        const cl_object s = env_copy->bds_top->symbol;  \
ecl/stacks.h:        cl_object function;
ecl/stacks.h:        cl_object lex_env;
ecl/stacks.h:        cl_object       frs_val;
ecl/stacks.h:        (a[0].narg--,(a[0].sp? *(a[0].sp++) : va_arg(a[0].args,cl_object)))
ecl/stacks.h:                cl_object __aux1 = (x), __aux2=(y);                     \
ecl/stacks.h:                cl_object __aux1=(x), __aux2=(y), __aux3=(z);           \
ecl/stacks.h:                cl_object *__new_top = __env->stack_top;                \
ecl/stacks.h:                cl_object *__new_top = __env->stack + (ndx);    \
ecl/stacks.h:                cl_object *__new_top = __env->stack_top - (n);  \
ecl/stacks.h:                cl_object *__new_top = __env->stack_top;                \
ecl/stacks.h:                cl_object __dest = (dest);                              \
ecl/stacks.h:                cl_object __orig = (orig);                              \
ecl/stacks.h:                memcpy(__dest->frame.base, __orig->frame.base, __size * sizeof(cl_object)); \
ecl/stacks.h:        const cl_object __id = ECL_NEW_FRAME_ID(the_env);       \
ecl/stacks.h:        const cl_object __ecl_tag = ecl_list1(names);                   \
ecl/stacks.h:        const cl_object args = __the_env->values[1];
ecl/stacks.h:        const cl_object __ecl_tag = ecl_list1(names);                   \
ecl/stacks.h:        const cl_object args = __the_env->values[1];
lsp/config.lsp:        cl_object output;
