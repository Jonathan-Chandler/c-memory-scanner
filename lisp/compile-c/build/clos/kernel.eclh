
#ifdef ECL_DYNAMIC_VV
static cl_object *VV;
#else
static cl_object VV[VM];
#endif

#ifdef __cplusplus
extern "C" {
#endif
static cl_object L1setf_find_class(cl_narg, cl_object , cl_object , ...);
static cl_object LC2__lambda4(cl_narg, cl_object , ...);
static cl_object L3classp(cl_object );
static cl_object L5install_method(cl_narg, cl_object , cl_object , cl_object , cl_object , cl_object , ...);
static cl_object LC4__lambda10(cl_narg, cl_object , ...);
static cl_object L7wrapped_method_function(cl_object );
static cl_object LC6__lambda14(cl_narg, cl_object , cl_object , ...);
static cl_object L8ensure_generic_function(cl_narg, cl_object , ...);
#define L8ensure_generic_functionkeys (&VV[31])
static cl_object L9_setf_generic_function_name_(cl_object , cl_object );
static cl_object L10default_dispatch(cl_object );
static cl_object L12compute_discriminating_function(cl_object );
static cl_object LC11__lambda44(cl_narg, ...);
static cl_object L13set_generic_function_dispatch(cl_object );
ECL_DLLEXPORT cl_object clos_std_compute_applicable_methods(cl_object , cl_object );
static cl_object L15applicable_method_list(cl_object , cl_object );
static cl_object LC14applicable_method_p(cl_object , cl_object );
static cl_object L17std_compute_applicable_methods_using_classes(cl_object volatile , cl_object volatile );
static cl_object LC16applicable_method_p(volatile cl_object  *, cl_object , cl_object );
static cl_object L18sort_applicable_methods(cl_object , cl_object , cl_object );
static cl_object L19compare_methods(cl_object , cl_object , cl_object , cl_object );
static cl_object L20compare_specializers_lists(cl_object , cl_object , cl_object );
static cl_object L21fast_subtypep(cl_object , cl_object );
static cl_object L22compare_specializers(cl_object , cl_object , cl_object );
static cl_object L24compute_g_f_spec_list(cl_object );
static cl_object LC23nupdate_spec_how_list(cl_object , cl_object );
static cl_object L25print_object(cl_object , cl_object );
static cl_object Cblock;
#define VM 42
#define VMtemp 1
#define ECL_DEFINE_SETF_FUNCTIONS \
VV[33]=ecl_setf_definition(ECL_SYM("SLOT-VALUE",973),ECL_T);
#ifdef __cplusplus
}
#endif
/*
 * Exported Lisp functions
 */
#define compiler_cfuns_size 13
static const struct ecl_cfunfixed compiler_cfuns[] = {
 /*t,m,narg,padding,name=function-location,block=name-location,entry,entry_fixed,file,file_position*/
{0,0,-3,0,ecl_make_fixnum(26),ecl_make_fixnum(5),(cl_objectfn)L1setf_find_class,NULL,ECL_NIL,ecl_make_fixnum(1297)},
{0,0,1,0,ecl_make_fixnum(27),ecl_make_fixnum(6),(cl_objectfn)L3classp,NULL,ECL_NIL,ecl_make_fixnum(2014)},
{0,0,-6,0,ecl_make_fixnum(28),ecl_make_fixnum(8),(cl_objectfn)L5install_method,NULL,ECL_NIL,ecl_make_fixnum(2533)},
{0,0,1,0,ecl_make_fixnum(29),ecl_make_fixnum(9),(cl_objectfn)L7wrapped_method_function,NULL,ECL_NIL,ecl_make_fixnum(3533)},
{0,0,-2,0,ecl_make_fixnum(30),ecl_make_fixnum(10),(cl_objectfn)L8ensure_generic_function,NULL,ECL_NIL,ecl_make_fixnum(3947)},
{0,0,2,0,ecl_make_fixnum(32),ecl_make_fixnum(11),(cl_objectfn)L9_setf_generic_function_name_,NULL,ECL_NIL,ecl_make_fixnum(4943)},
{0,0,1,0,ecl_make_fixnum(34),ecl_make_fixnum(12),(cl_objectfn)L10default_dispatch,NULL,ECL_NIL,ecl_make_fixnum(5108)},
{0,0,1,0,ecl_make_fixnum(36),ecl_make_fixnum(13),(cl_objectfn)L12compute_discriminating_function,NULL,ECL_NIL,ecl_make_fixnum(5363)},
{0,0,1,0,ecl_make_fixnum(37),ecl_make_fixnum(16),(cl_objectfn)L13set_generic_function_dispatch,NULL,ECL_NIL,ecl_make_fixnum(6199)},
{0,0,2,0,ecl_make_fixnum(38),ecl_make_fixnum(17),(cl_objectfn)L17std_compute_applicable_methods_using_classes,NULL,ECL_NIL,ecl_make_fixnum(10809)},
{0,0,3,0,ecl_make_fixnum(39),ecl_make_fixnum(18),(cl_objectfn)L18sort_applicable_methods,NULL,ECL_NIL,ecl_make_fixnum(11928)},
{0,0,1,0,ecl_make_fixnum(40),ecl_make_fixnum(24),(cl_objectfn)L24compute_g_f_spec_list,NULL,ECL_NIL,ecl_make_fixnum(15761)},
{0,0,2,0,ecl_make_fixnum(41),ecl_make_fixnum(25),(cl_objectfn)L25print_object,NULL,ECL_NIL,ecl_make_fixnum(17949)},
};
