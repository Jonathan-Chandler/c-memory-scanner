static const struct ecl_base_string compiler_data_text1[] = {
        (int8_t)t_base_string, 0, ecl_aet_bc, 0,
        ECL_NIL, (cl_index)14916, (cl_index)14916,
        (ecl_base_char*)
"si::column si::posn si::initial-buffer-size si::default-line-length si::pretty-s"
 "tream :sealedp si::pretty-stream-p :target :buffer-start-column si::make-pretty-"
 "stream si::index-posn si::posn-index si::posn-column :literal si::logical-block "
 "si::copy-logical-block si::logical-block-p si::index si::section-start-line si::"
 "suffix-length si::prefix-length si::per-line-prefix-end si::section-column si::s"
 "tart-column 0 si::make-logical-block si::logical-block-section-start-line mp::ca"
 "s-expander si::logical-block-suffix-length si::logical-block-prefix-length si::l"
 "ogical-block-per-line-prefix-end si::logical-block-section-column si::logical-bl"
 "ock-start-column :start-column :section-column :per-line-prefix-end :prefix-leng"
 "th :suffix-length :section-start-line si::queued-op si::copy-queued-op si::queue"
 "d-op-p 0 si::make-queued-op si::queued-op-posn si::section-start si::copy-sectio"
 "n-start si::section-start-p si::newline si::block-end (or null si::newline si::b"
 "lock-end) si::section-end si::depth 0 si::make-section-start si::section-start-s"
 "ection-end si::section-start-depth si::section-start-posn si::copy-newline si::n"
 "ewline-p (:linear :fill :miser :literal :mandatory) (member :linear :fill :miser"
 " :literal :mandatory) si::kind 0 si::make-newline si::newline-kind si::newline-s"
 "ection-end si::newline-depth si::newline-posn :posn :kind :depth :mandatory si::"
 "indentation si::copy-indentation si::indentation-p si::amount (:block . #1=(:cur"
 "rent)) :current #1# (member :block :current) 0 si::make-indentation si::indentat"
 "ion-amount si::indentation-kind si::indentation-posn :amount si::block-start si:"
 ":copy-block-start si::block-start-p (or null string) si::suffix si::prefix (or n"
 "ull si::block-end) 0 si::make-block-start si::block-start-suffix si::block-start"
 "-prefix si::block-start-block-end si::block-start-section-end si::block-start-de"
 "pth si::block-start-posn :prefix :suffix si::copy-block-end si::block-end-p 0 si"
 "::make-block-end si::block-end-suffix si::block-end-posn si::tab si::copy-tab si"
 "::tab-p si::colinc si::colnum (t . #2=(nil)) #2# (member t nil) si::relativep si"
 "::sectionp 0 si::make-tab si::tab-colinc si::tab-colnum si::tab-relativep si::ta"
 "b-sectionp si::tab-posn :line-relative :section :section-relative (:line :line-r"
 "elative :section :section-relative) :sectionp :relativep :colnum :colinc 0 0 :li"
 "near 0 :miser :fill 0 :dont-know (t nil :dont-know) (:linear :mandatory :literal"
 " :miser :fill) (si::newline si::indentation si::block-start si::block-end si::ta"
 "b) :from-end \" ..\" si::line-limit-abbreviation-happened \"Output-partial-line cal"
 "led when nothing can be output.\" \". \" \"...\" si::pprint-pop-helper si::pprint-log"
 "ical-block-helper \"\" :per-line-prefix (:suffix :per-line-prefix :prefix) \"Cannot"
 " specify both a prefix and a per-line-prefix.\" \"PPRINT-LOGICAL-BLOCK-\" \"PPRINT-L"
 "OGICAL-BLOCK-LENGTH-\" pprint-logical-block \"PPRINT-EXIT-IF-LIST-EXHAUSTED must b"
 "e lexically inside ~\n          PPRINT-LOGICAL-BLOCK.\" pprint-exit-if-list-exhaus"
 "ted \"PPRINT-POP must be lexically inside PPRINT-LOGICAL-BLOCK.\" pprint-pop #3=(:"
 "linear . #4=(:miser . #5=(:fill . #6=(:mandatory)))) #4# #5# #6# (member . #3#) "
 "(or stream (member t nil)) #7=(:line . #8=(:section . #9=(:line-relative . #10=("
 ":section-relative)))) #8# #9# #10# (member . #7#) \"(\" \")\" (or unsigned-byte null"
 ") si::*standard-pprint-dispatch* si::*initial-pprint-dispatch* si::pprint-dispat"
 "ch-entry si::copy-pprint-dispatch-entry si::%print-pprint-dispatch-entry si::ppr"
 "int-dispatch-entry-p (or function symbol) si::initial-p si::priority 0 si::make-"
 "pprint-dispatch-entry si::pprint-dispatch-entry-function si::pprint-dispatch-ent"
 "ry-initial-p si::pprint-dispatch-entry-priority si::pprint-dispatch-entry-type \""
 "Type=~S, priority=~S~@[ [Initial]~]\" si::pprint-dispatch-table si::copy-pprint-d"
 "ispatch-table si::%print-pprint-dispatch-table si::pprint-dispatch-table-p si::e"
 "ntries 0 si::make-pprint-dispatch-table si::pprint-dispatch-table-cons-entries s"
 "i::pprint-dispatch-table-entries si::pprint-dispatch-table-read-only-p :entries "
 "(or si::pprint-dispatch-table null) si::default-pprint-dispatch (or null functio"
 "n symbol) \"Ignore and continue\" \"Tried to modify a read-only pprint dispatch tab"
 "le: ~A\" :priority si::pprint-array \"#(\" si::pprint-vector \"#\" \"A\" \"#A(\" :optiona"
 "l 0 0 0 0 (:required :key :optional) si::pprint-lambda-list :complaint \"No more "
 "arguments.\" \"~:<~^~W~^~3I ~:_~/SI:PPRINT-LAMBDA-LIST/~1I~@{ ~_~W~}~:>\" \" \" si::p"
 "print-lambda \"~:<~^~W~^~3I ~:_~W~1I~@{ ~_~W~}~:>\" si::pprint-block \"~:<~^~W~^ ~@"
 "_~:<~@{~:<~^~W~^~3I ~:_~/SI:PPRINT-LAMBDA-LIST/~1I~:@_~@{~W~^ ~_~}~:>~^ ~_~}~:>~"
 "1I~@:_~@{~W~^ ~_~}~:>\" si::pprint-flet \"~:<~^~W~^ ~@_~:<~@{~:<~^~W~@{ ~_~W~}~:>~"
 "^ ~_~}~:>~1I~:@_~@{~W~^ ~_~}~:>\" si::pprint-let \"~:<~^~W~@{ ~_~W~}~:>\" si::pprin"
 "t-progn \"~:<~^~W~^~3I ~_~W~^ ~_~W~^~1I~@{ ~_~W~}~:>\" si::pprint-progv \"#'\" si::p"
 "print-quote si::pprint-setq si::pprint-tagbody \"~:<~^~W~^ ~3I~:_~W~1I~@{ ~_~:<~^"
 "~:/SI:PPRINT-FILL/~^~@{ ~_~W~}~:>~}~:>\" si::pprint-case \"~:<~^~W~^ ~@_~:I~W~^ ~:"
 "_~/SI:PPRINT-LAMBDA-LIST/~1I~@{ ~_~W~}~:>\" si::pprint-defun \"~:<~^~W~^~3I ~_~:/S"
 "I:PPRINT-LAMBDA-LIST/~^ ~_~W~^~1I~@{ ~_~W~}~:>\" si::pprint-destructuring-bind \"~"
 ":<~@{~:<~^~W~^ ~@_~:I~W~@{ ~_~W~}~:>~^~:@_~}~:>\" si::pprint-do \"~:<~^~W~^ ~:_~:I"
 "~W~@{ ~_~W~}~:>\" si::pprint-dolist \"~:<~^~W~^ ~3I~:_~W~1I~@{ ~_~:<~^~W~^~@{ ~_~W"
 "~}~:>~}~:>\" si::pprint-typecase si::pprint-prog \"~:<~^~W~^ ~:_~:I~@{~W~^ ~_~}~:>"
 "\" si::pprint-function-call 0 0 clos::install-method 0 0 0 si::define-structure 0"
 " si::structure-type-error 0 0 :posn :depth :section-end 0 si::required-argument "
 ":posn :depth :section-end :kind 0 :posn :kind :amount 0 :posn :depth :section-en"
 "d :block-end :prefix :suffix 0 :posn :suffix 0 :posn :sectionp :relativep :colnu"
 "m :colinc 0 0 0 si::dm-too-few-arguments si::search-keyword si::check-keyword 0 "
 "si::dm-too-many-arguments 0 0 :type :priority :initial-p :function 0 0 :read-onl"
 "y-p :entries :cons-entries 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \"SI\" ((op"
 "timize (safety 0) (speed 3) (debug 0) (space 0))) (deftype si::column nil '#11=("
 "and fixnum unsigned-byte)) #11# (deftype si::posn nil 'fixnum) (gray::fundamenta"
 "l-character-output-stream) (:writers ((setf si::pretty-stream-target)) :readers "
 "(si::pretty-stream-target) :type stream :initform t :initargs (:target) :name si"
 "::target) (:writers ((setf si::pretty-stream-line-length)) :readers (si::pretty-"
 "stream-line-length) :type si::column :initform (or *print-right-margin* si::defa"
 "ult-line-length) :name si::line-length) (:writers ((setf si::pretty-stream-buffe"
 "r)) :readers (si::pretty-stream-buffer) :type simple-string :initform (make-stri"
 "ng si::initial-buffer-size) :name si::buffer) (:writers ((setf si::pretty-stream"
 "-buffer-fill-pointer)) :readers (si::pretty-stream-buffer-fill-pointer) :type si"
 "::index :initform 0 :name si::buffer-fill-pointer) (:writers ((setf si::pretty-s"
 "tream-buffer-offset)) :readers (si::pretty-stream-buffer-offset) :type si::posn "
 ":initform 0 :name si::buffer-offset) (:writers ((setf si::pretty-stream-buffer-s"
 "tart-column)) :readers (si::pretty-stream-buffer-start-column) :type si::column "
 ":initargs (:buffer-start-column) :name si::buffer-start-column) (:writers ((setf"
 " si::pretty-stream-line-number)) :readers (si::pretty-stream-line-number) :type "
 "si::index :initform 0 :name si::line-number) (:writers ((setf si::pretty-stream-"
 "blocks)) :readers (si::pretty-stream-blocks) :type list :initform (list (si::mak"
 "e-logical-block)) :name si::blocks) (:writers ((setf si::pretty-stream-prefix)) "
 ":readers (si::pretty-stream-prefix) :type string :initform (make-string si::init"
 "ial-buffer-size) :name si::prefix) (:writers ((setf si::pretty-stream-suffix)) :"
 "readers (si::pretty-stream-suffix) :type string :initform (make-string si::initi"
 "al-buffer-size) :name si::suffix) (:writers ((setf si::pretty-stream-queue-tail)"
 ") :readers (si::pretty-stream-queue-tail) :type list :initform nil :name si::que"
 "ue-tail) (:writers ((setf si::pretty-stream-queue-head)) :readers (si::pretty-st"
 "ream-queue-head) :type list :initform nil :name si::queue-head) (:writers ((setf"
 " si::pretty-stream-pending-blocks)) :readers (si::pretty-stream-pending-blocks) "
 ":type list :initform nil :name si::pending-blocks) (t) (si::pretty-stream t) (si"
 "::pretty-stream stream) ((inline si::index-posn si::posn-index si::posn-column))"
 " #'(ext::lambda-block si::index-posn (si::index stream) #12=(declare (si::c-glob"
 "al)) (declare (type si::index si::index) (type si::pretty-stream stream)) (+ si:"
 ":index (si::pretty-stream-buffer-offset stream))) #'(ext::lambda-block si::posn-"
 "index (si::posn stream) #12# (declare (type si::posn si::posn) (type si::pretty-"
 "stream stream)) (- si::posn (si::pretty-stream-buffer-offset stream))) #'(ext::l"
 "ambda-block si::posn-column (si::posn stream) #12# (declare (type si::posn si::p"
 "osn) (type si::pretty-stream stream)) (si::index-column (si::posn-index si::posn"
 " stream) stream)) (stream char) (si::pretty-stream) (stream) ((si::start-column "
 "0 :type si::column) (si::section-column 0 :type si::column) (si::per-line-prefix"
 "-end 0 :type si::index) (si::prefix-length 0 :type si::index) (si::suffix-length"
 " 0 :type si::index) (si::section-start-line 0 :type si::index)) ((si::start-colu"
 "mn 0 si::column nil 0 nil) (si::section-column 0 si::column nil 1 nil) (si::per-"
 "line-prefix-end 0 si::index nil 2 nil) (si::prefix-length 0 si::index nil 3 nil)"
 " (si::suffix-length 0 si::index nil 4 nil) (si::section-start-line 0 si::index n"
 "il 5 nil)) (si::make-logical-block) \"Ignore lock and proceed.\" \"Attempt to defin"
 "e CAS accessor ~S in locked package.\" (si::logical-block-section-start-line) (si"
 "::logical-block-suffix-length) (si::logical-block-prefix-length) (si::logical-bl"
 "ock-per-line-prefix-end) (si::logical-block-section-column) (si::logical-block-s"
 "tart-column) ((si::posn 0 :type si::posn)) ((si::posn 0 si::posn nil 0 nil)) (si"
 "::make-queued-op) (si::queued-op-posn) ((si::depth 0 :type si::index) (si::secti"
 "on-end nil :type #13=(or null si::newline si::block-end))) (#14=(si::posn 0 si::"
 "posn nil 0 si::queued-op-posn) (si::depth 0 si::index nil 1 nil) (si::section-en"
 "d nil #13# nil 2 nil)) (si::make-section-start) (si::section-start-section-end) "
 "(si::section-start-depth) (si::section-start-posn) ((si::kind #15=(si::required-"
 "argument) :type #16=(member :linear :fill :miser :literal :mandatory))) (#17=(si"
 "::posn 0 si::posn nil 0 si::section-start-posn) #18=(si::depth 0 si::index nil 1"
 " si::section-start-depth) #19=(si::section-end nil (or null si::newline si::bloc"
 "k-end) nil 2 si::section-start-section-end) (si::kind #15# #16# nil 3 nil)) (si:"
 ":make-newline) (si::newline-kind) (si::newline-section-end) (si::newline-depth) "
 "(si::newline-posn) ((si::kind #20=(si::required-argument) :type #21=(member :blo"
 "ck :current)) (si::amount 0 :type fixnum)) (#14# (si::kind #20# #21# nil 1 nil) "
 "(si::amount 0 fixnum nil 2 nil)) (si::make-indentation) (si::indentation-amount)"
 " (si::indentation-kind) (si::indentation-posn) ((si::block-end nil :type #22=(or"
 " null si::block-end)) (si::prefix nil :type #23=(or null string)) (si::suffix ni"
 "l :type #24=(or null string))) (#17# #18# #19# (si::block-end nil #22# nil 3 nil"
 ") (si::prefix nil #23# nil 4 nil) (si::suffix nil #24# nil 5 nil)) (si::make-blo"
 "ck-start) (si::block-start-suffix) (si::block-start-prefix) (si::block-start-blo"
 "ck-end) (si::block-start-section-end) (si::block-start-depth) (si::block-start-p"
 "osn) ((si::suffix nil :type #25=(or null string))) (#14# (si::suffix nil #25# ni"
 "l 1 nil)) (si::make-block-end) (si::block-end-suffix) (si::block-end-posn) ((si:"
 ":sectionp nil :type #26=(member t nil)) (si::relativep nil :type #27=(member t n"
 "il)) (si::colnum 0 :type si::column) (si::colinc 0 :type si::column)) (#14# (si:"
 ":sectionp nil #26# nil 1 nil) (si::relativep nil #27# nil 2 nil) (si::colnum 0 s"
 "i::column nil 3 nil) (si::colinc 0 si::column nil 4 nil)) (si::make-tab) (si::ta"
 "b-colinc) (si::tab-colnum) (si::tab-relativep) (si::tab-sectionp) (si::tab-posn)"
 " ((type #28=(si::required-argument) :type t) (si::priority 0 :type real) (si::in"
 "itial-p #29=(not (boundp 'si::*initial-pprint-dispatch*)) :type #30=(member t ni"
 "l)) (function #31=(si::required-argument) :type #32=(or function symbol))) ((typ"
 "e #28# t nil 0 nil) (si::priority 0 real nil 1 nil) (si::initial-p #29# #30# nil"
 " 2 nil) (function #31# #32# nil 3 nil)) (si::make-pprint-dispatch-entry) (si::pp"
 "rint-dispatch-entry-function) (si::pprint-dispatch-entry-initial-p) (si::pprint-"
 "dispatch-entry-priority) (si::pprint-dispatch-entry-type) ((si::read-only-p nil)"
 " (si::entries nil :type list) (si::cons-entries #33=(make-hash-table :test #'eql"
 "))) ((si::read-only-p nil t nil 0 nil) (si::entries nil list nil 1 nil) (si::con"
 "s-entries #33# t nil 2 nil)) (si::make-pprint-dispatch-table) (si::pprint-dispat"
 "ch-table-cons-entries) (si::pprint-dispatch-table-entries) (si::pprint-dispatch-"
 "table-read-only-p) (cons (and symbol (satisfies fboundp))) ((lambda si::pprint-l"
 "ambda) (block si::pprint-block) (catch si::pprint-block) (ext::compiler-let si::"
 "pprint-let) (eval-when si::pprint-block) (flet si::pprint-flet) #'si::pprint-quo"
 "te (labels si::pprint-flet) (let si::pprint-let) (let* si::pprint-let) (locally "
 "si::pprint-progn) (macrolet si::pprint-flet) (multiple-value-call si::pprint-blo"
 "ck) (multiple-value-prog1 si::pprint-block) (progn si::pprint-progn) (progv si::"
 "pprint-progv) 'si::pprint-quote (return-from si::pprint-block) (setq si::pprint-"
 "setq) (symbol-macrolet si::pprint-let) (tagbody si::pprint-tagbody) (throw si::p"
 "print-block) (unwind-protect si::pprint-block) (case si::pprint-case) (ccase si:"
 ":pprint-case) (ctypecase si::pprint-typecase) (defconstant si::pprint-block) (de"
 "fine-modify-macro si::pprint-defun) (define-setf-expander si::pprint-defun) (def"
 "macro si::pprint-defun) (defparameter si::pprint-block) (defsetf si::pprint-defu"
 "n) (defstruct si::pprint-block) (deftype si::pprint-defun) (defun si::pprint-def"
 "un) (defvar si::pprint-block) (destructuring-bind si::pprint-destructuring-bind)"
 " (do si::pprint-do) (do* si::pprint-do) (do-all-symbols si::pprint-dolist) (do-e"
 "xternal-symbols si::pprint-dolist) (do-symbols si::pprint-dolist) (dolist si::pp"
 "rint-dolist) (dotimes si::pprint-dolist) (ecase si::pprint-case) (etypecase si::"
 "pprint-typecase) (multiple-value-bind si::pprint-progv) (multiple-value-setq si:"
 ":pprint-block) (pprint-logical-block si::pprint-block) (print-unreadable-object "
 "si::pprint-block) (prog si::pprint-prog) (prog* si::pprint-prog) (prog1 si::ppri"
 "nt-block) (prog2 si::pprint-progv) (psetf si::pprint-setq) (psetq si::pprint-set"
 "q) (setf si::pprint-setq) (step si::pprint-progn) (time si::pprint-progn) (typec"
 "ase si::pprint-typecase) (unless si::pprint-block) (when si::pprint-block) (with"
 "-compilation-unit si::pprint-block) (with-hash-table-iterator si::pprint-block) "
 "(with-input-from-string si::pprint-block) (with-open-file si::pprint-block) (wit"
 "h-open-stream si::pprint-block) (with-output-to-string si::pprint-block) (with-p"
 "ackage-iterator si::pprint-block) (with-simple-restart si::pprint-block) (with-s"
 "tandard-io-syntax si::pprint-progn))" };

static const cl_object compiler_data_text[] = {
(cl_object)compiler_data_text1,
NULL};
