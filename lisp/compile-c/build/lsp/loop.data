static const struct ecl_base_string compiler_data_text1[] = {
        (int8_t)t_base_string, 0, ecl_aet_bc, 0,
        ECL_NIL, (cl_index)12329, (cl_index)12329,
        (ecl_base_char*)
"(declare (ext::assume-right-type)) si::loop-unsafe (list nil) si::with-loop-list"
 "-collection-head 0 0 0 'nil 0 si::loop-collect-rplacd si::loop-collect-answer si"
 "::loop-minimax si::copy-loop-minimax (6) si::make-loop-minimax-internal si::*loo"
 "p-minimax-type-infinities-alist* :answer-variable :temp-variable \"LOOP-MAXMIN-TE"
 "MP-\" :flag-variable \"LOOP-MAXMIN-FLAG-\" :operations :infinity-data si::with-mini"
 "max-value (min max) si::loop-accumulate-minimax-value si::loop-store-table-data "
 "si::loop-universe si::copy-loop-universe (8) si::make-loop-universe si::*loop-un"
 "iverse* :keywords :for-keywords :iteration-keywords :path-keywords :ansi :implic"
 "it-for-required :type-keywords :type-symbols si::*loop-destructuring-hooks* si::"
 "loop-really-desetq si::*loop-desetq-temporary* si::*loop-source-code* si::*loop-"
 "original-source-code* si::*loop-source-context* si::*loop-names* si::*loop-macro"
 "-environment* si::*loop-named-variables* si::*loop-variables* si::*loop-declarat"
 "ions* si::*loop-desetq-crocks* si::*loop-wrappers* si::*loop-bind-stack* si::*lo"
 "op-nodeclare* si::*loop-iteration-variables* si::*loop-prologue* si::*loop-befor"
 "e-loop* si::*loop-body* si::*loop-after-body* si::*loop-emitted-body* si::*loop-"
 "epilogue* si::*loop-after-epilogue* si::*loop-final-value-culprit* si::*loop-ins"
 "ide-conditional* si::*loop-when-it-variable* si::*loop-never-stepped-variable* s"
 "i::*loop-collection-cruft* \"The form ~S evaluated to ~S, which was not of the an"
 "ticipated type ~S.\" si::*loop-duplicate-code* si::*loop-iteration-flag-variable*"
 " \"LOOP-BODY called with non-synched before- and after-loop lists.\" si::next-loop"
 " (go si::next-loop) si::end-loop si::loop-body \"~?~%Current LOOP context:~{ ~S~}"
 ".\" si::simple-style-warning \"LOOP couldn't verify that ~S is a subtype of the re"
 "quired type ~S.\" \"Specified data type ~S is not a subtype of ~S.\" (go si::end-lo"
 "op) loop-finish si::*ignores* si::subst-gensyms-for-nil si::loop-build-destructu"
 "ring-bindings \"~S found where LOOP keyword expected.\" (and si::else) \"Secondary "
 "clause misplaced at top level in LOOP macro: ~S ~S ~S ...\" \"~S is an unknown key"
 "word in LOOP macro.\" \"LOOP source code ran out when another token was expected.\""
 " \"Compound form expected, but found ~A.\" \"LOOP code ran out where a form was exp"
 "ected.\" \"LOOP clause is providing a value for the iteration,~@\n                h"
 "owever one was already established by a ~S clause.\" \"~:[This LOOP~;The LOOP ~:*~"
 "S~] clause is not permitted inside a conditional.\" si::loop-collector-name \"This"
 " LOOP clause is not permitted with anonymous collectors.\" si::loop-disallow-anon"
 "ymous-collectors (si::always si::never si::thereis) \"This anonymous collection L"
 "OOP clause is not permitted with aggregate booleans.\" si::loop-disallow-aggregat"
 "e-booleans (or float (complex float)) si::of-type \"~S found where a LOOP keyword"
 ", LOOP type keyword, or LOOP type pattern expected.\" \"~S found where a LOOP keyw"
 "ord or LOOP type keyword expected.\" \"Destructuring type pattern ~S contains unre"
 "cognized type keyword ~S.\" \"Destructuring type pattern ~S doesn't match variable"
 " pattern ~S.\" si::loop-variable-p \"LOOP-IGNORE-\" \"Duplicated LOOP iteration vari"
 "able ~S.\" \"Duplicated variable ~S in LOOP parallel binding.\" \"Bad variable ~S so"
 "mewhere in LOOP.\" \"LOOP-DESTRUCTURE-\" \"Invalid LOOP variable passed in: ~S.\" \"LO"
 "OP-BIND-\" \"~S found where keyword expected getting LOOP clause after ~S.\" si::it"
 " \"~S does not introduce a LOOP clause that can follow ~S.\" :and :else si::loop-d"
 "o-if :initially si::loop-do-initially :finally si::loop-do-finally si::loop-do-d"
 "o \"~S is an invalid name for your LOOP.\" \"The NAMED ~S clause occurs too late.\" "
 "\"You may only use one NAMED clause in your loop: NAMED ~S ... NAMED ~S.\" si::loo"
 "p-do-named si::loop-do-return si::loop-collector si::copy-loop-collector si::mak"
 "e-loop-collector si::into \"Value accumulation recipient name, ~S, is not a symbo"
 "l.\" \"Variable ~S cannot be used in INTO clause\" :class :history :dtype \"Incompat"
 "ible kinds of LOOP value accumulation specified for collecting~@\n               "
 "     ~:[as the value of the LOOP~;~:*INTO ~S~]: ~S and ~S.\" \"Unequal datatypes s"
 "pecified in different LOOP value accumulations~@\n                   into ~S: ~S "
 "and ~S.\" \"LOOP-LIST-HEAD\" \"LOOP-LIST-TAIL\" (list nconc append) si::loop-list-col"
 "lection si::sum \"LOOP-SUM-\" si::loop-sum-collection si::maxmin \"LOOP-MAXMIN-\" si"
 "::loop-maxmin-collection si::loop-do-always si::loop-do-thereis si::loop-do-whil"
 "e :with := \"Variable ~S has already been used\" si::loop-do-with \"Iteration in LO"
 "OP follows body code. This error is typically caused\nby a WHILE, UNTIL or simila"
 "r condition placed in between FOR, AS, and similar iterations.\nNote that this is"
 " not a valid ANSI code.\" \"~S is an unknown keyword in FOR or AS clause in LOOP.\""
 " si::loop-do-for :repeat si::loop-do-repeat \"LOOP-IT-\" :then (nil nil) si::loop-"
 "ansi-for-equals \"LOOP-ACROSS-VECTOR-\" \"LOOP-ACROSS-INDEX-\" \"LOOP-ACROSS-LIST\" si"
 "::loop-for-across :by #'si::cons-cdr \"Use of QUOTE around stepping function in L"
 "OOP will be left verbatim.\" \"LOOP-FN\" si::loop-for-on \"LOOP-LIST\" si::loop-for-i"
 "n si::loop-path si::copy-loop-path (5) si::make-loop-path :names :user-data :pre"
 "position-groups :inclusive-permitted (:each :the) (:its :each :his :her) \"~S fou"
 "nd where ITS or EACH expected in LOOP iteration path syntax.\" :in \"Unrecognizabl"
 "e LOOP iteration path syntax.  Missing EACH or THE?\" \"~S found where a LOOP iter"
 "ation path name was expected.\" \"~S is not the name of a LOOP iteration path.\" \"\\"
 "\"Inclusive\\\" iteration is not possible with the ~S LOOP iteration path.\" :inclus"
 "ive \"Unused USING variables: ~S.\" 0 0 \"Value passed back by LOOP iteration path "
 "function for path ~S has invalid length.\" si::loop-for-being \"A ~S prepositional"
 " phrase occurs multiply for some LOOP clause.\" \"Preposition ~S used when some ot"
 "her preposition has subsumed it.\" si::using \"The variable substitution for ~S oc"
 "curs twice in a USING phrase,~@\n                        with ~S and ~S.\" :of 0 0"
 " :from 0 :downfrom 0 :upfrom 0 :down (:upto :to :downto :above :below) :upto :to"
 " :downto :above :below \"LOOP-LIMIT\" \"LOOP-STEP-BY\" \"~S invalid preposition in se"
 "quencing or sequence path.~@\n               Invalid prepositions specified in it"
 "eration path descriptor or something?\" \"Conflicting stepping directions in LOOP "
 "sequencing path\" \"Missing OF or IN phrase in sequence path\" 0 0 \"LOOP-SEQ-LIMIT-"
 "\" \"Don't know where to start stepping.\" ((:from :upfrom :downfrom) (:to :upto :d"
 "ownto :above :below) (:by)) si::loop-for-arithmetic si::hash-key 0 si::hash-valu"
 "e 0 (member si::hash-key si::hash-value) si::which 0 0 \"Too many prepositions!\" "
 "\"Missing OF or IN in ~S iteration path.\" \"LOOP-HASHTAB-\" \"LOOP-HASHTAB-NEXT-\" \"L"
 "OOP-HASH-VAL-TEMP-\" \"LOOP-HASH-KEY-TEMP-\" \"LOOP-HASH-PREDICATE-VAR-\" si::loop-ha"
 "sh-table-iteration-path \"Unknow preposition ~S\" \"Destructuring is not valid for "
 "package symbol iteration.\" \"LOOP-PKGSYM-\" \"LOOP-PKGSYM-NEXT-\" si::loop-package-s"
 "ymbols-iteration-path ((si::named (si::loop-do-named)) (si::initially (si::loop-"
 "do-initially)) (si::finally (si::loop-do-finally)) (do (si::loop-do-do)) (si::do"
 "ing (si::loop-do-do)) (return (si::loop-do-return)) (ext::collect (si::loop-list"
 "-collection list)) (si::collecting (si::loop-list-collection list)) (append (si:"
 ":loop-list-collection append)) (si::appending (si::loop-list-collection append))"
 " (nconc (si::loop-list-collection nconc)) (si::nconcing (si::loop-list-collectio"
 "n nconc)) (count (si::loop-sum-collection count real fixnum)) (si::counting (si:"
 ":loop-sum-collection count real fixnum)) (si::sum (si::loop-sum-collection si::s"
 "um number number)) (si::summing (si::loop-sum-collection si::sum number number))"
 " (si::maximize (si::loop-maxmin-collection max)) (si::minimize (si::loop-maxmin-"
 "collection min)) (si::maximizing (si::loop-maxmin-collection max)) (si::minimizi"
 "ng (si::loop-maxmin-collection min)) (si::always (si::loop-do-always t nil)) (si"
 "::never (si::loop-do-always t t)) (si::thereis (si::loop-do-thereis t)) (si::whi"
 "le (si::loop-do-while nil :while)) (si::until (si::loop-do-while t :until)) (whe"
 "n (si::loop-do-if when nil)) (if (si::loop-do-if if nil)) (unless (si::loop-do-i"
 "f unless t)) (si::with (si::loop-do-with)) (si::repeat (si::loop-do-repeat))) (("
 "= (si::loop-ansi-for-equals)) (si::across (si::loop-for-across)) (si::in (si::lo"
 "op-for-in)) (si::on (si::loop-for-on)) (si::from (si::loop-for-arithmetic :from)"
 ") (si::downfrom (si::loop-for-arithmetic :downfrom)) (si::upfrom (si::loop-for-a"
 "rithmetic :upfrom)) (si::below (si::loop-for-arithmetic :below)) (si::above (si:"
 ":loop-for-arithmetic :above)) (si::to (si::loop-for-arithmetic :to)) (si::upto ("
 "si::loop-for-arithmetic :upto)) (si::downto (si::loop-for-arithmetic :downto)) ("
 "si::by (si::loop-for-arithmetic :by)) (si::being (si::loop-for-being))) ((si::fo"
 "r (si::loop-do-for)) (si::as (si::loop-do-for))) (array atom bignum bit bit-vect"
 "or character compiled-function complex cons double-float fixnum float function h"
 "ash-table integer keyword list long-float nil null number package pathname rando"
 "m-state ratio rational readtable sequence short-float simple-array simple-bit-ve"
 "ctor simple-string simple-vector single-float standard-char stream string base-c"
 "har symbol t vector) :extended (si::hash-key si::hash-keys) ((:of :in)) (:which "
 "si::hash-key) (si::hash-value si::hash-values) (:which si::hash-value) (symbol s"
 "i::symbols) (:symbol-types (:internal :external :inherited)) (si::external-symbo"
 "l si::external-symbols) (:symbol-types (:external)) (si::present-symbol si::pres"
 "ent-symbols) (:symbol-types (:internal :external)) si::*loop-ansi-universe* loop"
 " 0 0 si::dm-too-few-arguments si::dm-too-many-arguments 0 0 si::define-structure"
 " 0 :answer-variable :type :temp-variable :flag-variable :operations :infinity-da"
 "ta si::loop-minimax-operations si::loop-minimax-flag-variable 0 si::loop-minimax"
 "-type si::loop-minimax-infinity-data si::loop-minimax-answer-variable si::loop-m"
 "inimax-temp-variable 0 0 0 :keywords :iteration-keywords :for-keywords :path-key"
 "words :type-symbols :type-keywords :ansi :implicit-for-required :keywords :for-k"
 "eywords :iteration-keywords :path-keywords :type-keywords :type-symbols :ansi 0 "
 "0 0 0 0 si::loop-universe-keywords si::loop-universe-iteration-keywords 0 0 si::"
 "loop-universe-type-symbols si::loop-universe-type-keywords 0 si::make-seq-iterat"
 "or si::seq-iterator-ref si::seq-iterator-next 0 0 0 0 0 0 0 :name :class :histor"
 "y :tempvars :dtype :data si::loop-universe-ansi si::loop-collector-class si::loo"
 "p-collector-history si::loop-collector-dtype 0 si::loop-collector-tempvars 0 0 s"
 "i::loop-collector-data 0 0 0 0 si::loop-universe-implicit-for-required 0 si::loo"
 "p-universe-for-keywords 0 0 0 0 0 0 :names :preposition-groups :inclusive-permit"
 "ted :function :user-data :preposition-groups :inclusive-permitted :user-data si:"
 ":loop-universe-path-keywords 0 si::loop-path-inclusive-permitted si::loop-path-f"
 "unction si::loop-path-preposition-groups si::loop-path-user-data 0 0 :which 0 :s"
 "ymbol-types 0 \"SI\" (si::answer-variable type si::temp-variable si::flag-variable"
 " si::operations si::infinity-data) ((si::answer-variable nil t nil 0 nil) (type "
 "nil t nil 1 nil) (si::temp-variable nil t nil 2 nil) (si::flag-variable nil t ni"
 "l 3 nil) (si::operations nil t nil 4 nil) (si::infinity-data nil t nil 5 nil)) ("
 "si::make-loop-minimax-internal) ((fixnum most-positive-fixnum most-negative-fixn"
 "um)) (si::keywords si::iteration-keywords si::for-keywords si::path-keywords si:"
 ":type-symbols si::type-keywords si::ansi si::implicit-for-required) ((si::keywor"
 "ds nil t nil 0 nil) (si::iteration-keywords nil t nil 1 nil) (si::for-keywords n"
 "il t nil 2 nil) (si::path-keywords nil t nil 3 nil) (si::type-symbols nil t nil "
 "4 nil) (si::type-keywords nil t nil 5 nil) (si::ansi nil t nil 6 nil) (si::impli"
 "cit-for-required nil t nil 7 nil)) (si::make-loop-universe) \"LOOP-DESETQ-TEMP\" \""
 "LOOP-NOT-FIRST-TIME\" (si::name class (si::history nil) (si::tempvars nil) si::dt"
 "ype (si::data nil)) ((si::name nil t nil 0 nil) (class nil t nil 1 nil) (si::his"
 "tory nil t nil 2 nil) (si::tempvars nil t nil 3 nil) (si::dtype nil t nil 4 nil)"
 " (si::data nil t nil 5 nil)) (si::make-loop-collector) (si::names si::prepositio"
 "n-groups si::inclusive-permitted function si::user-data) ((si::names nil t nil 0"
 " nil) (si::preposition-groups nil t nil 1 nil) (si::inclusive-permitted nil t ni"
 "l 2 nil) (function nil t nil 3 nil) (si::user-data nil t nil 4 nil)) (si::make-l"
 "oop-path)" };

static const cl_object compiler_data_text[] = {
(cl_object)compiler_data_text1,
NULL};
